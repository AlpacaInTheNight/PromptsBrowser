{"version":3,"file":"promptBrowser.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACjUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACjaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACjQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACjcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACvTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AClTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACxdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACncA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AC9SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AC3MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACvMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AEvBA;AACA;AACA;AACA","sources":["webpack://promptsbrowser/./client/ActivePrompts/convertToGroup.ts","webpack://promptsbrowser/./client/ActivePrompts/getPromptByIndexInBranch.ts","webpack://promptsbrowser/./client/ActivePrompts/index.ts","webpack://promptsbrowser/./client/ActivePrompts/insertPromptInBranch.ts","webpack://promptsbrowser/./client/ActivePrompts/reindexPromptGroups.ts","webpack://promptsbrowser/./client/ActivePrompts/removePromptInBranch.ts","webpack://promptsbrowser/./client/ActivePrompts/unGroupInBranch.ts","webpack://promptsbrowser/./client/CollectionTools/event.ts","webpack://promptsbrowser/./client/CollectionTools/generateNextPreview.ts","webpack://promptsbrowser/./client/CollectionTools/index.ts","webpack://promptsbrowser/./client/ControlPanel/index.ts","webpack://promptsbrowser/./client/CurrentPrompts/event.ts","webpack://promptsbrowser/./client/CurrentPrompts/index.ts","webpack://promptsbrowser/./client/CurrentPrompts/showPrompts.ts","webpack://promptsbrowser/./client/Database/index.ts","webpack://promptsbrowser/./client/KnownPrompts/event.ts","webpack://promptsbrowser/./client/KnownPrompts/index.ts","webpack://promptsbrowser/./client/LoadStyle/event.ts","webpack://promptsbrowser/./client/LoadStyle/index.ts","webpack://promptsbrowser/./client/PreviewSave/index.ts","webpack://promptsbrowser/./client/PromptEdit/event.ts","webpack://promptsbrowser/./client/PromptEdit/index.ts","webpack://promptsbrowser/./client/PromptScribe/event.ts","webpack://promptsbrowser/./client/PromptScribe/index.ts","webpack://promptsbrowser/./client/PromptTools/event.ts","webpack://promptsbrowser/./client/PromptTools/index.ts","webpack://promptsbrowser/./client/PromptWordTooltip/event.ts","webpack://promptsbrowser/./client/PromptWordTooltip/index.ts","webpack://promptsbrowser/./client/PromptsFilter/index.ts","webpack://promptsbrowser/./client/PromptsFilter/simple.ts","webpack://promptsbrowser/./client/SaveStyle/event.ts","webpack://promptsbrowser/./client/SaveStyle/index.ts","webpack://promptsbrowser/./client/SetupWindow/event.ts","webpack://promptsbrowser/./client/SetupWindow/index.ts","webpack://promptsbrowser/./client/TagTooltip/event.ts","webpack://promptsbrowser/./client/TagTooltip/index.ts","webpack://promptsbrowser/./client/applyStyle.ts","webpack://promptsbrowser/./client/categories.ts","webpack://promptsbrowser/./client/checkFilter.ts","webpack://promptsbrowser/./client/const.ts","webpack://promptsbrowser/./client/dom.ts","webpack://promptsbrowser/./client/index.ts","webpack://promptsbrowser/./client/initialState.ts","webpack://promptsbrowser/./client/showPromptItem.ts","webpack://promptsbrowser/./client/supportedContainers.ts","webpack://promptsbrowser/./client/synchroniseCurrentPrompts.ts","webpack://promptsbrowser/./client/types/style.ts","webpack://promptsbrowser/./client/utils/index.ts","webpack://promptsbrowser/./client/utils/parseGroups.ts","webpack://promptsbrowser/./client/utils/promptStringToObject.ts","webpack://promptsbrowser/webpack/bootstrap","webpack://promptsbrowser/webpack/before-startup","webpack://promptsbrowser/webpack/startup","webpack://promptsbrowser/webpack/after-startup"],"sourcesContent":["define([\"require\", \"exports\", \"./index\"], function (require, exports, index_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function convertToGroup({ index, groupId = false, currentGroupId = false, branch, terminator = 0 }) {\r\n        if (terminator > 100)\r\n            return false;\r\n        let isRoot = false;\r\n        let isTargetBranch = false;\r\n        if (!branch) {\r\n            branch = index_1.default.getCurrentPrompts();\r\n            isRoot = true;\r\n        }\r\n        if (isRoot && groupId === false)\r\n            isTargetBranch = true;\r\n        else if (groupId === currentGroupId)\r\n            isTargetBranch = true;\r\n        if (isTargetBranch) {\r\n            const targetEntity = branch[index];\r\n            if (!targetEntity)\r\n                return false;\r\n            const newGroup = {\r\n                groupId: undefined,\r\n                parentGroup: currentGroupId,\r\n                weight: 0,\r\n                prompts: [targetEntity],\r\n            };\r\n            branch[index] = newGroup;\r\n            return branch[index];\r\n        }\r\n        else {\r\n            for (const branchItem of branch) {\r\n                if (\"groupId\" in branchItem) {\r\n                    const result = convertToGroup({\r\n                        index,\r\n                        groupId,\r\n                        currentGroupId: branchItem.groupId,\r\n                        branch: branchItem.prompts,\r\n                        terminator: terminator + 1\r\n                    });\r\n                    if (result)\r\n                        return result;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    exports.default = convertToGroup;\r\n});\r\n","define([\"require\", \"exports\", \"./index\"], function (require, exports, index_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function getPromptByIndexInBranch({ index, branch, terminator = 0, groupId = false, currentGroupId = false }) {\r\n        if (terminator > 100)\r\n            return false;\r\n        if (!branch)\r\n            branch = index_1.default.getCurrentPrompts();\r\n        if (groupId === currentGroupId) {\r\n            const target = branch[index];\r\n            if (target && \"id\" in target)\r\n                return target;\r\n            else\r\n                return false;\r\n        }\r\n        for (const branchItem of branch) {\r\n            if (groupId !== false && \"groupId\" in branchItem) {\r\n                const { prompts } = branchItem;\r\n                const result = getPromptByIndexInBranch({\r\n                    index,\r\n                    branch: prompts,\r\n                    terminator: terminator + 1,\r\n                    groupId,\r\n                    currentGroupId: branchItem.groupId,\r\n                });\r\n                if (result)\r\n                    return result;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    exports.default = getPromptByIndexInBranch;\r\n});\r\n","define([\"require\", \"exports\", \"client/index\", \"client/utils/index\", \"./reindexPromptGroups\", \"./getPromptByIndexInBranch\", \"./insertPromptInBranch\", \"./removePromptInBranch\", \"./convertToGroup\", \"./unGroupInBranch\"], function (require, exports, index_1, index_2, reindexPromptGroups_1, getPromptByIndexInBranch_1, insertPromptInBranch_1, removePromptInBranch_1, convertToGroup_1, unGroupInBranch_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class ActivePrompts {\r\n        static getUniqueIdsInBranch(uniqueArray, branch) {\r\n            let isRoot = false;\r\n            if (!branch) {\r\n                branch = ActivePrompts.getCurrentPrompts();\r\n                isRoot = true;\r\n            }\r\n            for (const branchItem of branch) {\r\n                if (\"groupId\" in branchItem)\r\n                    ActivePrompts.getUniqueIdsInBranch(uniqueArray, branchItem.prompts);\r\n                else if (!branchItem.isSyntax) {\r\n                    if (!uniqueArray.includes(branchItem.id))\r\n                        uniqueArray.push(branchItem.id);\r\n                }\r\n            }\r\n        }\r\n        static getUniqueIds(branch) {\r\n            const uniqueArray = [];\r\n            ActivePrompts.getUniqueIdsInBranch(uniqueArray, branch);\r\n            return uniqueArray;\r\n        }\r\n        static getUniqueInBranch(uniqueArray, branch) {\r\n            let isRoot = false;\r\n            if (!branch) {\r\n                branch = ActivePrompts.getCurrentPrompts();\r\n                isRoot = true;\r\n            }\r\n            for (const branchItem of branch) {\r\n                if (\"groupId\" in branchItem)\r\n                    ActivePrompts.getUniqueInBranch(uniqueArray, branchItem.prompts);\r\n                else if (!branchItem.isSyntax) {\r\n                    if (!uniqueArray.some(item => item.id === branchItem.id))\r\n                        uniqueArray.push(branchItem);\r\n                }\r\n            }\r\n        }\r\n        static getUnique() {\r\n            const uniqueArray = [];\r\n            ActivePrompts.getUniqueInBranch(uniqueArray);\r\n            return uniqueArray;\r\n        }\r\n        static getPromptByIndex(index, groupId) {\r\n            return (0, getPromptByIndexInBranch_1.default)({ index, groupId });\r\n        }\r\n        static getPromptById({ id, groupId = false, currentGroupId = false, branch, terminator = 0 }) {\r\n            if (terminator > 100)\r\n                return false;\r\n            if (!branch)\r\n                branch = ActivePrompts.getCurrentPrompts();\r\n            for (const branchItem of branch) {\r\n                if (\"id\" in branchItem && branchItem.id === id && groupId === currentGroupId)\r\n                    return branchItem;\r\n                if (groupId !== false && \"groupId\" in branchItem) {\r\n                    const { prompts } = branchItem;\r\n                    const result = ActivePrompts.getPromptById({\r\n                        id,\r\n                        branch: prompts,\r\n                        terminator: terminator + 1\r\n                    });\r\n                    if (result && result.id === id)\r\n                        return result;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        static removePrompt(index, groupId) {\r\n            (0, removePromptInBranch_1.default)({ index, groupId });\r\n            (0, reindexPromptGroups_1.default)();\r\n        }\r\n        static insertPrompt(prompt, index, groupId = false) {\r\n            const result = (0, insertPromptInBranch_1.default)({ prompt, index, groupId });\r\n            if (result)\r\n                (0, reindexPromptGroups_1.default)();\r\n            return result;\r\n        }\r\n        static replacePrompt(prompt, index, groupId = false) {\r\n            (0, insertPromptInBranch_1.default)({ prompt, index, groupId, isReplace: true });\r\n            //reindexPromptGroups();\r\n        }\r\n        static movePrompt({ from, to }) {\r\n            const origin = (0, index_2.clone)(ActivePrompts.getCurrentPrompts());\r\n            const fromElement = (0, removePromptInBranch_1.default)(Object.assign({}, from));\r\n            if (!fromElement || !fromElement[0])\r\n                return false;\r\n            const result = ActivePrompts.insertPrompt(fromElement[0], to.index, to.groupId);\r\n            if (!result)\r\n                ActivePrompts.setCurrentPrompts(origin);\r\n            return result;\r\n        }\r\n        static groupPrompts({ from, to }) {\r\n            const origin = (0, index_2.clone)(ActivePrompts.getCurrentPrompts());\r\n            const result = (0, convertToGroup_1.default)(Object.assign({}, to));\r\n            if (!result)\r\n                return false;\r\n            const fromElement = (0, removePromptInBranch_1.default)(Object.assign({}, from));\r\n            if (!fromElement || !fromElement[0]) {\r\n                ActivePrompts.setCurrentPrompts(origin);\r\n                return false;\r\n            }\r\n            result.prompts.push(fromElement[0]);\r\n            (0, reindexPromptGroups_1.default)();\r\n            return true;\r\n        }\r\n        static getGroupById(id, branch) {\r\n            if (!branch)\r\n                branch = ActivePrompts.getCurrentPrompts();\r\n            for (const branchItem of branch) {\r\n                if (\"groupId\" in branchItem) {\r\n                    if (branchItem.groupId === id)\r\n                        return branchItem;\r\n                    const result = ActivePrompts.getGroupById(id, branchItem.prompts);\r\n                    if (result)\r\n                        return result;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        static makeGroupKey(group) {\r\n            if (typeof group === \"number\")\r\n                group = ActivePrompts.getGroupById(group);\r\n            if (!group || !group.prompts)\r\n                return false;\r\n            const uniquePrompts = ActivePrompts.getUniqueIds(group.prompts);\r\n            const key = uniquePrompts.join(\" \");\r\n            return key;\r\n        }\r\n        static updateFoldedKeys(branch) {\r\n            if (!branch) {\r\n                ActivePrompts.foldedGroups = [];\r\n                branch = ActivePrompts.getCurrentPrompts();\r\n            }\r\n            for (const branchItem of branch) {\r\n                if (\"groupId\" in branchItem) {\r\n                    if (branchItem.folded) {\r\n                        const key = ActivePrompts.makeGroupKey(branchItem);\r\n                        if (key)\r\n                            ActivePrompts.foldedGroups.push(key);\r\n                    }\r\n                    if (branchItem === null || branchItem === void 0 ? void 0 : branchItem.prompts.length)\r\n                        ActivePrompts.updateFoldedKeys(branchItem.prompts);\r\n                }\r\n            }\r\n        }\r\n        static toggleGroupFold(groupId) {\r\n            const targetGroup = ActivePrompts.getGroupById(groupId);\r\n            if (!targetGroup)\r\n                return false;\r\n            targetGroup.folded = targetGroup.folded ? false : true;\r\n            ActivePrompts.updateFoldedKeys();\r\n            return true;\r\n        }\r\n        static unGroup(groupId) {\r\n            if (groupId === undefined)\r\n                return false;\r\n            const result = (0, unGroupInBranch_1.default)({ groupId });\r\n            if (result)\r\n                (0, reindexPromptGroups_1.default)();\r\n            return result;\r\n        }\r\n    }\r\n    ActivePrompts.foldedGroups = [];\r\n    ActivePrompts.getCurrentPrompts = () => {\r\n        const { state } = index_1.default;\r\n        if (!state.currentPromptsList[state.currentContainer]) {\r\n            state.currentPromptsList[state.currentContainer] = [];\r\n        }\r\n        return state.currentPromptsList[state.currentContainer];\r\n    };\r\n    ActivePrompts.setCurrentPrompts = (currentPrompts = []) => {\r\n        const { state } = index_1.default;\r\n        const { currentPromptsList, currentContainer } = state;\r\n        currentPromptsList[currentContainer] = currentPrompts;\r\n    };\r\n    exports.default = ActivePrompts;\r\n});\r\n","define([\"require\", \"exports\", \"./index\"], function (require, exports, index_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function insertPromptInBranch({ prompt, isReplace = false, index, branch, terminator = 0, groupId, currentGroupId }) {\r\n        if (terminator > 100)\r\n            return false;\r\n        let isRoot = false;\r\n        let isTargetBranch = false;\r\n        if (!branch) {\r\n            branch = index_1.default.getCurrentPrompts();\r\n            isRoot = true;\r\n        }\r\n        if (isRoot && groupId === false)\r\n            isTargetBranch = true;\r\n        else if (groupId === currentGroupId)\r\n            isTargetBranch = true;\r\n        if (isTargetBranch) {\r\n            if (isReplace && \"id\" in prompt) {\r\n                const targetPrompt = branch[index];\r\n                if (!targetPrompt || \"groupId\" in targetPrompt)\r\n                    return false;\r\n                targetPrompt.id = prompt.id;\r\n                targetPrompt.isExternalNetwork = prompt.isExternalNetwork;\r\n            }\r\n            else\r\n                branch.splice(index, 0, prompt);\r\n            return true;\r\n        }\r\n        else {\r\n            for (const branchItem of branch) {\r\n                if (\"groupId\" in branchItem) {\r\n                    const result = insertPromptInBranch({\r\n                        prompt,\r\n                        index,\r\n                        groupId,\r\n                        isReplace,\r\n                        currentGroupId: branchItem.groupId,\r\n                        branch: branchItem.prompts,\r\n                        terminator: terminator + 1\r\n                    });\r\n                    if (result)\r\n                        return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    exports.default = insertPromptInBranch;\r\n});\r\n","define([\"require\", \"exports\", \"./index\"], function (require, exports, index_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function reindexPromptGroups(branch, parentGroup) {\r\n        let isRoot = false;\r\n        if (!branch) {\r\n            branch = index_1.default.getCurrentPrompts();\r\n            isRoot = true;\r\n        }\r\n        for (const branchItem of branch) {\r\n            if (\"groupId\" in branchItem)\r\n                reindexPromptGroups(branchItem.prompts, branchItem.groupId);\r\n            if (isRoot)\r\n                delete branchItem.parentGroup;\r\n            else if (branchItem.parentGroup !== parentGroup)\r\n                branchItem.parentGroup = parentGroup;\r\n        }\r\n    }\r\n    exports.default = reindexPromptGroups;\r\n});\r\n","define([\"require\", \"exports\", \"./index\"], function (require, exports, index_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function removePromptInBranch({ index, branch, terminator = 0, groupId, currentGroupId }) {\r\n        if (terminator > 100)\r\n            return false;\r\n        let isRoot = false;\r\n        let isTargetBranch = false;\r\n        if (!branch) {\r\n            branch = index_1.default.getCurrentPrompts();\r\n            isRoot = true;\r\n        }\r\n        if (isRoot && groupId === false)\r\n            isTargetBranch = true;\r\n        else if (groupId === currentGroupId)\r\n            isTargetBranch = true;\r\n        if (isTargetBranch) {\r\n            return branch.splice(index, 1);\r\n        }\r\n        else {\r\n            for (const branchItem of branch) {\r\n                if (\"groupId\" in branchItem) {\r\n                    const result = removePromptInBranch({\r\n                        index,\r\n                        groupId,\r\n                        currentGroupId: branchItem.groupId,\r\n                        branch: branchItem.prompts,\r\n                        terminator: terminator + 1\r\n                    });\r\n                    if (result !== false)\r\n                        return result;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    exports.default = removePromptInBranch;\r\n});\r\n","define([\"require\", \"exports\", \"./index\"], function (require, exports, index_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function unGroupInBranch({ groupId, currentGroupId = false, branch, terminator = 0 }) {\r\n        if (terminator > 100)\r\n            return false;\r\n        if (!branch)\r\n            branch = index_1.default.getCurrentPrompts();\r\n        for (let index = 0; index < branch.length; index++) {\r\n            const branchItem = branch[index];\r\n            if (\"groupId\" in branchItem) {\r\n                if (branchItem.groupId === groupId) {\r\n                    const { prompts = [] } = branchItem;\r\n                    branch.splice(index, 1, ...prompts);\r\n                    return true;\r\n                }\r\n                const result = unGroupInBranch({\r\n                    groupId,\r\n                    currentGroupId: branchItem.groupId,\r\n                    branch: branchItem.prompts,\r\n                    terminator: terminator + 1\r\n                });\r\n                if (result)\r\n                    return result;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    exports.default = unGroupInBranch;\r\n});\r\n","define([\"require\", \"exports\", \"./index\", \"client/index\", \"client/Database/index\", \"client/PromptEdit/index\", \"client/checkFilter\", \"./generateNextPreview\"], function (require, exports, index_1, index_2, index_3, index_4, checkFilter_1, generateNextPreview_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class CollectionToolsEvent {\r\n        static onCloseWindow() {\r\n            const wrapper = index_2.default.DOMCache.collectionTools;\r\n            if (!wrapper)\r\n                return;\r\n            clearTimeout(index_1.default.generateNextTimer);\r\n            wrapper.style.display = \"none\";\r\n        }\r\n        static onChangeAutogenerateType(e) {\r\n            const { state } = index_2.default;\r\n            const target = e.currentTarget;\r\n            const value = target.value;\r\n            if (!value)\r\n                return;\r\n            state.autoGenerateType = value;\r\n        }\r\n        static onGeneratePreviews(e) {\r\n            const { state } = index_2.default;\r\n            const { data } = index_3.default;\r\n            const { autogen } = index_1.default;\r\n            const { selectedCollectionPrompts, collectionToolsId, autoGenerateType } = state;\r\n            const textArea = index_2.default.DOMCache.containers[state.currentContainer].textArea;\r\n            const targetCollection = data.original[collectionToolsId];\r\n            let currentPrompt = \"\";\r\n            if (!selectedCollectionPrompts || !selectedCollectionPrompts.length || !targetCollection)\r\n                return;\r\n            index_1.default.generateQueue = [];\r\n            if (autoGenerateType === \"current\" && textArea) {\r\n                currentPrompt = textArea.value;\r\n            }\r\n            for (const promptId of selectedCollectionPrompts) {\r\n                const prompt = targetCollection.find(item => item.id === promptId);\r\n                if (!prompt)\r\n                    continue;\r\n                const generateItem = {\r\n                    id: promptId,\r\n                };\r\n                if (autoGenerateType === \"current\") {\r\n                    generateItem.addPrompts = currentPrompt;\r\n                }\r\n                else if (autoGenerateType === \"autogen\") {\r\n                    if (prompt.autogen)\r\n                        generateItem.autogen = Object.assign({}, prompt.autogen);\r\n                }\r\n                else if (autoGenerateType === \"selected\") {\r\n                    if (prompt.autogen)\r\n                        generateItem.autogen = Object.assign({}, autogen);\r\n                }\r\n                index_1.default.generateQueue.push(generateItem);\r\n            }\r\n            (0, generateNextPreview_1.default)();\r\n        }\r\n        static onAssignAutogenStyle(e) {\r\n            const { state } = index_2.default;\r\n            const { data } = index_3.default;\r\n            const { collection, style } = index_1.default.autogen;\r\n            const { selectedCollectionPrompts, collectionToolsId } = state;\r\n            const targetCollection = data.original[collectionToolsId];\r\n            if (!selectedCollectionPrompts || !selectedCollectionPrompts.length || !targetCollection)\r\n                return;\r\n            for (const promptId of selectedCollectionPrompts) {\r\n                const prompt = targetCollection.find(item => item.id === promptId);\r\n                if (!prompt)\r\n                    continue;\r\n                if (collection && style)\r\n                    prompt.autogen = { collection, style };\r\n                else\r\n                    delete prompt.autogen;\r\n            }\r\n            index_1.default.updateCurrentCollection();\r\n        }\r\n        static onAddCategory(e) {\r\n            const { state } = index_2.default;\r\n            const { data } = index_3.default;\r\n            const target = e.currentTarget;\r\n            const parent = target.parentElement;\r\n            const { selectedCollectionPrompts, collectionToolsId } = state;\r\n            const targetCollection = data.original[collectionToolsId];\r\n            const categorySelect = parent.querySelector(\".PBE_categoryAction\");\r\n            if (!categorySelect)\r\n                return;\r\n            const categoryId = categorySelect.value;\r\n            if (!selectedCollectionPrompts || !selectedCollectionPrompts.length || !targetCollection)\r\n                return;\r\n            for (const promptId of selectedCollectionPrompts) {\r\n                const prompt = targetCollection.find(item => item.id === promptId);\r\n                if (!prompt)\r\n                    continue;\r\n                if (!prompt.category)\r\n                    prompt.category = [];\r\n                if (!prompt.category.includes(categoryId))\r\n                    prompt.category.push(categoryId);\r\n            }\r\n            index_1.default.updateCurrentCollection();\r\n        }\r\n        static onRemoveCategory(e) {\r\n            const { state } = index_2.default;\r\n            const { data } = index_3.default;\r\n            const target = e.currentTarget;\r\n            const parent = target.parentElement;\r\n            const { selectedCollectionPrompts, collectionToolsId } = state;\r\n            const targetCollection = data.original[collectionToolsId];\r\n            const categorySelect = parent.querySelector(\".PBE_categoryAction\");\r\n            if (!categorySelect)\r\n                return;\r\n            const categoryId = categorySelect.value;\r\n            if (!selectedCollectionPrompts || !selectedCollectionPrompts.length || !targetCollection)\r\n                return;\r\n            for (const promptId of selectedCollectionPrompts) {\r\n                const prompt = targetCollection.find(item => item.id === promptId);\r\n                if (!prompt)\r\n                    continue;\r\n                if (!prompt.category)\r\n                    continue;\r\n                if (prompt.category.includes(categoryId))\r\n                    prompt.category = prompt.category.filter(id => id !== categoryId);\r\n            }\r\n            index_1.default.updateCurrentCollection();\r\n        }\r\n        static onAddTags(e) {\r\n            const { state } = index_2.default;\r\n            const { data } = index_3.default;\r\n            const target = e.currentTarget;\r\n            const parent = target.parentElement;\r\n            const { selectedCollectionPrompts, collectionToolsId } = state;\r\n            const targetCollection = data.original[collectionToolsId];\r\n            const tagsInput = parent.querySelector(\".PBE_tagsAction\");\r\n            if (!tagsInput)\r\n                return;\r\n            const tagsValue = tagsInput.value;\r\n            if (!selectedCollectionPrompts || !selectedCollectionPrompts.length || !targetCollection)\r\n                return;\r\n            const tagsArr = tagsValue.split(\",\");\r\n            for (let i = 0; i < tagsArr.length; i++)\r\n                tagsArr[i] = tagsArr[i].trim();\r\n            for (const promptId of selectedCollectionPrompts) {\r\n                const prompt = targetCollection.find(item => item.id === promptId);\r\n                if (!prompt)\r\n                    continue;\r\n                if (!prompt.tags)\r\n                    prompt.tags = [];\r\n                for (const tagItem of tagsArr) {\r\n                    if (!prompt.tags.includes(tagItem))\r\n                        prompt.tags.push(tagItem);\r\n                }\r\n            }\r\n            index_1.default.updateCurrentCollection();\r\n        }\r\n        static onRemoveTags(e) {\r\n            const { state } = index_2.default;\r\n            const { data } = index_3.default;\r\n            const { selectedCollectionPrompts, collectionToolsId } = state;\r\n            const targetCollection = data.original[collectionToolsId];\r\n            const target = e.currentTarget;\r\n            const parent = target.parentElement;\r\n            const tagsInput = parent.querySelector(\".PBE_tagsAction\");\r\n            if (!tagsInput)\r\n                return;\r\n            const tagsValue = tagsInput.value;\r\n            if (!selectedCollectionPrompts || !selectedCollectionPrompts.length || !targetCollection)\r\n                return;\r\n            const tagsArr = tagsValue.split(\",\");\r\n            for (let i = 0; i < tagsArr.length; i++)\r\n                tagsArr[i] = tagsArr[i].trim();\r\n            for (const promptId of selectedCollectionPrompts) {\r\n                const prompt = targetCollection.find(item => item.id === promptId);\r\n                if (!prompt || !prompt.tags)\r\n                    continue;\r\n                prompt.tags = prompt.tags.filter(id => !tagsArr.includes(id));\r\n            }\r\n            index_1.default.updateCurrentCollection();\r\n        }\r\n        static onSelectItem(e) {\r\n            const target = e.currentTarget;\r\n            const parent = target.parentElement;\r\n            const { state } = index_2.default;\r\n            const id = target.dataset.id;\r\n            if (!id)\r\n                return;\r\n            if (e.shiftKey) {\r\n                state.editingPrompt = id;\r\n                index_4.default.update();\r\n                return;\r\n            }\r\n            if (!state.selectedCollectionPrompts.includes(id)) {\r\n                state.selectedCollectionPrompts.push(id);\r\n                parent.classList.add(\"selected\");\r\n            }\r\n            else {\r\n                state.selectedCollectionPrompts = state.selectedCollectionPrompts.filter(promptId => promptId !== id);\r\n                parent.classList.remove(\"selected\");\r\n            }\r\n            index_1.default.updateSelectedInfo();\r\n        }\r\n        static onToggleSelected(e) {\r\n            const { promptsFilter } = index_2.default.state;\r\n            const { state } = index_2.default;\r\n            const { data } = index_3.default;\r\n            const { collectionToolsId } = state;\r\n            const filterSetup = promptsFilter[\"collectionTools\"];\r\n            const targetCollection = data.original[collectionToolsId];\r\n            if (!targetCollection)\r\n                return;\r\n            if (state.selectedCollectionPrompts.length) {\r\n                state.selectedCollectionPrompts = [];\r\n                index_1.default.update();\r\n                return;\r\n            }\r\n            state.selectedCollectionPrompts = [];\r\n            for (const item of targetCollection) {\r\n                if ((0, checkFilter_1.default)(item, filterSetup))\r\n                    state.selectedCollectionPrompts.push(item.id);\r\n            }\r\n            index_1.default.update();\r\n        }\r\n        /**\r\n         * Deletes selected prompts after a user confirmation\r\n         */\r\n        static onDeleteSelected(e) {\r\n            const { state } = index_2.default;\r\n            const { data } = index_3.default;\r\n            const { selectedCollectionPrompts, collectionToolsId } = state;\r\n            const targetCollection = data.original[collectionToolsId];\r\n            if (!selectedCollectionPrompts || !selectedCollectionPrompts.length || !targetCollection)\r\n                return;\r\n            if (confirm(`Remove ${selectedCollectionPrompts.length} prompts from catalogue \"${collectionToolsId}\"?`)) {\r\n                data.original[collectionToolsId] = targetCollection.filter(prompt => !selectedCollectionPrompts.includes(prompt.id));\r\n                for (const deletedPromptId of selectedCollectionPrompts) {\r\n                    index_3.default.movePreviewImage(deletedPromptId, collectionToolsId, collectionToolsId, \"delete\");\r\n                }\r\n                index_3.default.saveJSONData(collectionToolsId);\r\n                index_3.default.updateMixedList();\r\n                state.selectedCollectionPrompts = [];\r\n                index_1.default.updateViews();\r\n            }\r\n        }\r\n        /**\r\n         * Moves or copies the selected prompts to the selected collection.\r\n         * By default moves prompts.\r\n         * @param {*} e - mouse event object.\r\n         * @param {*} isCopy if copy actions is required instead of move action.\r\n         */\r\n        static onMoveSelected(e, isCopy = false) {\r\n            const { state } = index_2.default;\r\n            const { data } = index_3.default;\r\n            const { selectedCollectionPrompts, collectionToolsId, copyOrMoveTo } = state;\r\n            const targetCollection = data.original[collectionToolsId];\r\n            if (!selectedCollectionPrompts || !selectedCollectionPrompts.length || !targetCollection || !copyOrMoveTo)\r\n                return;\r\n            const to = state.copyOrMoveTo;\r\n            const from = state.collectionToolsId;\r\n            if (!to || !from)\r\n                return;\r\n            if (!data.original[to] || !data.original[from])\r\n                return;\r\n            let message = `${isCopy ? \"Copy\" : \"Move\"} ${selectedCollectionPrompts.length} prompts`;\r\n            message += ` from catalogue \"${collectionToolsId}\" to catalogue \"${copyOrMoveTo}\"?`;\r\n            if (confirm(message)) {\r\n                for (const promptId of selectedCollectionPrompts) {\r\n                    const originalItem = data.original[from].find(item => item.id === promptId);\r\n                    if (!originalItem)\r\n                        continue;\r\n                    if (isCopy) {\r\n                        if (data.original[to].some(item => item.id === promptId))\r\n                            continue;\r\n                        data.original[to].push(JSON.parse(JSON.stringify(originalItem)));\r\n                        index_3.default.movePreviewImage(promptId, from, to, \"copy\");\r\n                    }\r\n                    else {\r\n                        if (!data.original[to].some(item => item.id === promptId)) {\r\n                            data.original[to].push(JSON.parse(JSON.stringify(originalItem)));\r\n                        }\r\n                        data.original[from] = data.original[from].filter(item => item.id !== promptId);\r\n                        index_3.default.movePreviewImage(promptId, from, to, \"move\");\r\n                    }\r\n                }\r\n                if (isCopy) {\r\n                    index_3.default.saveJSONData(to, true);\r\n                }\r\n                else {\r\n                    index_3.default.saveJSONData(to, true);\r\n                    index_3.default.saveJSONData(from, true);\r\n                }\r\n                index_3.default.updateMixedList();\r\n                state.selectedCollectionPrompts = [];\r\n                index_1.default.updateViews();\r\n            }\r\n        }\r\n        static onChangeAutogenCollection(e) {\r\n            const { data } = index_3.default;\r\n            const target = e.currentTarget;\r\n            const collection = target.value;\r\n            let setFirst = false;\r\n            index_1.default.autogen.collection = collection;\r\n            if (collection && index_1.default.autogenStyleSelector) {\r\n                let styleOptions = \"\";\r\n                const targetCollection = data.styles[collection];\r\n                if (targetCollection) {\r\n                    for (const styleItem of targetCollection) {\r\n                        if (!setFirst) {\r\n                            index_1.default.autogen.style = styleItem.name;\r\n                            index_1.default.autogenStyleSelector.value = styleItem.name;\r\n                            setFirst = true;\r\n                        }\r\n                        styleOptions += `<option value=\"${styleItem.name}\">${styleItem.name}</option>`;\r\n                    }\r\n                }\r\n                index_1.default.autogenStyleSelector.innerHTML = styleOptions;\r\n            }\r\n        }\r\n        static onChangeAutogenStyle(e) {\r\n            const target = e.currentTarget;\r\n            const style = target.value;\r\n            index_1.default.autogen.style = style;\r\n        }\r\n    }\r\n    CollectionToolsEvent.onCopySelected = (e) => CollectionToolsEvent.onMoveSelected(e, true);\r\n    exports.default = CollectionToolsEvent;\r\n});\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\ndefine([\"require\", \"exports\", \"./index\", \"client/index\", \"client/Database/index\", \"client/KnownPrompts/index\", \"client/CurrentPrompts/index\", \"client/PreviewSave/index\", \"client/applyStyle\", \"client/utils/index\"], function (require, exports, index_1, index_2, index_3, index_4, index_5, index_6, applyStyle_1, index_7) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function generateNextPreview() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { state } = index_2.default;\r\n            const { data } = index_3.default;\r\n            const { collectionToolsId } = state;\r\n            const { generateQueue } = index_1.default;\r\n            const textArea = index_2.default.DOMCache.containers[state.currentContainer].textArea;\r\n            const generateButton = index_2.default.DOMCache.containers[state.currentContainer].generateButton;\r\n            if (!textArea || !generateButton)\r\n                return;\r\n            const nextItem = generateQueue.shift();\r\n            if (!nextItem) {\r\n                (0, index_7.log)(\"Finished generating prompt previews.\");\r\n                state.selectedPrompt = undefined;\r\n                state.filesIteration++;\r\n                index_3.default.updateMixedList();\r\n                index_6.default.update();\r\n                index_4.default.update();\r\n                index_5.default.update(true);\r\n                index_1.default.update(true);\r\n                return;\r\n            }\r\n            const message = `Generating preview for \"${nextItem.id}\". ${generateQueue.length} items in queue left. `;\r\n            (0, index_7.log)(message);\r\n            index_1.default.updateAutogenInfo(message);\r\n            state.selectedPrompt = nextItem.id;\r\n            state.savePreviewCollection = collectionToolsId;\r\n            if (nextItem.autogen && nextItem.autogen.collection && nextItem.autogen.style) {\r\n                const delay = (ms) => new Promise(res => setTimeout(res, ms));\r\n                const targetCollection = data.styles[nextItem.autogen.collection];\r\n                if (targetCollection) {\r\n                    const targetStyle = targetCollection.find(item => item.name === nextItem.autogen.style);\r\n                    if (targetStyle) {\r\n                        (0, applyStyle_1.default)(targetStyle, true, true);\r\n                        yield delay(600); //need a pause due to a hacky nature of changing APP state\r\n                        textArea.value = `((${nextItem.id})), ${textArea.value}`;\r\n                    }\r\n                }\r\n            }\r\n            else if (nextItem.addPrompts) {\r\n                textArea.value = `((${nextItem.id})), ${nextItem.addPrompts}`;\r\n            }\r\n            else\r\n                textArea.value = nextItem.id;\r\n            textArea.dispatchEvent(new Event('focus'));\r\n            textArea.dispatchEvent(new Event('input'));\r\n            textArea.dispatchEvent(new KeyboardEvent('keyup'));\r\n            textArea.dispatchEvent(new KeyboardEvent('keypress'));\r\n            textArea.dispatchEvent(new Event('blur'));\r\n            generateButton.dispatchEvent(new Event('click'));\r\n            clearTimeout(index_1.default.generateNextTimer);\r\n            index_1.default.generateNextTimer = setTimeout(index_1.default.checkProgressState, 100);\r\n        });\r\n    }\r\n    exports.default = generateNextPreview;\r\n});\r\n","define([\"require\", \"exports\", \"client/index\", \"client/Database/index\", \"client/KnownPrompts/index\", \"client/CurrentPrompts/index\", \"client/PromptsFilter/index\", \"client/TagTooltip/index\", \"client/dom\", \"client/checkFilter\", \"./event\", \"./generateNextPreview\"], function (require, exports, index_1, index_2, index_3, index_4, index_5, index_6, dom_1, checkFilter_1, event_1, generateNextPreview_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class CollectionTools {\r\n        static init(wrapper) {\r\n            const collectionTools = document.createElement(\"div\");\r\n            collectionTools.className = \"PBE_generalWindow PBE_collectionToolsWindow\";\r\n            collectionTools.id = \"PBE_collectionTools\";\r\n            index_1.default.DOMCache.collectionTools = collectionTools;\r\n            CollectionTools.generateQueue = [];\r\n            clearTimeout(CollectionTools.generateNextTimer);\r\n            wrapper.appendChild(collectionTools);\r\n            index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n            collectionTools.addEventListener(\"click\", () => {\r\n                index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n            });\r\n        }\r\n        /**\r\n         * Updates UI components that shows existing prompts\r\n         */\r\n        static updateViews() {\r\n            index_3.default.update();\r\n            CollectionTools.update();\r\n            index_4.default.update(true);\r\n        }\r\n        static updateCurrentCollection() {\r\n            const { state } = index_1.default;\r\n            const { data } = index_2.default;\r\n            const { promptsFilter } = index_1.default.state;\r\n            const { collectionToolsId, selectedCollectionPrompts } = state;\r\n            if (!collectionToolsId)\r\n                return;\r\n            const filterSetup = promptsFilter[\"collectionTools\"];\r\n            const targetCollection = data.original[collectionToolsId];\r\n            if (!targetCollection)\r\n                return;\r\n            for (const item of targetCollection) {\r\n                const { id } = item;\r\n                if (!id)\r\n                    continue;\r\n                /**\r\n                 * Removing prompt from selected if it will not be shown.\r\n                 */\r\n                if (!(0, checkFilter_1.default)(item, filterSetup)) {\r\n                    if (selectedCollectionPrompts.includes(id)) {\r\n                        state.selectedCollectionPrompts = state.selectedCollectionPrompts.filter(selId => selId !== id);\r\n                    }\r\n                    continue;\r\n                }\r\n            }\r\n            index_2.default.saveJSONData(collectionToolsId);\r\n            index_2.default.updateMixedList();\r\n            CollectionTools.updateViews();\r\n        }\r\n        static checkProgressState() {\r\n            const { state } = index_1.default;\r\n            const resultsContainer = index_1.default.DOMCache.containers[state.currentContainer].resultsContainer;\r\n            if (!resultsContainer)\r\n                return;\r\n            /**\r\n             * Progress bar is being added during generation and is removed from the DOM after generation finished.\r\n             * Its presence serves as a marker when checking the state of generation.\r\n             */\r\n            const progressBar = resultsContainer.querySelector(\".progressDiv\");\r\n            if (!progressBar) {\r\n                index_2.default.savePromptPreview(false);\r\n                (0, generateNextPreview_1.default)();\r\n                return;\r\n            }\r\n            clearTimeout(CollectionTools.generateNextTimer);\r\n            CollectionTools.generateNextTimer = setTimeout(CollectionTools.checkProgressState, 500);\r\n        }\r\n        static showHeader(wrapper) {\r\n            index_5.default.update(wrapper, \"collectionTools\");\r\n        }\r\n        static showPromptsDetailed(wrapper) {\r\n            const { promptsFilter } = index_1.default.state;\r\n            const filterSetup = promptsFilter[\"collectionTools\"];\r\n            const { state } = index_1.default;\r\n            const { data } = index_2.default;\r\n            const { collectionToolsId, selectedCollectionPrompts } = state;\r\n            const targetCollection = data.original[collectionToolsId];\r\n            if (!targetCollection)\r\n                return;\r\n            wrapper.classList.add(\"PBE_detailedItemContainer\");\r\n            for (const item of targetCollection) {\r\n                const { id, tags = [], category = [], comment = \"\", previewImage } = item;\r\n                if (!id)\r\n                    continue;\r\n                /**\r\n                 * Removing prompt from selected if it will not be shown.\r\n                 */\r\n                if (!(0, checkFilter_1.default)(item, filterSetup)) {\r\n                    if (selectedCollectionPrompts.includes(id)) {\r\n                        state.selectedCollectionPrompts = state.selectedCollectionPrompts.filter(selId => selId !== id);\r\n                    }\r\n                    continue;\r\n                }\r\n                const promptContainer = document.createElement(\"div\");\r\n                const selectArea = document.createElement(\"div\");\r\n                const contentArea = document.createElement(\"div\");\r\n                const topContainer = document.createElement(\"div\");\r\n                const bottomContainer = document.createElement(\"div\");\r\n                const nameContainer = document.createElement(\"div\");\r\n                const tagsContainer = document.createElement(\"div\");\r\n                const categoriesContainer = document.createElement(\"div\");\r\n                const commentContainer = document.createElement(\"div\");\r\n                selectArea.dataset.id = id;\r\n                selectArea.className = \"PBE_detailedItemSelector\";\r\n                contentArea.className = \"PBE_detailedItemContent\";\r\n                selectArea.style.backgroundImage = index_2.default.getPromptPreviewURL(id, collectionToolsId);\r\n                promptContainer.className = \"PBE_detailedItem\";\r\n                topContainer.className = \"PBE_detailedItemTop\";\r\n                bottomContainer.className = \"PBE_detailedItemBottom\";\r\n                nameContainer.className = \"PBE_detailedItemName\";\r\n                commentContainer.className = \"PBE_detailedItemComment\";\r\n                tagsContainer.className = \"PBE_detailedItemTags\";\r\n                categoriesContainer.className = \"PBE_detailedItemCategories\";\r\n                nameContainer.innerText = id;\r\n                tagsContainer.innerText = tags.join(\", \");\r\n                categoriesContainer.innerText = category.join(\", \");\r\n                commentContainer.innerText = comment;\r\n                topContainer.appendChild(nameContainer);\r\n                topContainer.appendChild(commentContainer);\r\n                if (tags.length || category.length) {\r\n                    bottomContainer.appendChild(tagsContainer);\r\n                    bottomContainer.appendChild(categoriesContainer);\r\n                }\r\n                contentArea.appendChild(topContainer);\r\n                contentArea.appendChild(bottomContainer);\r\n                promptContainer.appendChild(selectArea);\r\n                promptContainer.appendChild(contentArea);\r\n                selectArea.addEventListener(\"click\", event_1.default.onSelectItem);\r\n                if (selectedCollectionPrompts.includes(id))\r\n                    promptContainer.classList.add(\"selected\");\r\n                wrapper.appendChild(promptContainer);\r\n            }\r\n        }\r\n        static showPromptsShort(wrapper) {\r\n        }\r\n        static showCopyOrMove(wrapper) {\r\n            const { state } = index_1.default;\r\n            const { data } = index_2.default;\r\n            const { collectionToolsId } = state;\r\n            const collectionSelect = document.createElement(\"select\");\r\n            collectionSelect.className = \"PBE_generalInput PBE_select\";\r\n            const moveButton = document.createElement(\"div\");\r\n            moveButton.innerText = \"Move\";\r\n            moveButton.className = \"PBE_button\";\r\n            moveButton.title = \"Move selected prompts to the target collection\";\r\n            moveButton.addEventListener(\"click\", event_1.default.onMoveSelected);\r\n            const copyButton = document.createElement(\"div\");\r\n            copyButton.innerText = \"Copy\";\r\n            copyButton.className = \"PBE_button\";\r\n            copyButton.title = \"Copy selected prompts to the target collection\";\r\n            copyButton.addEventListener(\"click\", event_1.default.onCopySelected);\r\n            let options = \"\";\r\n            for (const collectionId in data.original) {\r\n                if (collectionId === collectionToolsId)\r\n                    continue;\r\n                if (!state.copyOrMoveTo)\r\n                    state.copyOrMoveTo = collectionId;\r\n                options += `<option value=\"${collectionId}\">${collectionId}</option>`;\r\n            }\r\n            collectionSelect.innerHTML = options;\r\n            collectionSelect.addEventListener(\"change\", (e) => {\r\n                const target = e.currentTarget;\r\n                const value = target.value;\r\n                state.copyOrMoveTo = value || undefined;\r\n            });\r\n            const container = document.createElement(\"fieldset\");\r\n            container.className = \"PBE_fieldset\";\r\n            const legend = document.createElement(\"legend\");\r\n            legend.innerText = \"Collection\";\r\n            container.appendChild(legend);\r\n            container.appendChild(collectionSelect);\r\n            container.appendChild(moveButton);\r\n            container.appendChild(copyButton);\r\n            wrapper.appendChild(container);\r\n        }\r\n        static showCategoryAction(wrapper) {\r\n            const { data } = index_2.default;\r\n            const categories = data.categories;\r\n            let options = \"\";\r\n            const categorySelect = document.createElement(\"select\");\r\n            const addButton = document.createElement(\"div\");\r\n            const removeButton = document.createElement(\"div\");\r\n            categorySelect.className = \"PBE_generalInput PBE_select PBE_categoryAction\";\r\n            addButton.className = \"PBE_button\";\r\n            addButton.title = \"Add selected category to all selected prompts\";\r\n            removeButton.className = \"PBE_button PBE_buttonCancel\";\r\n            addButton.innerText = \"Add\";\r\n            removeButton.title = \"Remove selected category from all selected prompts\";\r\n            removeButton.innerText = \"Remove\";\r\n            for (const categoryItem of categories) {\r\n                if (!categorySelect.value)\r\n                    categorySelect.value = categoryItem;\r\n                options += `<option value=\"${categoryItem}\">${categoryItem}</option>`;\r\n            }\r\n            categorySelect.innerHTML = options;\r\n            addButton.addEventListener(\"click\", event_1.default.onAddCategory);\r\n            removeButton.addEventListener(\"click\", event_1.default.onRemoveCategory);\r\n            const container = document.createElement(\"fieldset\");\r\n            container.className = \"PBE_fieldset\";\r\n            const legend = document.createElement(\"legend\");\r\n            legend.innerText = \"Category\";\r\n            container.appendChild(legend);\r\n            container.appendChild(categorySelect);\r\n            container.appendChild(addButton);\r\n            container.appendChild(removeButton);\r\n            wrapper.appendChild(container);\r\n        }\r\n        static showTagsAction(wrapper) {\r\n            const tagsInput = document.createElement(\"input\");\r\n            const addButton = document.createElement(\"div\");\r\n            const removeButton = document.createElement(\"div\");\r\n            tagsInput.placeholder = \"tag1, tag2, tag3\";\r\n            tagsInput.className = \"PBE_generalInput PBE_input PBE_tagsAction\";\r\n            addButton.className = \"PBE_button\";\r\n            removeButton.className = \"PBE_button PBE_buttonCancel\";\r\n            addButton.title = \"Add target tags to all selected prompts\";\r\n            removeButton.title = \"Remove target tags from all selected prompts\";\r\n            addButton.innerText = \"Add\";\r\n            removeButton.innerText = \"Remove\";\r\n            addButton.addEventListener(\"click\", event_1.default.onAddTags);\r\n            removeButton.addEventListener(\"click\", event_1.default.onRemoveTags);\r\n            const container = document.createElement(\"fieldset\");\r\n            container.className = \"PBE_fieldset\";\r\n            const legend = document.createElement(\"legend\");\r\n            legend.innerText = \"Tags\";\r\n            container.appendChild(legend);\r\n            container.appendChild(tagsInput);\r\n            container.appendChild(addButton);\r\n            container.appendChild(removeButton);\r\n            wrapper.appendChild(container);\r\n            index_6.default.add(tagsInput, true);\r\n        }\r\n        static showAutogenStyle(wrapper) {\r\n            const { data } = index_2.default;\r\n            const { collection, style } = CollectionTools.autogen;\r\n            const container = (0, dom_1.makeElement)({ element: \"fieldset\", className: \"PBE_fieldset\" });\r\n            const legend = (0, dom_1.makeElement)({ element: \"legend\", content: \"Autogenerate style\" });\r\n            //collection select\r\n            const colOptions = [{ id: \"__none\", name: \"None\" }];\r\n            for (const colId in data.styles)\r\n                colOptions.push({ id: colId, name: colId });\r\n            const stylesCollectionsSelect = (0, dom_1.makeSelect)({\r\n                className: \"PBE_generalInput PBE_select\", value: collection, options: colOptions,\r\n                onChange: event_1.default.onChangeAutogenCollection\r\n            });\r\n            container.appendChild(stylesCollectionsSelect);\r\n            //style select\r\n            const styleOptions = [];\r\n            if (collection) {\r\n                const targetCollection = data.styles[collection];\r\n                if (targetCollection) {\r\n                    for (const styleItem of targetCollection)\r\n                        styleOptions.push({ id: styleItem.name, name: styleItem.name });\r\n                }\r\n            }\r\n            const styleSelect = (0, dom_1.makeSelect)({\r\n                className: \"PBE_generalInput PBE_select\", value: style || \"\", options: styleOptions,\r\n                onChange: event_1.default.onChangeAutogenStyle\r\n            });\r\n            container.appendChild(styleSelect);\r\n            CollectionTools.autogenStyleSelector = styleSelect;\r\n            //assign button\r\n            const assignButton = (0, dom_1.makeElement)({ element: \"div\", className: \"PBE_button\", content: \"Assign\" });\r\n            assignButton.addEventListener(\"click\", event_1.default.onAssignAutogenStyle);\r\n            container.appendChild(assignButton);\r\n            //append to wrapper\r\n            container.appendChild(legend);\r\n            wrapper.appendChild(container);\r\n        }\r\n        static showAutogenerate(wrapper) {\r\n            const { state } = index_1.default;\r\n            const generateButton = (0, dom_1.makeElement)({ element: \"div\", className: \"PBE_button\", content: \"Generate\" });\r\n            generateButton.addEventListener(\"click\", event_1.default.onGeneratePreviews);\r\n            const generateTypeSelect = (0, dom_1.makeSelect)({\r\n                className: \"PBE_generalInput PBE_select\", value: state.autoGenerateType,\r\n                options: [\r\n                    { id: \"prompt\", name: \"Prompt only\" },\r\n                    { id: \"current\", name: \"With current prompts\" },\r\n                    { id: \"autogen\", name: \"With prompt autogen style\" },\r\n                    { id: \"selected\", name: \"With selected autogen style\" },\r\n                ],\r\n                onChange: event_1.default.onChangeAutogenerateType\r\n            });\r\n            const container = document.createElement(\"fieldset\");\r\n            container.className = \"PBE_fieldset\";\r\n            const legend = document.createElement(\"legend\");\r\n            legend.innerText = \"Generate preview\";\r\n            container.appendChild(legend);\r\n            container.appendChild(generateTypeSelect);\r\n            container.appendChild(generateButton);\r\n            wrapper.appendChild(container);\r\n        }\r\n        static showActions(wrapper) {\r\n            const { data } = index_2.default;\r\n            const toggleAllButton = document.createElement(\"div\");\r\n            toggleAllButton.innerText = \"Toggle all\";\r\n            toggleAllButton.className = \"PBE_button\";\r\n            toggleAllButton.title = \"Select and unselect all visible prompts\";\r\n            toggleAllButton.addEventListener(\"click\", event_1.default.onToggleSelected);\r\n            const deleteButton = document.createElement(\"div\");\r\n            deleteButton.innerText = \"Delete selected\";\r\n            deleteButton.className = \"PBE_button PBE_buttonCancel\";\r\n            deleteButton.title = \"Delete selected prompts\";\r\n            deleteButton.addEventListener(\"click\", event_1.default.onDeleteSelected);\r\n            const container = document.createElement(\"fieldset\");\r\n            container.className = \"PBE_fieldset\";\r\n            const legend = document.createElement(\"legend\");\r\n            legend.innerText = \"Actions\";\r\n            container.appendChild(legend);\r\n            container.appendChild(toggleAllButton);\r\n            container.appendChild(deleteButton);\r\n            wrapper.appendChild(container);\r\n            if (Object.keys(data.original).length > 1)\r\n                CollectionTools.showCopyOrMove(wrapper);\r\n            CollectionTools.showCategoryAction(wrapper);\r\n            CollectionTools.showTagsAction(wrapper);\r\n            CollectionTools.showAutogenStyle(wrapper);\r\n            CollectionTools.showAutogenerate(wrapper);\r\n        }\r\n        static updateAutogenInfo(status, wrapper) {\r\n            if (!wrapper)\r\n                wrapper = document.querySelector(\".PBE_collectionToolsAutogenInfo\");\r\n            if (!wrapper)\r\n                return;\r\n            wrapper.innerText = status;\r\n        }\r\n        static updateSelectedInfo(wrapper) {\r\n            if (!wrapper)\r\n                wrapper = document.querySelector(\".PBE_collectionToolsSelectedInfo\");\r\n            if (!wrapper)\r\n                return;\r\n            const { selectedCollectionPrompts } = index_1.default.state;\r\n            let text = \"\";\r\n            const prevItems = [];\r\n            const MAX_SHOWN_DETAILED = 3;\r\n            if (!selectedCollectionPrompts || !selectedCollectionPrompts.length) {\r\n                wrapper.innerText = \"No items selected\";\r\n                return;\r\n            }\r\n            for (let i = 0; i < selectedCollectionPrompts.length; i++) {\r\n                if (i + 1 > MAX_SHOWN_DETAILED)\r\n                    break;\r\n                prevItems.push(`\"${selectedCollectionPrompts[i]}\"`);\r\n            }\r\n            if (prevItems.length)\r\n                text += prevItems.join(\", \");\r\n            const allSelected = selectedCollectionPrompts.length;\r\n            if (allSelected > MAX_SHOWN_DETAILED) {\r\n                text += `, and ${allSelected - MAX_SHOWN_DETAILED} more items selected.`;\r\n            }\r\n            wrapper.innerText = text;\r\n        }\r\n        static showStatus(wrapper) {\r\n            const autogenStatus = (0, dom_1.makeDiv)({ className: \"PBE_collectionToolsAutogenInfo\" });\r\n            const selectedStatus = (0, dom_1.makeDiv)({ className: \"PBE_collectionToolsSelectedInfo\" });\r\n            CollectionTools.updateAutogenInfo(\"\", autogenStatus);\r\n            CollectionTools.updateSelectedInfo(selectedStatus);\r\n            wrapper.appendChild(autogenStatus);\r\n            wrapper.appendChild(selectedStatus);\r\n        }\r\n        static update(ifShown = false) {\r\n            const { state } = index_1.default;\r\n            const { data } = index_2.default;\r\n            const wrapper = index_1.default.DOMCache.collectionTools;\r\n            clearTimeout(CollectionTools.generateNextTimer);\r\n            if (!wrapper || !data)\r\n                return;\r\n            if (ifShown && wrapper.style.display !== \"flex\")\r\n                return;\r\n            if (!state.collectionToolsId) {\r\n                for (const colId in data.original) {\r\n                    state.collectionToolsId = colId;\r\n                    break;\r\n                }\r\n            }\r\n            if (!state.collectionToolsId)\r\n                return;\r\n            index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n            wrapper.innerHTML = \"\";\r\n            wrapper.style.display = \"flex\";\r\n            const footerBlock = (0, dom_1.makeDiv)({ className: \"PBE_rowBlock PBE_rowBlock_wide PBE_toolsFooter\" });\r\n            const closeButton = document.createElement(\"button\");\r\n            closeButton.innerText = \"Close\";\r\n            closeButton.className = \"PBE_button\";\r\n            closeButton.addEventListener(\"click\", event_1.default.onCloseWindow);\r\n            const headerBlock = (0, dom_1.makeDiv)({ className: \"PBE_collectionToolsHeader\" });\r\n            const contentBlock = (0, dom_1.makeDiv)({ className: \"PBE_dataBlock PBE_Scrollbar PBE_windowContent\" });\r\n            const statusBlock = (0, dom_1.makeDiv)({ className: \"PBE_collectionToolsStatus PBE_row\" });\r\n            const actionsBlock = (0, dom_1.makeDiv)({ className: \"PBE_collectionToolsActions PBE_row\" });\r\n            CollectionTools.showHeader(headerBlock);\r\n            CollectionTools.showPromptsDetailed(contentBlock);\r\n            footerBlock.appendChild(closeButton);\r\n            wrapper.appendChild(headerBlock);\r\n            wrapper.appendChild(contentBlock);\r\n            wrapper.appendChild(statusBlock);\r\n            wrapper.appendChild(actionsBlock);\r\n            wrapper.appendChild(footerBlock);\r\n            CollectionTools.showStatus(statusBlock);\r\n            CollectionTools.showActions(actionsBlock);\r\n        }\r\n    }\r\n    CollectionTools.autogen = {\r\n        collection: \"\",\r\n        style: \"\",\r\n    };\r\n    CollectionTools.autogenStyleSelector = undefined;\r\n    /**\r\n     * Auto generate previews timer.\r\n     */\r\n    CollectionTools.generateNextTimer = 0;\r\n    CollectionTools.generateQueue = [];\r\n    exports.default = CollectionTools;\r\n});\r\n","define([\"require\", \"exports\", \"client/index\", \"client/SetupWindow/index\", \"client/dom\"], function (require, exports, index_1, index_2, dom_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class ControlPanel {\r\n        static init(wrapper, containerId) {\r\n            const controlPanel = document.createElement(\"div\");\r\n            controlPanel.className = \"PBE_controlPanel\";\r\n            index_1.default.DOMCache.containers[containerId].controlPanel = controlPanel;\r\n            wrapper.prepend(controlPanel);\r\n        }\r\n        static onTogglePanel(e) {\r\n            const { state } = index_1.default;\r\n            state.showControlPanel = !state.showControlPanel;\r\n            ControlPanel.update();\r\n            localStorage.setItem(\"showControlPanel\", JSON.stringify(state.showControlPanel));\r\n        }\r\n        static onToggleVisibility(e) {\r\n            const target = e.currentTarget;\r\n            const { state } = index_1.default;\r\n            const id = target.dataset.id;\r\n            if (!id)\r\n                return;\r\n            let targetWrapper = undefined;\r\n            if (id === \"known\")\r\n                targetWrapper = index_1.default.DOMCache.containers[state.currentContainer].promptBrowser;\r\n            if (id === \"current\")\r\n                targetWrapper = index_1.default.DOMCache.containers[state.currentContainer].currentPrompts;\r\n            if (id === \"positive\")\r\n                targetWrapper = index_1.default.DOMCache.containers[state.currentContainer].positivePrompts;\r\n            if (id === \"negative\")\r\n                targetWrapper = index_1.default.DOMCache.containers[state.currentContainer].negativePrompts;\r\n            if (!targetWrapper)\r\n                return;\r\n            if (state.showViews.includes(id)) {\r\n                state.showViews = state.showViews.filter(item => item !== id);\r\n                target.classList.remove(\"PBE_activeControlIcon\");\r\n                targetWrapper.style.display = \"none\";\r\n            }\r\n            else {\r\n                state.showViews.push(id);\r\n                target.classList.add(\"PBE_activeControlIcon\");\r\n                targetWrapper.style.display = \"\";\r\n            }\r\n            localStorage.setItem(\"PBE_showViews\", JSON.stringify(state.showViews));\r\n        }\r\n        static update() {\r\n            const { state } = index_1.default;\r\n            const controlPanel = index_1.default.DOMCache.containers[state.currentContainer].controlPanel;\r\n            if (!controlPanel)\r\n                return;\r\n            controlPanel.innerHTML = \"\";\r\n            if (state.showControlPanel)\r\n                controlPanel.classList.remove(\"PBE_controlPanelHidden\");\r\n            else\r\n                controlPanel.classList.add(\"PBE_controlPanelHidden\");\r\n            const togglePanelButton = (0, dom_1.makeDiv)({ content: state.showControlPanel ? \"◀\" : \"▶\", className: \"PBE_toggleControlPanel\" });\r\n            togglePanelButton.addEventListener(\"click\", ControlPanel.onTogglePanel);\r\n            controlPanel.appendChild(togglePanelButton);\r\n            if (!state.showControlPanel)\r\n                return;\r\n            const iconKnownPrompts = (0, dom_1.makeDiv)({ content: \"K\", title: \"Known prompts\", className: \"PBE_controlIcon\" });\r\n            const iconCurrentPrompts = (0, dom_1.makeDiv)({ content: \"C\", title: \"Current prompts\", className: \"PBE_controlIcon\" });\r\n            const iconPositiveTextArea = (0, dom_1.makeDiv)({ content: \"P\", title: \"Positive prompts textarea\", className: \"PBE_controlIcon\" });\r\n            const iconNegativeTextArea = (0, dom_1.makeDiv)({ content: \"N\", title: \"Negative prompts textarea\", className: \"PBE_controlIcon\" });\r\n            if (state.showViews.includes(\"known\"))\r\n                iconKnownPrompts.classList.add(\"PBE_activeControlIcon\");\r\n            if (state.showViews.includes(\"current\"))\r\n                iconCurrentPrompts.classList.add(\"PBE_activeControlIcon\");\r\n            if (state.showViews.includes(\"positive\"))\r\n                iconPositiveTextArea.classList.add(\"PBE_activeControlIcon\");\r\n            if (state.showViews.includes(\"negative\"))\r\n                iconNegativeTextArea.classList.add(\"PBE_activeControlIcon\");\r\n            iconKnownPrompts.dataset.id = \"known\";\r\n            iconCurrentPrompts.dataset.id = \"current\";\r\n            iconPositiveTextArea.dataset.id = \"positive\";\r\n            iconNegativeTextArea.dataset.id = \"negative\";\r\n            iconKnownPrompts.addEventListener(\"click\", ControlPanel.onToggleVisibility);\r\n            iconCurrentPrompts.addEventListener(\"click\", ControlPanel.onToggleVisibility);\r\n            iconPositiveTextArea.addEventListener(\"click\", ControlPanel.onToggleVisibility);\r\n            iconNegativeTextArea.addEventListener(\"click\", ControlPanel.onToggleVisibility);\r\n            const setupButton = document.createElement(\"button\");\r\n            setupButton.className = \"PBE_button\";\r\n            setupButton.innerText = \"New Collection\";\r\n            setupButton.style.marginRight = \"10px\";\r\n            setupButton.addEventListener(\"click\", index_2.default.update);\r\n            controlPanel.appendChild(setupButton);\r\n            controlPanel.appendChild(iconKnownPrompts);\r\n            controlPanel.appendChild(iconCurrentPrompts);\r\n            controlPanel.appendChild(iconPositiveTextArea);\r\n            controlPanel.appendChild(iconNegativeTextArea);\r\n        }\r\n    }\r\n    exports.default = ControlPanel;\r\n});\r\n","define([\"require\", \"exports\", \"./index\", \"client/index\", \"client/ActivePrompts/index\", \"client/Database/index\", \"client/PreviewSave/index\", \"client/PromptEdit/index\", \"client/PromptScribe/index\", \"client/PromptTools/index\", \"client/synchroniseCurrentPrompts\"], function (require, exports, index_1, index_2, index_3, index_4, index_5, index_6, index_7, index_8, synchroniseCurrentPrompts_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class CurrentPromptsEvent {\r\n    }\r\n    CurrentPromptsEvent.onDragStart = (e) => {\r\n        const target = e.currentTarget;\r\n        const { state } = index_2.default;\r\n        let index = Number(target.dataset.index);\r\n        let group = Number(target.dataset.group);\r\n        if (Number.isNaN(index))\r\n            return;\r\n        if (Number.isNaN(group))\r\n            group = false;\r\n        state.dragInfo.index = index;\r\n        state.dragInfo.groupId = group;\r\n        e.dataTransfer.setData(\"text\", index + \"\");\r\n    };\r\n    CurrentPromptsEvent.onDragOver = (e) => {\r\n        e.preventDefault();\r\n    };\r\n    CurrentPromptsEvent.onDragLeave = (e) => {\r\n        const target = e.currentTarget;\r\n        target.classList.remove(\"PBE_swap\");\r\n    };\r\n    CurrentPromptsEvent.onDragEnter = (e) => {\r\n        const target = e.currentTarget;\r\n        const { state } = index_2.default;\r\n        e.preventDefault();\r\n        const dragIndex = Number(target.dataset.index);\r\n        let dragGroup = Number(target.dataset.group);\r\n        if (Number.isNaN(dragGroup))\r\n            dragGroup = false;\r\n        const dropIndex = state.dragInfo.index;\r\n        const dropGroup = state.dragInfo.groupId;\r\n        //invalid element\r\n        if (Number.isNaN(dragIndex) || dropIndex === undefined)\r\n            return;\r\n        //is the same element\r\n        if (dragIndex === dropIndex && dragGroup === dropGroup)\r\n            return;\r\n        target.classList.add(\"PBE_swap\");\r\n    };\r\n    CurrentPromptsEvent.onDrop = (e) => {\r\n        const target = e.currentTarget;\r\n        const { state } = index_2.default;\r\n        const dragIndex = Number(target.dataset.index);\r\n        let dragGroup = Number(target.dataset.group);\r\n        if (Number.isNaN(dragGroup))\r\n            dragGroup = false;\r\n        const dropIndex = state.dragInfo.index;\r\n        const dropGroup = state.dragInfo.groupId;\r\n        target.classList.remove(\"PBE_swap\");\r\n        state.dragInfo = {};\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        if (e.shiftKey) {\r\n            index_3.default.groupPrompts({\r\n                from: { index: dropIndex, groupId: dropGroup },\r\n                to: { index: dragIndex, groupId: dragGroup },\r\n            });\r\n        }\r\n        else {\r\n            index_3.default.movePrompt({\r\n                from: { index: dropIndex, groupId: dropGroup },\r\n                to: { index: dragIndex, groupId: dragGroup },\r\n            });\r\n        }\r\n        index_1.default.update();\r\n    };\r\n    CurrentPromptsEvent.onDblClick = (e) => {\r\n        const target = e.currentTarget;\r\n        const { state } = index_2.default;\r\n        let index = Number(target.dataset.index);\r\n        let group = Number(target.dataset.group);\r\n        if (Number.isNaN(index))\r\n            return;\r\n        if (Number.isNaN(group))\r\n            group = false;\r\n        if (!state.promptTools)\r\n            state.promptTools = {};\r\n        state.promptTools.index = index;\r\n        state.promptTools.groupId = group;\r\n        index_8.default.update();\r\n    };\r\n    CurrentPromptsEvent.onPromptSelected = (e) => {\r\n        const target = e.currentTarget;\r\n        const { readonly } = index_4.default.meta;\r\n        const { united } = index_4.default.data;\r\n        const { state } = index_2.default;\r\n        const currentId = target.dataset.prompt;\r\n        let index = Number(target.dataset.index);\r\n        let group = Number(target.dataset.group);\r\n        const isSyntax = target.dataset.issyntax ? true : false;\r\n        const wrapper = index_2.default.DOMCache.containers[state.currentContainer].currentPrompts;\r\n        if (!wrapper || !currentId)\r\n            return;\r\n        //on remove element\r\n        if (e.ctrlKey || e.metaKey) {\r\n            if (Number.isNaN(index))\r\n                return;\r\n            if (Number.isNaN(group))\r\n                group = false;\r\n            index_3.default.removePrompt(index, group);\r\n            index_1.default.update();\r\n            return;\r\n        }\r\n        if (isSyntax)\r\n            return;\r\n        const targetPrompt = united.find(item => item.id.toLowerCase() === currentId.toLowerCase());\r\n        if (targetPrompt && targetPrompt.collections && targetPrompt.collections[0]) {\r\n            if (!state.savePreviewCollection || !targetPrompt.collections.includes(state.savePreviewCollection)) {\r\n                state.savePreviewCollection = targetPrompt.collections[0];\r\n                index_5.default.update();\r\n            }\r\n        }\r\n        if (!readonly && e.shiftKey) {\r\n            if (targetPrompt) {\r\n                state.editingPrompt = currentId;\r\n                index_6.default.update();\r\n            }\r\n            else {\r\n                index_7.default.onOpenScriber();\r\n            }\r\n            return;\r\n        }\r\n        const selectedElements = wrapper.querySelectorAll(\".PBE_selectedCurrentElement\");\r\n        for (let i = 0; i < selectedElements.length; ++i) {\r\n            selectedElements[i].classList.remove(\"PBE_selectedCurrentElement\");\r\n        }\r\n        if (state.selectedPrompt !== currentId) {\r\n            target.classList.add(\"PBE_selectedCurrentElement\");\r\n            state.selectedPrompt = currentId;\r\n        }\r\n        else {\r\n            state.selectedPrompt = undefined;\r\n        }\r\n        index_5.default.update();\r\n    };\r\n    /**\r\n     * Handles the mouse wheel event and changes the weight of the prompt\r\n     */\r\n    CurrentPromptsEvent.scrollWeight = (e) => {\r\n        const target = e.currentTarget;\r\n        const { state } = index_2.default;\r\n        const { belowOneWeight = 0.05, aboveOneWeight = 0.01 } = state.config;\r\n        if (!e.shiftKey)\r\n            return;\r\n        const currentId = target.dataset.prompt;\r\n        let index = Number(target.dataset.index);\r\n        let group = Number(target.dataset.group);\r\n        if (Number.isNaN(index))\r\n            return;\r\n        if (Number.isNaN(group))\r\n            group = false;\r\n        if (!currentId)\r\n            return;\r\n        const targetItem = index_3.default.getPromptByIndex(index, group);\r\n        if (!targetItem)\r\n            return;\r\n        if (targetItem.isSyntax)\r\n            return;\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        if (!targetItem.weight)\r\n            targetItem.weight = 0;\r\n        if (e.deltaY < 0) { //rising weight\r\n            if (targetItem.weight < 1 && (targetItem.weight + belowOneWeight) > 1) {\r\n                targetItem.weight = 1;\r\n            }\r\n            else {\r\n                if (targetItem.weight >= 1)\r\n                    targetItem.weight += aboveOneWeight;\r\n                else\r\n                    targetItem.weight += belowOneWeight;\r\n            }\r\n        }\r\n        else { //lowering weight\r\n            if (targetItem.weight > 1 && (targetItem.weight - aboveOneWeight) < 1) {\r\n                targetItem.weight = 1;\r\n            }\r\n            else {\r\n                if (targetItem.weight <= 1)\r\n                    targetItem.weight -= belowOneWeight;\r\n                else\r\n                    targetItem.weight -= aboveOneWeight;\r\n            }\r\n        }\r\n        if (targetItem.weight < 0)\r\n            targetItem.weight = 0;\r\n        targetItem.weight = Number(targetItem.weight.toFixed(2));\r\n        index_1.default.update();\r\n    };\r\n    CurrentPromptsEvent.onNormalizePrompts = () => {\r\n        (0, synchroniseCurrentPrompts_1.default)(true, true);\r\n        index_1.default.update();\r\n    };\r\n    CurrentPromptsEvent.onGroupHeadClick = (e) => {\r\n        const target = e.currentTarget;\r\n        const groupId = Number(target.dataset.id);\r\n        if (Number.isNaN(groupId))\r\n            return;\r\n        if (e.ctrlKey || e.metaKey) {\r\n            index_3.default.unGroup(groupId);\r\n        }\r\n        else {\r\n            index_3.default.toggleGroupFold(groupId);\r\n        }\r\n        index_1.default.update();\r\n    };\r\n    //TODO: unite similar logic with scrollWeight method\r\n    CurrentPromptsEvent.onGroupHeadWheel = (e) => {\r\n        const target = e.currentTarget;\r\n        const { state } = index_2.default;\r\n        const { belowOneWeight = 0.05, aboveOneWeight = 0.01 } = state.config;\r\n        if (!e.shiftKey)\r\n            return;\r\n        const groupId = Number(target.dataset.id);\r\n        if (Number.isNaN(groupId))\r\n            return;\r\n        const targetGroup = index_3.default.getGroupById(groupId);\r\n        if (!targetGroup)\r\n            return;\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        if (!targetGroup.weight)\r\n            targetGroup.weight = 1;\r\n        if (e.deltaY < 0) { //rising weight\r\n            if (targetGroup.weight < 1 && (targetGroup.weight + belowOneWeight) > 1) {\r\n                targetGroup.weight = 1;\r\n            }\r\n            else {\r\n                if (targetGroup.weight >= 1)\r\n                    targetGroup.weight += aboveOneWeight;\r\n                else\r\n                    targetGroup.weight += belowOneWeight;\r\n            }\r\n        }\r\n        else { //lowering weight\r\n            if (targetGroup.weight > 1 && (targetGroup.weight - aboveOneWeight) < 1) {\r\n                targetGroup.weight = 1;\r\n            }\r\n            else {\r\n                if (targetGroup.weight <= 1)\r\n                    targetGroup.weight -= belowOneWeight;\r\n                else\r\n                    targetGroup.weight -= aboveOneWeight;\r\n            }\r\n        }\r\n        if (targetGroup.weight < 0)\r\n            targetGroup.weight = 0;\r\n        targetGroup.weight = Number(targetGroup.weight.toFixed(2));\r\n        if (targetGroup.weight === 1)\r\n            targetGroup.weight = undefined;\r\n        index_1.default.update();\r\n    };\r\n    exports.default = CurrentPromptsEvent;\r\n});\r\n","define([\"require\", \"exports\", \"client/index\", \"client/ActivePrompts/index\", \"client/Database/index\", \"./event\", \"client/synchroniseCurrentPrompts\", \"./showPrompts\"], function (require, exports, index_1, index_2, index_3, event_1, synchroniseCurrentPrompts_1, showPrompts_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class CurrentPrompts {\r\n    }\r\n    CurrentPrompts.init = (wrapper, containerId) => {\r\n        const currentPrompts = document.createElement(\"div\");\r\n        currentPrompts.className = \"PBE_currentPrompts\";\r\n        index_1.default.DOMCache.containers[containerId].currentPrompts = currentPrompts;\r\n        wrapper.appendChild(currentPrompts);\r\n    };\r\n    CurrentPrompts.initButton = (positiveWrapper) => {\r\n        const { readonly } = index_3.default.meta;\r\n        const normalizeButton = document.createElement(\"button\");\r\n        normalizeButton.className = \"PBE_actionButton PBE_normalizeButton\";\r\n        normalizeButton.innerText = \"Normalize\";\r\n        if (readonly)\r\n            normalizeButton.className = \"PBE_actionButton PBE_normalizeButton_readonly\";\r\n        normalizeButton.addEventListener(\"click\", event_1.default.onNormalizePrompts);\r\n        positiveWrapper.appendChild(normalizeButton);\r\n    };\r\n    CurrentPrompts.update = (noTextAreaUpdate = false) => {\r\n        const { state } = index_1.default;\r\n        const activePrompts = index_2.default.getCurrentPrompts();\r\n        const wrapper = index_1.default.DOMCache.containers[state.currentContainer].currentPrompts;\r\n        const textArea = index_1.default.DOMCache.containers[state.currentContainer].textArea;\r\n        if (!wrapper || !textArea)\r\n            return;\r\n        wrapper.innerHTML = \"\";\r\n        (0, showPrompts_1.default)({\r\n            prompts: activePrompts,\r\n            wrapper,\r\n            allowMove: true,\r\n            onClick: event_1.default.onPromptSelected,\r\n            onDblClick: event_1.default.onDblClick,\r\n            onWheel: event_1.default.scrollWeight,\r\n        });\r\n        if (noTextAreaUpdate)\r\n            return;\r\n        (0, synchroniseCurrentPrompts_1.synchroniseListToTextarea)(activePrompts);\r\n    };\r\n    exports.default = CurrentPrompts;\r\n});\r\n","define([\"require\", \"exports\", \"client/index\", \"client/showPromptItem\", \"./event\", \"client/PromptsFilter/simple\", \"client/dom\", \"client/const\", \"client/ActivePrompts/index\"], function (require, exports, index_1, showPromptItem_1, event_1, simple_1, dom_1, const_1, index_2) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function sortPrompts(prompts, sorting) {\r\n        //store original index\r\n        for (let index = 0; index < prompts.length; index++) {\r\n            const promptItem = prompts[index];\r\n            if (\"id\" in promptItem)\r\n                promptItem.index = index;\r\n        }\r\n        switch (sorting) {\r\n            case \"alph\":\r\n                //sorting prompts alphabetically\r\n                prompts.sort((A, B) => {\r\n                    if (\"groupId\" in A && \"groupId\" in B)\r\n                        return 0;\r\n                    if (\"id\" in A && \"groupId\" in B)\r\n                        return -1;\r\n                    if (\"id\" in B && \"groupId\" in A)\r\n                        return 1;\r\n                    if (\"id\" in A && \"id\" in B) {\r\n                        if (A.id.toLowerCase() < B.id.toLowerCase())\r\n                            return -1;\r\n                        if (A.id.toLowerCase() > B.id.toLowerCase())\r\n                            return 1;\r\n                    }\r\n                    return 0;\r\n                });\r\n                break;\r\n            case \"alphReversed\":\r\n                //sorting prompts alphabetically in reverse orderd\r\n                prompts.sort((A, B) => {\r\n                    if (\"groupId\" in A && \"groupId\" in B)\r\n                        return 0;\r\n                    if (\"id\" in A && \"groupId\" in B)\r\n                        return -1;\r\n                    if (\"id\" in B && \"groupId\" in A)\r\n                        return 1;\r\n                    if (\"id\" in A && \"id\" in B) {\r\n                        if (A.id.toLowerCase() < B.id.toLowerCase())\r\n                            return 1;\r\n                        if (A.id.toLowerCase() > B.id.toLowerCase())\r\n                            return -1;\r\n                    }\r\n                    return 0;\r\n                });\r\n                break;\r\n            case \"weight\":\r\n                //sorting prompts based on their weight\r\n                prompts.sort((A, B) => {\r\n                    if (\"id\" in A && \"groupId\" in B)\r\n                        return -1;\r\n                    if (\"id\" in B && \"groupId\" in A)\r\n                        return 1;\r\n                    if (A.weight < B.weight)\r\n                        return 1;\r\n                    if (A.weight > B.weight)\r\n                        return -1;\r\n                    return 0;\r\n                });\r\n        }\r\n    }\r\n    function showPrompts(props) {\r\n        const { prompts = [], focusOn, filterSimple, wrapper, allowMove = false, onClick, onDblClick, onWheel } = props;\r\n        const { state } = index_1.default;\r\n        const { checkFilter } = simple_1.default;\r\n        const { cardHeight = 100 } = state.config;\r\n        if (filterSimple === null || filterSimple === void 0 ? void 0 : filterSimple.sorting)\r\n            sortPrompts(prompts, filterSimple.sorting);\r\n        for (let index = 0; index < prompts.length; index++) {\r\n            const promptItem = prompts[index];\r\n            const useIndex = promptItem.index !== undefined ? promptItem.index : index;\r\n            if (\"groupId\" in promptItem) {\r\n                const groupContainer = (0, dom_1.makeDiv)({ className: promptItem.folded ? \"PBE_promptsGroup PBE_promptsGroupFolded\" : \"PBE_promptsGroup\" });\r\n                const groupHead = (0, dom_1.makeDiv)({ className: \"PBE_groupHead\" });\r\n                groupHead.style.height = cardHeight + \"px\";\r\n                groupHead.dataset.id = promptItem.groupId + \"\";\r\n                groupHead.dataset.index = useIndex + \"\";\r\n                groupHead.dataset.group = promptItem.parentGroup + \"\";\r\n                groupHead.dataset.isgroup = \"true\";\r\n                groupHead.addEventListener(\"click\", event_1.default.onGroupHeadClick);\r\n                groupHead.addEventListener(\"wheel\", event_1.default.onGroupHeadWheel);\r\n                if (promptItem.folded)\r\n                    groupHead.innerText += index_2.default.makeGroupKey(promptItem);\r\n                if (promptItem.weight && promptItem.weight !== const_1.DEFAULT_PROMPT_WEIGHT) {\r\n                    const groupWeight = (0, dom_1.makeDiv)({ className: \"PBE_groupHeadWeight\", content: promptItem.weight + \"\" });\r\n                    groupHead.appendChild(groupWeight);\r\n                }\r\n                if (allowMove) {\r\n                    groupHead.draggable = true;\r\n                    groupHead.addEventListener(\"dragstart\", event_1.default.onDragStart);\r\n                    groupHead.addEventListener(\"dragover\", event_1.default.onDragOver);\r\n                    groupHead.addEventListener(\"dragenter\", event_1.default.onDragEnter);\r\n                    groupHead.addEventListener(\"dragleave\", event_1.default.onDragLeave);\r\n                    groupHead.addEventListener(\"drop\", event_1.default.onDrop);\r\n                }\r\n                groupContainer.appendChild(groupHead);\r\n                wrapper.appendChild(groupContainer);\r\n                if (!promptItem.folded)\r\n                    showPrompts(Object.assign(Object.assign({}, props), { prompts: promptItem.prompts, wrapper: groupContainer }));\r\n                continue;\r\n            }\r\n            //check filters\r\n            if (filterSimple && !checkFilter(promptItem.id, filterSimple))\r\n                continue;\r\n            const { id, parentGroup = false } = promptItem;\r\n            let isShadowed = false;\r\n            if (focusOn) {\r\n                isShadowed = true;\r\n                if (useIndex === focusOn.index && parentGroup === focusOn.groupId)\r\n                    isShadowed = false;\r\n            }\r\n            const promptElement = (0, showPromptItem_1.default)({ prompt: promptItem, options: { index: useIndex, parentGroup, isShadowed } });\r\n            if (promptItem.isSyntax)\r\n                promptElement.dataset.issyntax = \"true\";\r\n            else if (state.selectedPrompt === id)\r\n                promptElement.classList.add(\"PBE_selectedCurrentElement\");\r\n            if (allowMove) {\r\n                promptElement.addEventListener(\"dragstart\", event_1.default.onDragStart);\r\n                promptElement.addEventListener(\"dragover\", event_1.default.onDragOver);\r\n                promptElement.addEventListener(\"dragenter\", event_1.default.onDragEnter);\r\n                promptElement.addEventListener(\"dragleave\", event_1.default.onDragLeave);\r\n                promptElement.addEventListener(\"drop\", event_1.default.onDrop);\r\n            }\r\n            if (onClick)\r\n                promptElement.addEventListener(\"click\", onClick);\r\n            if (!promptItem.isSyntax) {\r\n                if (onDblClick)\r\n                    promptElement.addEventListener(\"dblclick\", onDblClick);\r\n                if (onWheel)\r\n                    promptElement.addEventListener(\"wheel\", onWheel);\r\n            }\r\n            wrapper.appendChild(promptElement);\r\n        }\r\n    }\r\n    exports.default = showPrompts;\r\n});\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\ndefine([\"require\", \"exports\", \"client/index\", \"client/ActivePrompts/index\", \"client/CurrentPrompts/index\", \"client/PreviewSave/index\", \"client/LoadStyle/index\", \"client/categories\", \"client/utils/index\", \"client/const\", \"client/KnownPrompts/index\"], function (require, exports, index_1, index_2, index_3, index_4, index_5, categories_1, index_6, const_1, index_7) {\r\n    \"use strict\";\r\n    var _a;\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class Database {\r\n        static load() {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                const { state } = index_1.default;\r\n                const url = Database.getAPIurl(\"getPrompts\");\r\n                yield fetch(url, {\r\n                    method: 'GET',\r\n                }).then(data => data.json()).then(res => {\r\n                    if (!res || !res.prompts)\r\n                        return; //TODO: process server error here\r\n                    const { readonly = false } = res;\r\n                    const prompts = res.prompts;\r\n                    const styles = res.styles;\r\n                    if (res.config) {\r\n                        for (const i in res.config) {\r\n                            state.config[i] = res.config[i];\r\n                        }\r\n                    }\r\n                    Database.data.styles = styles;\r\n                    Database.data.original = prompts;\r\n                    Database.updateMixedList();\r\n                    Database.meta.readonly = readonly;\r\n                });\r\n            });\r\n        }\r\n        static updateMixedList() {\r\n            const unitedArray = [];\r\n            const unitedList = {};\r\n            const res = Database.data.original;\r\n            const addedIds = {};\r\n            for (const collectionId in res) {\r\n                const collection = res[collectionId];\r\n                if (!Array.isArray(collection))\r\n                    continue;\r\n                for (const collectionPrompt of collection) {\r\n                    const { id, isExternalNetwork, previewImage, addAtStart, addAfter, addStart, addEnd } = collectionPrompt;\r\n                    let newItem = { id, tags: [], category: [], collections: [], knownPreviews: {} };\r\n                    if (addedIds[id])\r\n                        newItem = unitedArray.find(item => item.id === id);\r\n                    if (addAtStart)\r\n                        newItem.addAtStart = addAtStart;\r\n                    if (addAfter)\r\n                        newItem.addAfter = addAfter;\r\n                    if (addStart)\r\n                        newItem.addStart = addStart;\r\n                    if (addEnd)\r\n                        newItem.addEnd = addEnd;\r\n                    if (isExternalNetwork)\r\n                        newItem.isExternalNetwork = true;\r\n                    if (previewImage) {\r\n                        newItem.knownPreviews[collectionId] = previewImage;\r\n                    }\r\n                    if (!newItem.collections.includes(collectionId)) {\r\n                        newItem.collections.push(collectionId);\r\n                    }\r\n                    if (collectionPrompt.tags) {\r\n                        collectionPrompt.tags.forEach(item => {\r\n                            if (!newItem.tags.includes(item))\r\n                                newItem.tags.push(item);\r\n                        });\r\n                    }\r\n                    if (collectionPrompt.category) {\r\n                        collectionPrompt.category.forEach(item => {\r\n                            if (!newItem.category.includes(item))\r\n                                newItem.category.push(item);\r\n                        });\r\n                    }\r\n                    if (!addedIds[id]) {\r\n                        unitedArray.push(newItem);\r\n                        unitedList[id] = newItem;\r\n                    }\r\n                    addedIds[id] = true;\r\n                }\r\n            }\r\n            Database.data.united = unitedArray;\r\n            Database.data.unitedList = unitedList;\r\n        }\r\n        static getStylePreviewURL(style) {\r\n            const { state } = index_1.default;\r\n            if (!style)\r\n                return const_1.NEW_CARD_GRADIENT;\r\n            const { name, id, previewImage } = style;\r\n            if (!name || !id || !previewImage)\r\n                return const_1.NEW_CARD_GRADIENT;\r\n            const apiUrl = Database.getAPIurl(\"styleImage\");\r\n            const safeFileName = (0, index_6.makeFileNameSafe)(name);\r\n            const url = `url(\"${apiUrl}/${id}/${safeFileName}.${previewImage}?${state.filesIteration}\"), ${const_1.EMPTY_CARD_GRADIENT}`;\r\n            return url;\r\n        }\r\n        static createNewCollection(id, mode = \"short\") {\r\n            if (!id)\r\n                return;\r\n            const url = Database.getAPIurl(\"newCollection\");\r\n            (() => __awaiter(this, void 0, void 0, function* () {\r\n                const rawResponse = yield fetch(url, {\r\n                    method: 'POST',\r\n                    headers: {\r\n                        'Accept': 'application/json',\r\n                        'Content-Type': 'application/json'\r\n                    },\r\n                    body: JSON.stringify({ id, mode })\r\n                });\r\n                //const answer = await rawResponse.json();\r\n                Database.load();\r\n                index_7.default.update();\r\n                index_3.default.update();\r\n            }))();\r\n        }\r\n        static createNewStylesCollection(id, mode = \"short\") {\r\n            if (!id)\r\n                return;\r\n            const url = Database.getAPIurl(\"newStylesCollection\");\r\n            (() => __awaiter(this, void 0, void 0, function* () {\r\n                const rawResponse = yield fetch(url, {\r\n                    method: 'POST',\r\n                    headers: {\r\n                        'Accept': 'application/json',\r\n                        'Content-Type': 'application/json'\r\n                    },\r\n                    body: JSON.stringify({ id, mode })\r\n                });\r\n                //const answer = await rawResponse.json();\r\n                Database.load();\r\n                index_7.default.update();\r\n                index_3.default.update();\r\n            }))();\r\n        }\r\n    }\r\n    _a = Database;\r\n    Database.data = {\r\n        categories: categories_1.default,\r\n    };\r\n    Database.meta = {\r\n        version: \"1.3.0\",\r\n        readonly: false,\r\n    };\r\n    Database.getAPIurl = (endpoint, root = false) => {\r\n        const server = root ? window.location.origin + \"/\" : window.location.origin + \"/promptBrowser/\";\r\n        return server + endpoint;\r\n    };\r\n    Database.saveJSONData = (collectionId, noClear = false, noUpdate = false) => {\r\n        if (!collectionId)\r\n            return;\r\n        const targetData = Database.data.original[collectionId];\r\n        if (!targetData)\r\n            return;\r\n        const url = Database.getAPIurl(\"savePrompts\");\r\n        (() => __awaiter(void 0, void 0, void 0, function* () {\r\n            const rawResponse = yield fetch(url, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Accept': 'application/json',\r\n                    'Content-Type': 'application/json'\r\n                },\r\n                body: JSON.stringify({ collection: collectionId, data: JSON.stringify(targetData), noClear })\r\n            });\r\n            if (!noUpdate) {\r\n                index_7.default.update();\r\n                index_3.default.update(true);\r\n            }\r\n        }))();\r\n    };\r\n    Database.movePrompt = (promptA, promptB, collectionId) => {\r\n        const { united } = Database.data;\r\n        const { state } = index_1.default;\r\n        if (!promptA || !promptB || promptA === promptB)\r\n            return;\r\n        if (!collectionId)\r\n            collectionId = state.filterCollection;\r\n        if (!collectionId) {\r\n            const itemA = united.find(item => item.id === promptA);\r\n            const itemB = united.find(item => item.id === promptB);\r\n            if (!itemA.collections || !itemA.collections.length)\r\n                return;\r\n            if (!itemB.collections || !itemB.collections.length)\r\n                return;\r\n            for (const collectionItem of itemA.collections) {\r\n                if (itemB.collections.includes(collectionItem)) {\r\n                    collectionId = collectionItem;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (!collectionId)\r\n            return;\r\n        const targetCollection = Database.data.original[collectionId];\r\n        if (!targetCollection)\r\n            return;\r\n        const indexInOriginB = targetCollection.findIndex(item => item.id === promptB);\r\n        const indexInOriginA = targetCollection.findIndex(item => item.id === promptA);\r\n        const element = targetCollection.splice(indexInOriginB, 1)[0];\r\n        targetCollection.splice(indexInOriginA, 0, element);\r\n        Database.saveJSONData(collectionId, false, true);\r\n        Database.updateMixedList();\r\n        index_7.default.update();\r\n    };\r\n    Database.movePreviewImage = (item, movefrom, to, type) => {\r\n        const { state } = index_1.default;\r\n        const url = Database.getAPIurl(\"movePreview\");\r\n        (() => __awaiter(void 0, void 0, void 0, function* () {\r\n            const rawResponse = yield fetch(url, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Accept': 'application/json',\r\n                    'Content-Type': 'application/json'\r\n                },\r\n                body: JSON.stringify({ item, movefrom, to, type })\r\n            });\r\n            state.filesIteration++;\r\n            index_7.default.update();\r\n            index_3.default.update(true);\r\n        }))();\r\n    };\r\n    Database.getPromptPreviewURL = (prompt, collectionId) => {\r\n        if (!prompt)\r\n            return const_1.NEW_CARD_GRADIENT;\r\n        const apiUrl = Database.getAPIurl(\"promptImage\");\r\n        const { data } = Database;\r\n        const { united } = data;\r\n        const { state } = index_1.default;\r\n        let fileExtension = \"\";\r\n        let targetPrompt = united.find(item => item.id.toLowerCase() === prompt.toLowerCase());\r\n        //if no target prompt found - searching for the normalized version of the target prompt\r\n        if (!targetPrompt) {\r\n            const normalizedPrompt = (0, index_6.normalizePrompt)({ prompt, state, data });\r\n            targetPrompt = united.find(item => item.id.toLowerCase() === normalizedPrompt.toLowerCase());\r\n        }\r\n        //if no prompt found - returning New Card image.\r\n        if (!targetPrompt || !targetPrompt.knownPreviews)\r\n            return const_1.NEW_CARD_GRADIENT;\r\n        if (!collectionId && state.filterCollection)\r\n            collectionId = state.filterCollection;\r\n        if (collectionId && targetPrompt.knownPreviews[collectionId])\r\n            fileExtension = targetPrompt.knownPreviews[collectionId];\r\n        if (!fileExtension) {\r\n            for (let colId in targetPrompt.knownPreviews) {\r\n                fileExtension = targetPrompt.knownPreviews[colId];\r\n                collectionId = colId;\r\n                break;\r\n            }\r\n        }\r\n        if (!collectionId)\r\n            return const_1.EMPTY_CARD_GRADIENT;\r\n        if (!fileExtension)\r\n            return const_1.EMPTY_CARD_GRADIENT;\r\n        const safeFileName = (0, index_6.makeFileNameSafe)(prompt);\r\n        const url = `url(\"${apiUrl}/${collectionId}/${safeFileName}.${fileExtension}?${state.filesIteration}\"), ${const_1.EMPTY_CARD_GRADIENT}`;\r\n        return url;\r\n    };\r\n    Database.savePromptPreview = (callUpdate = true) => {\r\n        const { state } = index_1.default;\r\n        const { data } = Database;\r\n        const { united } = data;\r\n        const { selectedPrompt, savePreviewCollection, currentContainer } = state;\r\n        const url = Database.getAPIurl(\"savePreview\");\r\n        const imageArea = index_1.default.DOMCache.containers[currentContainer].imageArea;\r\n        if (!imageArea)\r\n            return;\r\n        if (!selectedPrompt)\r\n            return;\r\n        if (!savePreviewCollection)\r\n            return;\r\n        const imageContainer = imageArea.querySelector(\"img\");\r\n        if (!imageContainer)\r\n            return;\r\n        let isExternalNetwork = false;\r\n        let src = imageContainer.src;\r\n        const fileMarkIndex = src.indexOf(\"file=\");\r\n        if (fileMarkIndex === -1)\r\n            return;\r\n        src = src.slice(fileMarkIndex + 5);\r\n        const cacheMarkIndex = src.indexOf(\"?\");\r\n        if (cacheMarkIndex && cacheMarkIndex !== -1)\r\n            src = src.substring(0, cacheMarkIndex);\r\n        const imageExtension = src.split('.').pop();\r\n        if (!data.original[savePreviewCollection])\r\n            return;\r\n        //checking if prompt have an external network syntax.\r\n        const targetCurrentPrompt = index_2.default.getPromptById({ id: state.selectedPrompt });\r\n        if (targetCurrentPrompt && targetCurrentPrompt.isExternalNetwork)\r\n            isExternalNetwork = true;\r\n        const saveData = { src, prompt: selectedPrompt, collection: savePreviewCollection };\r\n        if (isExternalNetwork)\r\n            saveData.isExternalNetwork = true;\r\n        let targetItem = united.find(item => item.id === selectedPrompt);\r\n        if (!targetItem) {\r\n            targetItem = { id: selectedPrompt, tags: [], category: [], collections: [] };\r\n            if (isExternalNetwork)\r\n                targetItem.isExternalNetwork = true;\r\n            united.push(targetItem);\r\n        }\r\n        if (!targetItem.collections)\r\n            targetItem.collections = [];\r\n        if (!targetItem.collections.includes(savePreviewCollection)) {\r\n            targetItem.collections.push(savePreviewCollection);\r\n        }\r\n        let originalItem = data.original[savePreviewCollection].find(item => item.id === selectedPrompt);\r\n        if (!originalItem) {\r\n            originalItem = { id: selectedPrompt, tags: [], category: [] };\r\n            if (isExternalNetwork)\r\n                originalItem.isExternalNetwork = true;\r\n            data.original[savePreviewCollection].push(originalItem);\r\n        }\r\n        if (state.config.resizeThumbnails && state.config.resizeThumbnailsFormat) {\r\n            originalItem.previewImage = state.config.resizeThumbnailsFormat.toLowerCase();\r\n        }\r\n        else\r\n            originalItem.previewImage = imageExtension;\r\n        (() => __awaiter(void 0, void 0, void 0, function* () {\r\n            const rawResponse = yield fetch(url, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Accept': 'application/json',\r\n                    'Content-Type': 'application/json'\r\n                },\r\n                body: JSON.stringify(saveData)\r\n            });\r\n            const answer = yield rawResponse.json();\r\n            if (answer === \"ok\" && callUpdate) {\r\n                state.selectedPrompt = undefined;\r\n                state.filesIteration++;\r\n                Database.updateMixedList();\r\n                index_4.default.update();\r\n                index_7.default.update();\r\n                index_3.default.update(true);\r\n            }\r\n        }))();\r\n    };\r\n    Database.updateStyles = (collectionId) => {\r\n        if (!collectionId)\r\n            return;\r\n        const { data } = Database;\r\n        const targetData = data.styles[collectionId];\r\n        if (!targetData)\r\n            return;\r\n        const url = Database.getAPIurl(\"saveStyles\");\r\n        (() => __awaiter(void 0, void 0, void 0, function* () {\r\n            const rawResponse = yield fetch(url, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Accept': 'application/json',\r\n                    'Content-Type': 'application/json'\r\n                },\r\n                body: JSON.stringify({ collection: collectionId, data: JSON.stringify(targetData) })\r\n            });\r\n            //const content = await rawResponse.json();\r\n        }))();\r\n    };\r\n    Database.onRenameStyle = (collection, oldName, newName) => {\r\n        const { data } = Database;\r\n        if (!collection || !oldName || !newName)\r\n            return;\r\n        const url = Database.getAPIurl(\"renameStyle\");\r\n        (() => __awaiter(void 0, void 0, void 0, function* () {\r\n            const saveData = { oldName, newName, collection };\r\n            const rawResponse = yield fetch(url, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Accept': 'application/json',\r\n                    'Content-Type': 'application/json'\r\n                },\r\n                body: JSON.stringify(saveData)\r\n            });\r\n            const targetStylesCollection = data.styles[collection];\r\n            if (targetStylesCollection) {\r\n                targetStylesCollection.some(item => {\r\n                    if (item.name === oldName) {\r\n                        item.name = newName;\r\n                        return true;\r\n                    }\r\n                });\r\n            }\r\n            index_5.default.update();\r\n        }))();\r\n    };\r\n    Database.onUpdateStylePreview = (e) => {\r\n        const target = e.currentTarget;\r\n        const { data } = Database;\r\n        const { state } = index_1.default;\r\n        let collectionId = undefined;\r\n        let styleId = undefined;\r\n        if (target.dataset.action) {\r\n            const { selectedItem } = index_5.default;\r\n            collectionId = selectedItem.collection;\r\n            styleId = selectedItem.styleId;\r\n        }\r\n        else {\r\n            collectionId = target.dataset.id;\r\n            styleId = target.dataset.id;\r\n        }\r\n        if (!collectionId || !styleId)\r\n            return;\r\n        const imageArea = index_1.default.DOMCache.containers[state.currentContainer].imageArea;\r\n        if (!imageArea)\r\n            return;\r\n        const imageContainer = imageArea.querySelector(\"img\");\r\n        if (!imageContainer)\r\n            return;\r\n        let src = imageContainer.src;\r\n        const fileMarkIndex = src.indexOf(\"file=\");\r\n        if (fileMarkIndex === -1)\r\n            return;\r\n        src = src.slice(fileMarkIndex + 5);\r\n        const cacheMarkIndex = src.indexOf(\"?\");\r\n        if (cacheMarkIndex && cacheMarkIndex !== -1)\r\n            src = src.substring(0, cacheMarkIndex);\r\n        const imageExtension = src.split('.').pop();\r\n        const url = Database.getAPIurl(\"saveStylePreview\");\r\n        (() => __awaiter(void 0, void 0, void 0, function* () {\r\n            const saveData = { src, style: styleId, collection: collectionId };\r\n            const rawResponse = yield fetch(url, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Accept': 'application/json',\r\n                    'Content-Type': 'application/json'\r\n                },\r\n                body: JSON.stringify(saveData)\r\n            });\r\n            //const content = await rawResponse.json();\r\n            const targetStylesCollection = data.styles[collectionId];\r\n            if (targetStylesCollection) {\r\n                targetStylesCollection.some(item => {\r\n                    if (item.name === styleId) {\r\n                        if (state.config.resizeThumbnails && state.config.resizeThumbnailsFormat) {\r\n                            item.previewImage = state.config.resizeThumbnailsFormat.toLowerCase();\r\n                        }\r\n                        else\r\n                            item.previewImage = imageExtension;\r\n                        return true;\r\n                    }\r\n                });\r\n            }\r\n            index_5.default.update();\r\n        }))();\r\n    };\r\n    exports.default = Database;\r\n});\r\n","define([\"require\", \"exports\", \"./index\", \"client/index\", \"client/ActivePrompts/index\", \"client/Database/index\", \"client/CurrentPrompts/index\", \"client/PromptEdit/index\", \"client/utils/index\", \"client/const\", \"client/synchroniseCurrentPrompts\"], function (require, exports, index_1, index_2, index_3, index_4, index_5, index_6, index_7, const_1, synchroniseCurrentPrompts_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class KnownPromptsEvent {\r\n        static addPromptItem(targetItem) {\r\n            if (!targetItem)\r\n                return;\r\n            const activePrompts = index_3.default.getCurrentPrompts();\r\n            const { id, addAtStart, addAfter, addStart, addEnd } = targetItem;\r\n            //if(activePrompts.some(item => item.id === id)) return;\r\n            const newPrompt = { id, weight: const_1.DEFAULT_PROMPT_WEIGHT, isExternalNetwork: targetItem.isExternalNetwork };\r\n            if (addStart)\r\n                (0, index_7.addStrToActive)(addStart, true);\r\n            if (addAfter) {\r\n                if (addAtStart) {\r\n                    (0, index_7.addStrToActive)(addAfter, true);\r\n                    activePrompts.unshift(newPrompt);\r\n                }\r\n                else {\r\n                    activePrompts.push(newPrompt);\r\n                    (0, index_7.addStrToActive)(addAfter, false);\r\n                }\r\n            }\r\n            else {\r\n                if (addAtStart)\r\n                    activePrompts.unshift(newPrompt);\r\n                else\r\n                    activePrompts.push(newPrompt);\r\n            }\r\n            if (addEnd)\r\n                (0, index_7.addStrToActive)(addEnd, false);\r\n        }\r\n        /**\r\n         * Adds a random prompt from the prompts corresponding to the current filter settings.\r\n         */\r\n        static onAddRandom() {\r\n            const { data } = index_4.default;\r\n            const { state } = index_2.default;\r\n            const { united } = data;\r\n            const usedPrompts = index_3.default.getUniqueIds();\r\n            let dataArr = [];\r\n            if (state.filterCollection) {\r\n                const targetCategory = data.original[state.filterCollection];\r\n                if (targetCategory) {\r\n                    for (const id in targetCategory) {\r\n                        const targetOriginalItem = targetCategory[id];\r\n                        const targetMixedItem = united.find(item => item.id === targetOriginalItem.id);\r\n                        if (targetMixedItem && index_1.default.checkFilter(targetMixedItem))\r\n                            dataArr.push(Object.assign({}, targetMixedItem));\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                for (const id in united) {\r\n                    if (index_1.default.checkFilter(united[id]))\r\n                        dataArr.push(Object.assign({}, united[id]));\r\n                }\r\n            }\r\n            dataArr = dataArr.filter(dataItem => !usedPrompts.includes(dataItem.id));\r\n            const randomPrompt = dataArr[Math.floor(Math.random() * dataArr.length)];\r\n            KnownPromptsEvent.addPromptItem(randomPrompt);\r\n            index_5.default.update();\r\n        }\r\n        static onDragStart(e) {\r\n            const target = e.currentTarget;\r\n            const { state } = index_2.default;\r\n            const splash = target.querySelector(\".PBE_promptElementSplash\");\r\n            splash.style.display = \"none\";\r\n            const promptItem = target.dataset.prompt;\r\n            state.dragInfo.id = promptItem;\r\n            e.dataTransfer.setData(\"text\", promptItem);\r\n        }\r\n        static onDragOver(e) {\r\n            e.preventDefault();\r\n        }\r\n        static onDragEnter(e) {\r\n            const target = e.currentTarget;\r\n            const { state } = index_2.default;\r\n            e.preventDefault();\r\n            const dragItem = target.dataset.prompt;\r\n            const dropItem = state.dragInfo.id;\r\n            if (!dragItem || !dropItem)\r\n                return;\r\n            if (dragItem === dropItem)\r\n                return;\r\n            if ((0, index_7.isInSameCollection)(dragItem, dropItem))\r\n                target.classList.add(\"PBE_swap\");\r\n        }\r\n        static onDragLeave(e) {\r\n            const target = e.currentTarget;\r\n            target.classList.remove(\"PBE_swap\");\r\n        }\r\n        static onDrop(e) {\r\n            const target = e.currentTarget;\r\n            const { state } = index_2.default;\r\n            const dragItem = target.dataset.prompt;\r\n            const dropItem = e.dataTransfer.getData(\"text\");\r\n            target.classList.remove(\"PBE_swap\");\r\n            //state.dragItemId = undefined;\r\n            state.dragInfo.id = undefined;\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n            if ((0, index_7.isInSameCollection)(dragItem, dropItem)) {\r\n                index_4.default.movePrompt(dragItem, dropItem);\r\n            }\r\n        }\r\n    }\r\n    KnownPromptsEvent.onPromptClick = (e) => {\r\n        const target = e.currentTarget;\r\n        const { readonly } = index_4.default.meta;\r\n        const { united } = index_4.default.data;\r\n        const { state } = index_2.default;\r\n        (0, synchroniseCurrentPrompts_1.default)();\r\n        const promptItem = target.dataset.prompt;\r\n        const targetItem = united.find(item => item.id === promptItem);\r\n        if (!targetItem)\r\n            return;\r\n        if (!readonly && e.shiftKey) {\r\n            state.editingPrompt = promptItem;\r\n            index_6.default.update();\r\n            return;\r\n        }\r\n        if (!readonly && (e.metaKey || e.ctrlKey)) {\r\n            let targetCollection = state.filterCollection;\r\n            if (!targetCollection) {\r\n                if (!targetItem.collections)\r\n                    return;\r\n                const firstCollection = targetItem.collections[0];\r\n                if (!firstCollection)\r\n                    return;\r\n                targetCollection = targetItem.collections[0];\r\n            }\r\n            if (confirm(`Remove prompt \"${promptItem}\" from catalogue \"${targetCollection}\"?`)) {\r\n                if (!index_4.default.data.original[targetCollection])\r\n                    return;\r\n                index_4.default.data.original[targetCollection] = index_4.default.data.original[targetCollection].filter(item => item.id !== promptItem);\r\n                index_4.default.movePreviewImage(promptItem, targetCollection, targetCollection, \"delete\");\r\n                index_4.default.saveJSONData(targetCollection);\r\n                index_4.default.updateMixedList();\r\n                index_6.default.update();\r\n                index_5.default.update();\r\n            }\r\n            return;\r\n        }\r\n        KnownPromptsEvent.addPromptItem(targetItem);\r\n        index_5.default.update();\r\n    };\r\n    exports.default = KnownPromptsEvent;\r\n});\r\n","define([\"require\", \"exports\", \"client/index\", \"client/Database/index\", \"client/CurrentPrompts/index\", \"client/CollectionTools/index\", \"client/dom\", \"client/showPromptItem\", \"client/TagTooltip/index\", \"client/utils/index\", \"./event\", \"client/ActivePrompts/index\"], function (require, exports, index_1, index_2, index_3, index_4, dom_1, showPromptItem_1, index_5, index_6, event_1, index_7) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class KnownPrompts {\r\n        static init(promptContainer, positivePrompts, containerId) {\r\n            const promptBrowser = document.createElement(\"div\");\r\n            promptBrowser.className = \"PBE_promptsWrapper\";\r\n            const promptsCatalogue = document.createElement(\"div\");\r\n            promptsCatalogue.className = \"PBE_promptsCatalogue\";\r\n            promptBrowser.appendChild(promptsCatalogue);\r\n            index_1.default.DOMCache.containers[containerId].promptBrowser = promptBrowser;\r\n            index_1.default.DOMCache.containers[containerId].promptsCatalogue = promptsCatalogue;\r\n            promptContainer.insertBefore(promptBrowser, positivePrompts);\r\n        }\r\n        static checkFilter(prompt) {\r\n            const { state } = index_1.default;\r\n            if (state.filterCategory) {\r\n                if (state.filterCategory === \"__none\") {\r\n                    if (prompt.category !== undefined && prompt.category.length)\r\n                        return false;\r\n                }\r\n                else {\r\n                    if (!prompt.category)\r\n                        return false;\r\n                    if (!prompt.category.includes(state.filterCategory))\r\n                        return false;\r\n                }\r\n            }\r\n            if (state.filterCollection) {\r\n                if (!prompt.collections)\r\n                    return false;\r\n                if (!prompt.collections.includes(state.filterCollection))\r\n                    return false;\r\n            }\r\n            if (state.filterName) {\r\n                if (!prompt.id.toLowerCase().includes(state.filterName))\r\n                    return false;\r\n            }\r\n            if (state.filterTags && Array.isArray(state.filterTags)) {\r\n                if (!prompt.tags)\r\n                    return false;\r\n                let out = true;\r\n                const TAG_MODE = \"includeAll\";\r\n                if (TAG_MODE === \"includeAll\") {\r\n                    out = false;\r\n                    for (const filterTag of state.filterTags) {\r\n                        let fulfil = false;\r\n                        for (const promptTag of prompt.tags) {\r\n                            if (promptTag === filterTag) {\r\n                                fulfil = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!fulfil) {\r\n                            out = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    for (const filterTag of state.filterTags) {\r\n                        for (const promptTag of prompt.tags) {\r\n                            if (promptTag.includes(filterTag)) {\r\n                                out = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (out)\r\n                    return false;\r\n            }\r\n            return true;\r\n        }\r\n        static update(params) {\r\n            const { data } = index_2.default;\r\n            const { readonly } = index_2.default.meta;\r\n            const { united } = data;\r\n            const { state } = index_1.default;\r\n            const { cardWidth = 50, cardHeight = 100, showPromptIndex = false, rowsInKnownCards = 3, maxCardsShown = 1000 } = state.config;\r\n            const wrapper = index_1.default.DOMCache.containers[state.currentContainer].promptsCatalogue;\r\n            const usedPrompts = index_7.default.getUniqueIds();\r\n            let scrollState = 0;\r\n            let shownItems = 0;\r\n            if (wrapper) {\r\n                let prevPromptContainer = wrapper.querySelector(\".PBE_promptsCatalogueContent\");\r\n                if (prevPromptContainer) {\r\n                    scrollState = prevPromptContainer.scrollTop;\r\n                    prevPromptContainer = undefined;\r\n                }\r\n            }\r\n            wrapper.innerHTML = \"\";\r\n            if (!united) {\r\n                (0, index_6.log)(\"No prompt data to show\");\r\n                return;\r\n            }\r\n            KnownPrompts.showHeader(wrapper, params);\r\n            const proptsContainer = document.createElement(\"div\");\r\n            proptsContainer.className = \"PBE_promptsCatalogueContent PBE_Scrollbar\";\r\n            proptsContainer.style.maxHeight = `${cardHeight * rowsInKnownCards}px`;\r\n            let dataArr = [];\r\n            if (state.filterCollection) {\r\n                const targetCategory = data.original[state.filterCollection];\r\n                if (targetCategory) {\r\n                    for (const id in targetCategory) {\r\n                        const targetOriginalItem = targetCategory[id];\r\n                        const targetMixedItem = united.find(item => item.id === targetOriginalItem.id);\r\n                        if (targetMixedItem)\r\n                            dataArr.push(Object.assign({}, targetMixedItem));\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                for (const id in united)\r\n                    dataArr.push(Object.assign({}, united[id]));\r\n            }\r\n            if (state.sortKnownPrompts === \"alph\" || state.sortKnownPrompts === \"alphReversed\") {\r\n                dataArr.sort((A, B) => {\r\n                    if (state.sortKnownPrompts === \"alph\") {\r\n                        if (A.id > B.id)\r\n                            return 1;\r\n                        if (A.id < B.id)\r\n                            return -1;\r\n                    }\r\n                    else {\r\n                        if (A.id > B.id)\r\n                            return -1;\r\n                        if (A.id < B.id)\r\n                            return 1;\r\n                    }\r\n                    return 0;\r\n                });\r\n            }\r\n            else if (state.sortKnownPrompts === \"reversed\") {\r\n                dataArr.reverse();\r\n            }\r\n            //show Add Random card\r\n            if (dataArr.length) {\r\n                const addRandom = (0, dom_1.makeDiv)({\r\n                    className: \"PBE_promptElement PBE_promptElement_random\",\r\n                    content: \"Add random\"\r\n                });\r\n                addRandom.addEventListener(\"click\", event_1.default.onAddRandom);\r\n                addRandom.style.width = `${cardWidth}px`;\r\n                addRandom.style.height = `${cardHeight}px`;\r\n                proptsContainer.appendChild(addRandom);\r\n            }\r\n            for (const index in dataArr) {\r\n                const prompt = dataArr[index];\r\n                if (shownItems > maxCardsShown)\r\n                    break;\r\n                if (!KnownPrompts.checkFilter(prompt))\r\n                    continue;\r\n                //const isShadowed = usedPrompts.includes(prompt.id);\r\n                const promptElement = (0, showPromptItem_1.default)({ prompt, options: { isShadowed: false } });\r\n                if (showPromptIndex && state.filterCollection) {\r\n                    promptElement.appendChild((0, dom_1.makeDiv)({\r\n                        className: \"PBE_promptElementIndex\",\r\n                        content: index,\r\n                    }));\r\n                    /* splashElement.appendChild(makeElement({\r\n                        element: \"div\",\r\n                        className: \"PBE_promptElementIndex\",\r\n                        content: index,\r\n                    })); */\r\n                }\r\n                if (!readonly) {\r\n                    promptElement.addEventListener(\"dragstart\", event_1.default.onDragStart);\r\n                    promptElement.addEventListener(\"dragover\", event_1.default.onDragOver);\r\n                    promptElement.addEventListener(\"dragenter\", event_1.default.onDragEnter);\r\n                    promptElement.addEventListener(\"dragleave\", event_1.default.onDragLeave);\r\n                    promptElement.addEventListener(\"drop\", event_1.default.onDrop);\r\n                }\r\n                promptElement.addEventListener(\"click\", event_1.default.onPromptClick);\r\n                proptsContainer.appendChild(promptElement);\r\n                shownItems++;\r\n            }\r\n            wrapper.appendChild(proptsContainer);\r\n            proptsContainer.scrollTo(0, scrollState);\r\n        }\r\n    }\r\n    KnownPrompts.showHeader = (wrapper, params = {}) => {\r\n        const { readonly } = index_2.default.meta;\r\n        const { holdTagsInput = false } = params;\r\n        const { state } = index_1.default;\r\n        const headerContainer = document.createElement(\"div\");\r\n        const categorySelector = document.createElement(\"select\");\r\n        const collectionSelector = document.createElement(\"select\");\r\n        const sortingSelector = document.createElement(\"select\");\r\n        const tagsInput = document.createElement(\"input\");\r\n        const nameInput = document.createElement(\"input\");\r\n        tagsInput.placeholder = \"tag1, tag2, tag3...\";\r\n        nameInput.placeholder = \"by name\";\r\n        const collectionToolsButton = document.createElement(\"button\");\r\n        collectionToolsButton.className = \"PBE_button\";\r\n        collectionToolsButton.innerText = \"Edit collection\";\r\n        collectionToolsButton.style.marginRight = \"10px\";\r\n        categorySelector.className = \"PBE_generalInput\";\r\n        collectionSelector.className = \"PBE_generalInput\";\r\n        sortingSelector.className = \"PBE_generalInput\";\r\n        tagsInput.className = \"PBE_generalInput\";\r\n        nameInput.className = \"PBE_generalInput\";\r\n        headerContainer.className = \"PBE_promptsCatalogueHeader\";\r\n        //categories selector\r\n        const categories = index_2.default.data.categories;\r\n        let options = `\r\n            <option value=\"\">All categories</option>\r\n            <option value=\"__none\">Uncategorised</option>\r\n        `;\r\n        for (const categoryItem of categories) {\r\n            if (!categorySelector.value)\r\n                categorySelector.value = categoryItem;\r\n            options += `<option value=\"${categoryItem}\">${categoryItem}</option>`;\r\n        }\r\n        categorySelector.innerHTML = options;\r\n        if (state.filterCategory)\r\n            categorySelector.value = state.filterCategory;\r\n        categorySelector.addEventListener(\"change\", (e) => {\r\n            const target = e.currentTarget;\r\n            const value = target.value;\r\n            state.filterCategory = value || undefined;\r\n            KnownPrompts.update();\r\n        });\r\n        //collection selector\r\n        options = `<option value=\"\">All collections</option>`;\r\n        for (const collectionId in index_2.default.data.original) {\r\n            options += `<option value=\"${collectionId}\">${collectionId}</option>`;\r\n        }\r\n        collectionSelector.innerHTML = options;\r\n        if (state.filterCollection)\r\n            collectionSelector.value = state.filterCollection;\r\n        collectionSelector.addEventListener(\"change\", (e) => {\r\n            const target = e.currentTarget;\r\n            const value = target.value;\r\n            state.filterCollection = value || undefined;\r\n            state.filesIteration++;\r\n            KnownPrompts.update();\r\n            index_3.default.update(true);\r\n        });\r\n        //sorting selector\r\n        options = `\r\n            <option value=\"\">Unsorted</option>\r\n            <option value=\"reversed\">Unsorted reversed</option>\r\n            <option value=\"alph\">Alphabetical</option>\r\n            <option value=\"alphReversed\">Alphabetical reversed</option>\r\n        `;\r\n        sortingSelector.innerHTML = options;\r\n        if (state.sortKnownPrompts)\r\n            sortingSelector.value = state.sortKnownPrompts;\r\n        sortingSelector.addEventListener(\"change\", (e) => {\r\n            const target = e.currentTarget;\r\n            const value = target.value;\r\n            state.sortKnownPrompts = value || undefined;\r\n            KnownPrompts.update();\r\n        });\r\n        //tags input\r\n        if (state.filterTags)\r\n            tagsInput.value = state.filterTags.join(\", \");\r\n        tagsInput.addEventListener(\"change\", (e) => {\r\n            const target = e.currentTarget;\r\n            const value = target.value;\r\n            if (target.dataset.hint)\r\n                return;\r\n            let tags = value.split(\",\").map(item => item.trim());\r\n            //removing empty tags\r\n            tags = tags.filter(item => item);\r\n            if (!tags)\r\n                state.filterTags = undefined;\r\n            else\r\n                state.filterTags = tags;\r\n            if (state.filterTags && !state.filterTags.length)\r\n                state.filterTags = undefined;\r\n            if (state.filterTags && state.filterTags.length === 1 && !state.filterTags[0])\r\n                state.filterTags = undefined;\r\n            KnownPrompts.update({ holdTagsInput: true });\r\n        });\r\n        //search input\r\n        if (state.filterName)\r\n            nameInput.value = state.filterName;\r\n        nameInput.addEventListener(\"change\", (e) => {\r\n            const target = e.currentTarget;\r\n            let value = target.value || \"\";\r\n            value = value.trim();\r\n            if (value) {\r\n                value = value.toLowerCase();\r\n                state.filterName = value;\r\n            }\r\n            else {\r\n                state.filterName = undefined;\r\n            }\r\n            KnownPrompts.update();\r\n        });\r\n        if (!readonly) {\r\n            collectionToolsButton.addEventListener(\"click\", (e) => {\r\n                if (state.filterCollection)\r\n                    state.collectionToolsId = state.filterCollection;\r\n                index_4.default.update();\r\n            });\r\n            headerContainer.appendChild(collectionToolsButton);\r\n        }\r\n        headerContainer.appendChild(collectionSelector);\r\n        headerContainer.appendChild(categorySelector);\r\n        headerContainer.appendChild(tagsInput);\r\n        headerContainer.appendChild(nameInput);\r\n        headerContainer.appendChild(sortingSelector);\r\n        wrapper.appendChild(headerContainer);\r\n        index_5.default.add(tagsInput);\r\n        if (holdTagsInput)\r\n            tagsInput.focus();\r\n    };\r\n    exports.default = KnownPrompts;\r\n});\r\n","define([\"require\", \"exports\", \"./index\", \"client/index\", \"client/Database/index\", \"client/applyStyle\", \"clientTypes/style\"], function (require, exports, index_1, index_2, index_3, applyStyle_1, style_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class LoadStyleEvent {\r\n        static onCloseWindow() {\r\n            const { state } = index_2.default;\r\n            const wrapper = index_2.default.DOMCache.stylesWindow;\r\n            if (!wrapper || !state.showStylesWindow)\r\n                return;\r\n            state.showStylesWindow = undefined;\r\n            wrapper.style.display = \"none\";\r\n        }\r\n        static onCardClick(e) {\r\n            const isShift = e.shiftKey;\r\n            const isCtrl = e.metaKey || e.ctrlKey;\r\n            if (isShift)\r\n                LoadStyleEvent.onApplyStyle(e, false);\r\n            else if (isCtrl)\r\n                LoadStyleEvent.onRemoveStyle(e);\r\n            else\r\n                LoadStyleEvent.onSelectStyle(e);\r\n        }\r\n        static onChangeFilterCollection(e) {\r\n            const target = e.currentTarget;\r\n            const { state } = index_2.default;\r\n            const value = target.value;\r\n            state.filterStyleCollection = value;\r\n            index_1.default.update();\r\n        }\r\n        static onChangeFilterName(e) {\r\n            const target = e.currentTarget;\r\n            const { state } = index_2.default;\r\n            const value = target.value;\r\n            state.filterStyleName = value.toLowerCase();\r\n            index_1.default.update();\r\n        }\r\n        static onToggleShortMode(e) {\r\n            const { state } = index_2.default;\r\n            const id = \"styles_simplified_view\";\r\n            if (state.toggledButtons.includes(id)) {\r\n                state.toggledButtons = state.toggledButtons.filter(item => item !== id);\r\n            }\r\n            else {\r\n                state.toggledButtons.push(id);\r\n            }\r\n            index_1.default.update();\r\n        }\r\n        static onChangeSaveMeta(e) {\r\n            const target = e.currentTarget;\r\n            const { state } = index_2.default;\r\n            const checked = target.checked;\r\n            const id = target.dataset.id;\r\n            if (!id)\r\n                return;\r\n            if (!state.config)\r\n                state.config = {};\r\n            if (!state.config.saveStyleMeta)\r\n                state.config.saveStyleMeta = {};\r\n            state.config.saveStyleMeta[id] = checked;\r\n            localStorage.setItem(\"PBE_config\", JSON.stringify(state.config));\r\n        }\r\n        static onChangeUpdateMeta(e) {\r\n            const target = e.currentTarget;\r\n            const { state } = index_2.default;\r\n            const checked = target.checked;\r\n            const id = target.dataset.id;\r\n            if (!id)\r\n                return;\r\n            if (!state.config)\r\n                state.config = {};\r\n            if (!state.config.updateStyleMeta)\r\n                state.config.updateStyleMeta = {};\r\n            state.config.updateStyleMeta[id] = checked;\r\n            localStorage.setItem(\"PBE_config\", JSON.stringify(state.config));\r\n        }\r\n        static onChangeApplyMethod(e) {\r\n            const { state } = index_2.default;\r\n            const target = e.currentTarget;\r\n            const value = target.value;\r\n            const isUpdate = target.dataset.update ? true : false;\r\n            if (!value)\r\n                return;\r\n            if (!state.config)\r\n                state.config = {};\r\n            if (isUpdate) {\r\n                if (!state.config.updateStyleMeta)\r\n                    state.config.updateStyleMeta = {};\r\n                state.config.updateStyleMeta.addType = value;\r\n            }\r\n            else {\r\n                if (!state.config.saveStyleMeta)\r\n                    state.config.saveStyleMeta = {};\r\n                state.config.saveStyleMeta.addType = value;\r\n            }\r\n            localStorage.setItem(\"PBE_config\", JSON.stringify(state.config));\r\n        }\r\n        static onRemoveStyle(e) {\r\n            const target = e.currentTarget;\r\n            const { readonly } = index_3.default.meta;\r\n            const { data } = index_3.default;\r\n            if (readonly || !data.styles)\r\n                return;\r\n            let collectionId = undefined;\r\n            let index = undefined;\r\n            if (target.dataset.action) {\r\n                const { selectedItem } = index_1.default;\r\n                collectionId = selectedItem.collection;\r\n                index = selectedItem.index;\r\n            }\r\n            else {\r\n                collectionId = target.dataset.id;\r\n                index = Number(target.dataset.index);\r\n            }\r\n            if (!collectionId || Number.isNaN(index))\r\n                return;\r\n            const targetCollection = data.styles[collectionId];\r\n            if (!targetCollection)\r\n                return;\r\n            const targetStyle = data.styles[collectionId][index];\r\n            if (!targetStyle)\r\n                return;\r\n            if (confirm(`Remove style \"${targetStyle.name}\" from catalogue \"${collectionId}\"?`)) {\r\n                targetCollection.splice(index, 1);\r\n                index_3.default.updateStyles(collectionId);\r\n                index_1.default.update();\r\n            }\r\n        }\r\n        static onRenameStyle(e) {\r\n            const target = e.currentTarget;\r\n            const { data } = index_3.default;\r\n            if (!data.styles)\r\n                return;\r\n            let collectionId = undefined;\r\n            let index = undefined;\r\n            if (target.dataset.action) {\r\n                const { selectedItem } = index_1.default;\r\n                collectionId = selectedItem.collection;\r\n                index = selectedItem.index;\r\n            }\r\n            else {\r\n                collectionId = target.dataset.id;\r\n                index = Number(target.dataset.index);\r\n            }\r\n            if (!collectionId || Number.isNaN(index))\r\n                return;\r\n            const targetCollection = data.styles[collectionId];\r\n            if (!targetCollection)\r\n                return;\r\n            const targetStyle = data.styles[collectionId][index];\r\n            if (!targetStyle)\r\n                return;\r\n            const nameInputField = document.querySelector(\"#PBE_stylesWindow .PBE_nameAction\");\r\n            if (!nameInputField || !nameInputField.value)\r\n                return;\r\n            for (const styleItem of targetCollection) {\r\n                if (styleItem.name === nameInputField.value) {\r\n                    alert(\"Style name already used\");\r\n                    return;\r\n                }\r\n            }\r\n            if (confirm(`Rename style \"${targetStyle.name}\" to \"${nameInputField.value}\"?`)) {\r\n                index_3.default.onRenameStyle(collectionId, targetStyle.name, nameInputField.value);\r\n            }\r\n        }\r\n        static onUpdateStyle(e) {\r\n            const target = e.currentTarget;\r\n            const { data } = index_3.default;\r\n            if (!data.styles)\r\n                return;\r\n            let collectionId = undefined;\r\n            let index = undefined;\r\n            if (target.dataset.action) {\r\n                const { selectedItem } = index_1.default;\r\n                collectionId = selectedItem.collection;\r\n                index = selectedItem.index;\r\n            }\r\n            else {\r\n                collectionId = target.dataset.id;\r\n                index = Number(target.dataset.index);\r\n            }\r\n            if (!collectionId || Number.isNaN(index))\r\n                return;\r\n            const targetCollection = data.styles[collectionId];\r\n            if (!targetCollection)\r\n                return;\r\n            const targetStyle = data.styles[collectionId][index];\r\n            if (!targetStyle)\r\n                return;\r\n            if (confirm(`Replace style \"${targetStyle.name}\" params to the currently selected?`)) {\r\n                const newStyle = index_1.default.grabCurrentStyle(undefined, collectionId, true);\r\n                if (!newStyle)\r\n                    return;\r\n                for (const i in newStyle) {\r\n                    targetStyle[i] = newStyle[i];\r\n                }\r\n                /**\r\n                 * Removing fields that are not part of the style anymore.\r\n                 * Some fields like name or previewImage must be kept in the object.\r\n                 * TODO: I probably should check dictionary of fields that can be added/removed\r\n                 * instead of hardcoding check for things like a name\r\n                 */\r\n                for (const i in targetStyle) {\r\n                    if (i === \"name\")\r\n                        continue;\r\n                    if (i === \"previewImage\")\r\n                        continue;\r\n                    if (!newStyle[i])\r\n                        delete targetStyle[i];\r\n                }\r\n                index_3.default.updateStyles(collectionId);\r\n                index_1.default.update();\r\n            }\r\n        }\r\n        static onSelectStyle(e) {\r\n            const target = e.currentTarget;\r\n            const { data } = index_3.default;\r\n            const { state } = index_2.default;\r\n            const { updateStyleMeta = {} } = state.config || {};\r\n            const collection = target.dataset.id;\r\n            const styleId = target.dataset.name;\r\n            const index = Number(target.dataset.index);\r\n            if (!data || !data.styles || !collection || Number.isNaN(index))\r\n                return;\r\n            if (target.classList.contains(\"PBE_selectedCurrentElement\")) {\r\n                index_1.default.selectedItem = { collection: \"\", styleId: \"\", index: 0 };\r\n                target.classList.remove(\"PBE_selectedCurrentElement\");\r\n            }\r\n            else {\r\n                index_1.default.selectedItem = { collection, styleId, index };\r\n                const prevSelected = target.parentNode.querySelector(\".PBE_selectedCurrentElement\");\r\n                if (prevSelected)\r\n                    prevSelected.classList.remove(\"PBE_selectedCurrentElement\");\r\n                const targetCollection = data.styles[collection];\r\n                if (targetCollection) {\r\n                    const targetStyle = targetCollection[index];\r\n                    const checkBoxesWrapper = document.querySelector(\"#PBE_stylesWindow .PBE_styleMetaCheckboxes\");\r\n                    const nameInputField = document.querySelector(\"#PBE_stylesWindow .PBE_nameAction\");\r\n                    if (targetStyle && checkBoxesWrapper) {\r\n                        const checkStatus = {\r\n                            positive: { id: \"#PBE_UpdatekeepPositive\", checked: targetStyle.positive !== undefined },\r\n                            negative: { id: \"#PBE_UpdatekeepNegative\", checked: targetStyle.negative !== undefined },\r\n                            size: { id: \"#PBE_UpdatekeepSize\", checked: targetStyle.height !== undefined },\r\n                            sampler: { id: \"#PBE_UpdatekeepSampler\", checked: targetStyle.sampling !== undefined },\r\n                            quality: { id: \"#PBE_UpdatekeepQuality\", checked: targetStyle.steps !== undefined },\r\n                            seed: { id: \"#PBE_UpdatekeepSeed\", checked: targetStyle.seed !== undefined },\r\n                        };\r\n                        for (const fieldId in checkStatus) {\r\n                            const field = checkStatus[fieldId];\r\n                            const targetElement = checkBoxesWrapper.querySelector(field.id);\r\n                            targetElement.checked = field.checked;\r\n                            updateStyleMeta[fieldId] = field.checked;\r\n                        }\r\n                        const addTypeSelector = document.querySelector(\"#PBE_stylesWindow .PBE_addStyleTypeSelect\");\r\n                        if (addTypeSelector) {\r\n                            if (targetStyle.addType) {\r\n                                updateStyleMeta.addType = targetStyle.addType;\r\n                                addTypeSelector.value = targetStyle.addType;\r\n                            }\r\n                            else\r\n                                addTypeSelector.value = style_1.AddStyleType.UniqueRoot;\r\n                        }\r\n                        if (state.config)\r\n                            state.config.updateStyleMeta = updateStyleMeta;\r\n                    }\r\n                    if ((targetStyle === null || targetStyle === void 0 ? void 0 : targetStyle.name) && nameInputField) {\r\n                        nameInputField.value = targetStyle.name;\r\n                    }\r\n                }\r\n                target.classList.add(\"PBE_selectedCurrentElement\");\r\n            }\r\n        }\r\n        static onApplyStyle(e, isAfter) {\r\n            const target = e.currentTarget;\r\n            const { data } = index_3.default;\r\n            if (!data.styles)\r\n                return;\r\n            if (isAfter === undefined)\r\n                isAfter = target.dataset.isafter ? true : false;\r\n            let collectionId = undefined;\r\n            let index = undefined;\r\n            if (target.dataset.action) {\r\n                const { selectedItem } = index_1.default;\r\n                collectionId = selectedItem.collection;\r\n                index = selectedItem.index;\r\n            }\r\n            else {\r\n                collectionId = target.dataset.id;\r\n                index = Number(target.dataset.index);\r\n            }\r\n            if (!collectionId || Number.isNaN(index))\r\n                return;\r\n            const targetCollection = data.styles[collectionId];\r\n            if (!targetCollection)\r\n                return;\r\n            const targetStyle = data.styles[collectionId][index];\r\n            if (!targetStyle)\r\n                return;\r\n            (0, applyStyle_1.default)(targetStyle, isAfter);\r\n        }\r\n        static onOpenStyles() {\r\n            const { state } = index_2.default;\r\n            state.showStylesWindow = true;\r\n            index_1.default.update();\r\n        }\r\n    }\r\n    exports.default = LoadStyleEvent;\r\n});\r\n","define([\"require\", \"exports\", \"client/index\", \"client/ActivePrompts/index\", \"client/Database/index\", \"clientTypes/style\", \"client/dom\", \"client/showPromptItem\", \"client/CurrentPrompts/showPrompts\", \"client/const\", \"./event\"], function (require, exports, index_1, index_2, index_3, style_1, dom_1, showPromptItem_1, showPrompts_1, const_1, event_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class LoadStyle {\r\n        static init(mainWrapper) {\r\n            const stylesWindow = document.createElement(\"div\");\r\n            stylesWindow.className = \"PBE_generalWindow PBE_stylesWindow\";\r\n            stylesWindow.id = \"PBE_stylesWindow\";\r\n            index_1.default.DOMCache.stylesWindow = stylesWindow;\r\n            mainWrapper.appendChild(stylesWindow);\r\n            index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n            stylesWindow.addEventListener(\"click\", () => {\r\n                index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n            });\r\n        }\r\n        static initButton(positiveWrapper) {\r\n            const addStylesButton = document.createElement(\"button\");\r\n            addStylesButton.className = \"PBE_actionButton PBE_stylesButton\";\r\n            addStylesButton.innerText = \"Styles\";\r\n            addStylesButton.addEventListener(\"click\", event_1.default.onOpenStyles);\r\n            positiveWrapper.appendChild(addStylesButton);\r\n        }\r\n        static showStyleSetup(wrapper, isUpdate = false) {\r\n            const { state } = index_1.default;\r\n            const { saveStyleMeta = {}, updateStyleMeta = {} } = state.config || {};\r\n            const targetMeta = isUpdate ? updateStyleMeta : saveStyleMeta;\r\n            const paramsRow = (0, dom_1.makeElement)({ element: \"fieldset\", className: \"PBE_fieldset PBE_styleCofig\" });\r\n            const paramsRowLegend = (0, dom_1.makeElement)({ element: \"legend\", content: \"Apply prompts:\" });\r\n            const addTypeSelector = (0, dom_1.makeSelect)({\r\n                className: \"PBE_generalInput PBE_select PBE_addStyleTypeSelect\",\r\n                value: targetMeta.addType || style_1.AddStyleType.UniqueRoot,\r\n                options: [\r\n                    { id: style_1.AddStyleType.All, name: \"All\" },\r\n                    { id: style_1.AddStyleType.UniqueRoot, name: \"Unique in root\" },\r\n                    { id: style_1.AddStyleType.UniqueOnly, name: \"Unique all\" },\r\n                ],\r\n                onChange: event_1.default.onChangeApplyMethod\r\n            });\r\n            if (isUpdate)\r\n                addTypeSelector.dataset.update = \"true\";\r\n            paramsRow.appendChild(paramsRowLegend);\r\n            paramsRow.appendChild(addTypeSelector);\r\n            wrapper.appendChild(paramsRow);\r\n        }\r\n        static showMetaCheckboxes(wrapper, isUpdate = false) {\r\n            const { state } = index_1.default;\r\n            const { saveStyleMeta = {}, updateStyleMeta = {} } = state.config || {};\r\n            const targetMeta = isUpdate ? updateStyleMeta : saveStyleMeta;\r\n            const paramsRow = (0, dom_1.makeElement)({ element: \"fieldset\", className: \"PBE_fieldset PBE_styleMetaCheckboxes\" });\r\n            const paramsRowLegend = (0, dom_1.makeElement)({ element: \"legend\", content: \"Save meta:\" });\r\n            const onChange = isUpdate ? event_1.default.onChangeUpdateMeta : event_1.default.onChangeSaveMeta;\r\n            const prefix = isUpdate ? \"Update\" : \"Save\";\r\n            const keepSeed = (0, dom_1.makeCheckbox)({ onChange, checked: targetMeta.seed, name: \"Seed\", id: `PBE_${prefix}keepSeed`, data: \"seed\" });\r\n            const keepPositive = (0, dom_1.makeCheckbox)({ onChange, checked: targetMeta.positive, name: \"Positive\", id: `PBE_${prefix}keepPositive`, data: \"positive\" });\r\n            const keepNegative = (0, dom_1.makeCheckbox)({ onChange, checked: targetMeta.negative, name: \"Negative\", id: `PBE_${prefix}keepNegative`, data: \"negative\" });\r\n            const keepSize = (0, dom_1.makeCheckbox)({ onChange, checked: targetMeta.size, name: \"Size\", id: `PBE_${prefix}keepSize`, data: \"size\" });\r\n            const keepSampler = (0, dom_1.makeCheckbox)({ onChange, checked: targetMeta.sampler, name: \"Sampler\", id: `PBE_${prefix}keepSampler`, data: \"sampler\" });\r\n            const keepQuality = (0, dom_1.makeCheckbox)({ onChange, checked: targetMeta.quality, name: \"Quality\", id: `PBE_${prefix}keepQuality`, data: \"quality\" });\r\n            paramsRow.appendChild(paramsRowLegend);\r\n            paramsRow.appendChild(keepPositive);\r\n            paramsRow.appendChild(keepNegative);\r\n            paramsRow.appendChild(keepSize);\r\n            paramsRow.appendChild(keepSampler);\r\n            paramsRow.appendChild(keepQuality);\r\n            paramsRow.appendChild(keepSeed);\r\n            wrapper.appendChild(paramsRow);\r\n        }\r\n        static grabCurrentStyle(styleName, collectionId, isUpdate = false) {\r\n            const { data } = index_3.default;\r\n            const { state } = index_1.default;\r\n            const { saveStyleMeta = {}, updateStyleMeta = {} } = state.config || {};\r\n            const targetMeta = isUpdate ? updateStyleMeta : saveStyleMeta;\r\n            if (!collectionId)\r\n                return false;\r\n            if (!data.styles)\r\n                return false;\r\n            let seed = undefined;\r\n            let negative = undefined;\r\n            let width = undefined;\r\n            let height = undefined;\r\n            let steps = undefined;\r\n            let cfg = undefined;\r\n            let sampling = undefined;\r\n            const activePrompts = index_2.default.getCurrentPrompts();\r\n            const seedInput = index_1.default.DOMCache.containers[state.currentContainer].seedInput;\r\n            const negativePrompts = index_1.default.DOMCache.containers[state.currentContainer].negativePrompts;\r\n            const widthInput = index_1.default.DOMCache.containers[state.currentContainer].widthInput;\r\n            const heightInput = index_1.default.DOMCache.containers[state.currentContainer].heightInput;\r\n            const stepsInput = index_1.default.DOMCache.containers[state.currentContainer].stepsInput;\r\n            const cfgInput = index_1.default.DOMCache.containers[state.currentContainer].cfgInput;\r\n            const samplingInput = index_1.default.DOMCache.containers[state.currentContainer].samplingInput;\r\n            if (seedInput) {\r\n                const seedValue = Number(seedInput.value);\r\n                if (seedValue !== undefined && seedValue !== -1 && !Number.isNaN(seedValue))\r\n                    seed = seedValue;\r\n            }\r\n            if (negativePrompts) {\r\n                const negativeTextAreas = negativePrompts.getElementsByTagName(\"textarea\");\r\n                if (negativeTextAreas && negativeTextAreas[0])\r\n                    negative = negativeTextAreas[0].value;\r\n            }\r\n            if (widthInput)\r\n                width = Number(widthInput.value);\r\n            if (heightInput)\r\n                height = Number(heightInput.value);\r\n            if (stepsInput)\r\n                steps = Number(stepsInput.value);\r\n            if (cfgInput)\r\n                cfg = Number(cfgInput.value);\r\n            if (samplingInput)\r\n                sampling = samplingInput.value;\r\n            if (Number.isNaN(width))\r\n                width = undefined;\r\n            if (Number.isNaN(height))\r\n                height = undefined;\r\n            if (Number.isNaN(steps))\r\n                steps = undefined;\r\n            if (Number.isNaN(cfg))\r\n                cfg = undefined;\r\n            const targetCollection = data.styles[collectionId];\r\n            if (!targetCollection)\r\n                return;\r\n            const newStyle = {};\r\n            if (styleName)\r\n                newStyle.name = styleName;\r\n            //positive prompts. added as array of prompt objects\r\n            if (targetMeta.positive) {\r\n                if (activePrompts && activePrompts.length)\r\n                    newStyle.positive = JSON.parse(JSON.stringify(activePrompts));\r\n                else\r\n                    newStyle.positive = [];\r\n            }\r\n            if (targetMeta.seed && seed !== undefined)\r\n                newStyle.seed = seed;\r\n            //negative prompts. currently added as a string, may be changed to array of prompts in future\r\n            if (targetMeta.negative && negative !== undefined)\r\n                newStyle.negative = negative;\r\n            if (targetMeta.size && width !== undefined)\r\n                newStyle.width = width;\r\n            if (targetMeta.size && height !== undefined)\r\n                newStyle.height = height;\r\n            if (targetMeta.quality && steps !== undefined)\r\n                newStyle.steps = steps;\r\n            if (targetMeta.quality && cfg !== undefined)\r\n                newStyle.cfg = cfg;\r\n            if (targetMeta.sampler && sampling)\r\n                newStyle.sampling = sampling;\r\n            if (targetMeta.addType)\r\n                newStyle.addType = targetMeta.addType;\r\n            return newStyle;\r\n        }\r\n        static showFilters(wrapper) {\r\n            const { data } = index_3.default;\r\n            const { state } = index_1.default;\r\n            const toggleShortMode = document.createElement(\"div\");\r\n            toggleShortMode.className = \"PBE_toggleButton\";\r\n            toggleShortMode.innerText = \"Simple mode\";\r\n            toggleShortMode.title = \"Toggles simplified view mode\";\r\n            if (state.toggledButtons.includes(\"styles_simplified_view\"))\r\n                toggleShortMode.classList.add(\"PBE_toggledButton\");\r\n            toggleShortMode.style.height = \"16px\";\r\n            toggleShortMode.addEventListener(\"click\", event_1.default.onToggleShortMode);\r\n            const collectionSelect = document.createElement(\"select\");\r\n            collectionSelect.className = \"PBE_generalInput PBE_select\";\r\n            let options = \"<option value=''>Any</option>\";\r\n            for (const collectionId in data.styles) {\r\n                options += `<option value=\"${collectionId}\">${collectionId}</option>`;\r\n            }\r\n            collectionSelect.innerHTML = options;\r\n            collectionSelect.value = state.filterStyleCollection || \"\";\r\n            collectionSelect.addEventListener(\"change\", event_1.default.onChangeFilterCollection);\r\n            const nameFilter = document.createElement(\"input\");\r\n            nameFilter.placeholder = \"Search name\";\r\n            nameFilter.className = \"PBE_generalInput PBE_input\";\r\n            nameFilter.value = state.filterStyleName || \"\";\r\n            nameFilter.addEventListener(\"change\", event_1.default.onChangeFilterName);\r\n            wrapper.appendChild(toggleShortMode);\r\n            wrapper.appendChild(collectionSelect);\r\n            wrapper.appendChild(nameFilter);\r\n        }\r\n        static showStylesShort(wrapper) {\r\n            const { data } = index_3.default;\r\n            const { filterStyleCollection, filterStyleName } = index_1.default.state;\r\n            let styles = [];\r\n            for (const collectionId in data.styles) {\r\n                for (let i = 0; i < data.styles[collectionId].length; i++) {\r\n                    const styleItem = data.styles[collectionId][i];\r\n                    styles.push(Object.assign(Object.assign({}, styleItem), { id: collectionId, index: i }));\r\n                }\r\n            }\r\n            styles.sort((A, B) => {\r\n                if (A.name > B.name)\r\n                    return 1;\r\n                if (A.name < B.name)\r\n                    return -1;\r\n                return 0;\r\n            });\r\n            for (const style of styles) {\r\n                const { name, positive, negative, width, height, steps, cfg, sampling, id, index, previewImage } = style;\r\n                if (!name)\r\n                    continue;\r\n                if (filterStyleCollection && filterStyleCollection !== id)\r\n                    continue;\r\n                if (filterStyleName && !name.toLowerCase().includes(filterStyleName))\r\n                    continue;\r\n                let url = const_1.EMPTY_CARD_GRADIENT;\r\n                if (previewImage)\r\n                    url = index_3.default.getStylePreviewURL(style);\r\n                const element = (0, showPromptItem_1.default)({\r\n                    prompt: { id: name },\r\n                    options: { url },\r\n                });\r\n                element.dataset.id = id;\r\n                element.dataset.index = index + \"\";\r\n                element.dataset.name = name;\r\n                if (LoadStyle.selectedItem.collection === id && LoadStyle.selectedItem.index === index) {\r\n                    element.classList.add(\"PBE_selectedCurrentElement\");\r\n                }\r\n                element.addEventListener(\"click\", event_1.default.onCardClick);\r\n                wrapper.appendChild(element);\r\n            }\r\n        }\r\n        static showActions(wrapper, isShort = true) {\r\n            const { readonly } = index_3.default.meta;\r\n            const nameContainer = (0, dom_1.makeElement)({ element: \"fieldset\", className: \"PBE_fieldset\" });\r\n            const nameLegend = (0, dom_1.makeElement)({ element: \"legend\", content: \"Name\" });\r\n            const nameField = (0, dom_1.makeElement)({ element: \"input\", className: \"PBE_generalInput PBE_input PBE_nameAction\" });\r\n            nameField.placeholder = \"Style name\";\r\n            const renameButton = (0, dom_1.makeElement)({ element: \"div\", className: \"PBE_button\", content: \"Rename\", title: \"Rename selected style\" });\r\n            renameButton.dataset.action = \"true\";\r\n            renameButton.addEventListener(\"click\", event_1.default.onRenameStyle);\r\n            nameContainer.appendChild(nameLegend);\r\n            nameContainer.appendChild(nameField);\r\n            nameContainer.appendChild(renameButton);\r\n            if (!isShort) {\r\n                if (!readonly) {\r\n                    wrapper.appendChild(nameContainer);\r\n                    LoadStyle.showMetaCheckboxes(wrapper, true);\r\n                    LoadStyle.showStyleSetup(wrapper, true);\r\n                }\r\n                return;\r\n            }\r\n            const actionContainer = document.createElement(\"fieldset\");\r\n            actionContainer.className = \"PBE_fieldset\";\r\n            const actionLegend = document.createElement(\"legend\");\r\n            actionLegend.innerText = \"Actions\";\r\n            const addBeforeButton = document.createElement(\"div\");\r\n            addBeforeButton.innerText = \"Add before\";\r\n            addBeforeButton.className = \"PBE_button\";\r\n            addBeforeButton.title = \"Add style prompts at the start of current prompts\";\r\n            addBeforeButton.dataset.action = \"true\";\r\n            addBeforeButton.addEventListener(\"click\", event_1.default.onApplyStyle);\r\n            const addAfterButton = document.createElement(\"div\");\r\n            addAfterButton.innerText = \"Add after\";\r\n            addAfterButton.className = \"PBE_button\";\r\n            addAfterButton.title = \"Add style prompts at the end of current prompts\";\r\n            addAfterButton.dataset.action = \"true\";\r\n            addAfterButton.dataset.isafter = \"true\";\r\n            addAfterButton.addEventListener(\"click\", event_1.default.onApplyStyle);\r\n            actionContainer.appendChild(actionLegend);\r\n            actionContainer.appendChild(addBeforeButton);\r\n            actionContainer.appendChild(addAfterButton);\r\n            const editContainer = document.createElement(\"fieldset\");\r\n            editContainer.className = \"PBE_fieldset\";\r\n            const editLegend = document.createElement(\"legend\");\r\n            editLegend.innerText = \"Edit\";\r\n            const updateButton = document.createElement(\"div\");\r\n            updateButton.innerText = \"Update\";\r\n            updateButton.className = \"PBE_button\";\r\n            updateButton.title = \"Update selected style\";\r\n            updateButton.dataset.action = \"true\";\r\n            updateButton.addEventListener(\"click\", event_1.default.onUpdateStyle);\r\n            const updatePreviewButton = document.createElement(\"div\");\r\n            updatePreviewButton.innerText = \"Update preview\";\r\n            updatePreviewButton.className = \"PBE_button\";\r\n            updatePreviewButton.title = \"Delete selected style\";\r\n            updatePreviewButton.dataset.action = \"true\";\r\n            updatePreviewButton.addEventListener(\"click\", index_3.default.onUpdateStylePreview);\r\n            editContainer.appendChild(editLegend);\r\n            editContainer.appendChild(updateButton);\r\n            editContainer.appendChild(updatePreviewButton);\r\n            const systemContainer = document.createElement(\"fieldset\");\r\n            systemContainer.className = \"PBE_fieldset\";\r\n            const systemLegend = document.createElement(\"legend\");\r\n            systemLegend.innerText = \"System\";\r\n            const deleteButton = document.createElement(\"div\");\r\n            deleteButton.innerText = \"Delete\";\r\n            deleteButton.className = \"PBE_button PBE_buttonCancel\";\r\n            deleteButton.title = \"Delete selected style\";\r\n            deleteButton.dataset.action = \"true\";\r\n            deleteButton.addEventListener(\"click\", event_1.default.onRemoveStyle);\r\n            systemContainer.appendChild(systemLegend);\r\n            systemContainer.appendChild(deleteButton);\r\n            wrapper.appendChild(actionContainer);\r\n            if (!readonly) {\r\n                wrapper.appendChild(editContainer);\r\n                wrapper.appendChild(nameContainer);\r\n                LoadStyle.showMetaCheckboxes(wrapper, true);\r\n                LoadStyle.showStyleSetup(wrapper, true);\r\n                wrapper.appendChild(systemContainer);\r\n            }\r\n        }\r\n        static showStyles(wrapper) {\r\n            const { readonly } = index_3.default.meta;\r\n            const { data } = index_3.default;\r\n            const { state } = index_1.default;\r\n            const { filterStyleCollection, filterStyleName } = state;\r\n            const activePrompts = index_2.default.getCurrentPrompts();\r\n            let styles = [];\r\n            for (const collectionId in data.styles) {\r\n                for (let i = 0; i < data.styles[collectionId].length; i++) {\r\n                    const styleItem = data.styles[collectionId][i];\r\n                    styles.push(Object.assign(Object.assign({}, styleItem), { id: collectionId, index: i }));\r\n                }\r\n            }\r\n            styles.sort((A, B) => {\r\n                if (A.name > B.name)\r\n                    return 1;\r\n                if (A.name < B.name)\r\n                    return -1;\r\n                return 0;\r\n            });\r\n            for (const style of styles) {\r\n                const { name, positive, negative, width, height, steps, cfg, sampling, id, index, previewImage } = style;\r\n                if (filterStyleCollection && filterStyleCollection !== id)\r\n                    continue;\r\n                if (filterStyleName && !name.toLowerCase().includes(filterStyleName))\r\n                    continue;\r\n                const stylesItem = document.createElement(\"div\");\r\n                const styleHeader = document.createElement(\"div\");\r\n                const nameContainer = document.createElement(\"div\");\r\n                const contentContainer = document.createElement(\"div\");\r\n                const metaInfoContainer = document.createElement(\"div\");\r\n                const updatePreview = document.createElement(\"div\");\r\n                const currentPromptsContainer = document.createElement(\"div\");\r\n                const actionsContainer = document.createElement(\"div\");\r\n                stylesItem.className = \"PBE_styleItem\";\r\n                styleHeader.className = \"PBE_styleHeader\";\r\n                nameContainer.className = \"PBE_styleItemName\";\r\n                contentContainer.className = \"PBE_styleItemContent\";\r\n                metaInfoContainer.className = \"PBE_styleItemMetaInfo\";\r\n                currentPromptsContainer.className = \"PBE_stylesCurrentList PBE_Scrollbar\";\r\n                actionsContainer.className = \"PBE_stylesAction\";\r\n                updatePreview.className = \"PBE_button\";\r\n                if (previewImage) {\r\n                    const url = index_3.default.getStylePreviewURL(style);\r\n                    stylesItem.style.backgroundImage = url;\r\n                }\r\n                nameContainer.innerText = name;\r\n                updatePreview.innerText = \"Update preview\";\r\n                updatePreview.dataset.id = name;\r\n                updatePreview.dataset.collection = id;\r\n                if (positive && positive.length) {\r\n                    (0, showPrompts_1.default)({\r\n                        prompts: positive,\r\n                        wrapper: currentPromptsContainer,\r\n                        allowMove: false,\r\n                    });\r\n                }\r\n                /* currentPromptsContainer.addEventListener(\"wheel\", (e) => {\r\n                    if(!e.deltaY) return;\r\n            \r\n                    e.currentTarget.scrollLeft += e.deltaY + e.deltaX;\r\n                    e.preventDefault();\r\n                }); */\r\n                const addBeforeButton = document.createElement(\"button\");\r\n                const addAfterButton = document.createElement(\"button\");\r\n                const removeButton = document.createElement(\"button\");\r\n                const updateButton = document.createElement(\"button\");\r\n                addBeforeButton.innerText = \"Add before\";\r\n                addAfterButton.innerText = \"Add after\";\r\n                removeButton.innerText = \"Remove\";\r\n                updateButton.innerText = \"Update\";\r\n                addBeforeButton.className = \"PBE_button\";\r\n                addAfterButton.className = \"PBE_button\";\r\n                removeButton.className = \"PBE_button PBE_buttonCancel\";\r\n                updateButton.className = \"PBE_button\";\r\n                addAfterButton.dataset.isafter = \"true\";\r\n                stylesItem.dataset.name = name;\r\n                stylesItem.dataset.id = id;\r\n                addAfterButton.dataset.id = id;\r\n                addBeforeButton.dataset.id = id;\r\n                removeButton.dataset.id = id;\r\n                updateButton.dataset.id = id;\r\n                stylesItem.dataset.index = index + \"\";\r\n                addAfterButton.dataset.index = index + \"\";\r\n                addBeforeButton.dataset.index = index + \"\";\r\n                removeButton.dataset.index = index + \"\";\r\n                updateButton.dataset.index = index + \"\";\r\n                addBeforeButton.addEventListener(\"click\", event_1.default.onApplyStyle);\r\n                addAfterButton.addEventListener(\"click\", event_1.default.onApplyStyle);\r\n                removeButton.addEventListener(\"click\", event_1.default.onRemoveStyle);\r\n                updateButton.addEventListener(\"click\", event_1.default.onUpdateStyle);\r\n                updatePreview.addEventListener(\"click\", index_3.default.onUpdateStylePreview);\r\n                actionsContainer.appendChild(addBeforeButton);\r\n                if (activePrompts && activePrompts.length)\r\n                    actionsContainer.appendChild(addAfterButton);\r\n                if (!readonly) {\r\n                    actionsContainer.appendChild(removeButton);\r\n                    if (activePrompts && activePrompts.length)\r\n                        actionsContainer.appendChild(updateButton);\r\n                }\r\n                contentContainer.appendChild(currentPromptsContainer);\r\n                contentContainer.appendChild(actionsContainer);\r\n                styleHeader.appendChild(nameContainer);\r\n                if (!readonly)\r\n                    styleHeader.appendChild(updatePreview);\r\n                let metaInfo = []; //steps, cfg, sampling\r\n                if (negative)\r\n                    metaInfo.push(`<span class=\"PBE_styleMetaField\">Negative:</span> \"${negative}\"`);\r\n                if (width)\r\n                    metaInfo.push(`<span class=\"PBE_styleMetaField\">Width:</span> ${width}`);\r\n                if (height)\r\n                    metaInfo.push(`<span class=\"PBE_styleMetaField\">Height:</span> ${height}`);\r\n                if (sampling)\r\n                    metaInfo.push(`<span class=\"PBE_styleMetaField\">Sampling:</span> ${sampling}`);\r\n                if (steps)\r\n                    metaInfo.push(`<span class=\"PBE_styleMetaField\">Steps:</span> ${steps}`);\r\n                if (cfg)\r\n                    metaInfo.push(`<span class=\"PBE_styleMetaField\">CFG:</span> ${cfg}`);\r\n                metaInfoContainer.innerHTML = metaInfo.join(\"; \");\r\n                stylesItem.appendChild(styleHeader);\r\n                stylesItem.appendChild(contentContainer);\r\n                stylesItem.appendChild(metaInfoContainer);\r\n                stylesItem.addEventListener(\"click\", event_1.default.onSelectStyle);\r\n                wrapper.appendChild(stylesItem);\r\n            }\r\n        }\r\n        static update() {\r\n            const { state } = index_1.default;\r\n            const wrapper = index_1.default.DOMCache.stylesWindow;\r\n            if (!wrapper || !state.showStylesWindow)\r\n                return;\r\n            index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n            wrapper.innerHTML = \"\";\r\n            wrapper.style.display = \"flex\";\r\n            const isShort = state.toggledButtons.includes(\"styles_simplified_view\");\r\n            const possibleStylesBlock = document.createElement(\"div\");\r\n            const footerBlock = document.createElement(\"div\");\r\n            const closeButton = document.createElement(\"button\");\r\n            footerBlock.className = \"PBE_rowBlock PBE_rowBlock_wide\";\r\n            closeButton.innerText = \"Close\";\r\n            closeButton.className = \"PBE_button\";\r\n            if (isShort) {\r\n                possibleStylesBlock.className = \"PBE_dataBlock PBE_Scrollbar PBE_windowContent\";\r\n                LoadStyle.showStylesShort(possibleStylesBlock);\r\n            }\r\n            else {\r\n                possibleStylesBlock.className = \"PBE_dataColumn PBE_Scrollbar PBE_windowContent\";\r\n                LoadStyle.showStyles(possibleStylesBlock);\r\n            }\r\n            closeButton.addEventListener(\"click\", event_1.default.onCloseWindow);\r\n            footerBlock.appendChild(closeButton);\r\n            const filterBlock = document.createElement(\"div\");\r\n            filterBlock.className = \"PBE_row PBE_stylesFilter\";\r\n            LoadStyle.showFilters(filterBlock);\r\n            wrapper.appendChild(filterBlock);\r\n            wrapper.appendChild(possibleStylesBlock);\r\n            const actionsBlock = document.createElement(\"div\");\r\n            actionsBlock.className = \"PBE_collectionToolsActions PBE_row\";\r\n            LoadStyle.showActions(actionsBlock, isShort);\r\n            wrapper.appendChild(actionsBlock);\r\n            wrapper.appendChild(footerBlock);\r\n        }\r\n        ;\r\n    }\r\n    LoadStyle.selectedItem = {\r\n        collection: \"\",\r\n        styleId: \"\",\r\n        index: 0,\r\n    };\r\n    exports.default = LoadStyle;\r\n});\r\n","define([\"require\", \"exports\", \"client/index\", \"client/Database/index\"], function (require, exports, index_1, index_2) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class PreviewSave {\r\n        static onSavePreview() {\r\n            index_2.default.savePromptPreview();\r\n        }\r\n    }\r\n    PreviewSave.init = (wrapper, containerId) => {\r\n        const savePromptWrapper = document.createElement(\"div\");\r\n        wrapper.appendChild(savePromptWrapper);\r\n        index_1.default.DOMCache.containers[containerId].savePromptWrapper = savePromptWrapper;\r\n    };\r\n    PreviewSave.update = () => {\r\n        const { data } = index_2.default;\r\n        const { readonly } = index_2.default.meta;\r\n        const { state } = index_1.default;\r\n        const wrapper = index_1.default.DOMCache.containers[state.currentContainer].savePromptWrapper;\r\n        if (readonly || !wrapper)\r\n            return;\r\n        wrapper.innerHTML = \"\";\r\n        if (!state.selectedPrompt)\r\n            return;\r\n        const savePromptPreviewButton = document.createElement(\"div\");\r\n        savePromptPreviewButton.className = \"PBE_actionButton PBE_savePromptPreview\";\r\n        savePromptPreviewButton.innerText = \"save preview\";\r\n        const collectionSelect = document.createElement(\"select\");\r\n        collectionSelect.className = \"PBE_generalInput PBE_select PBE_savePromptSelect\";\r\n        let options = \"\";\r\n        for (const collectionId in data.original) {\r\n            if (!state.savePreviewCollection)\r\n                state.savePreviewCollection = collectionId;\r\n            options += `<option value=\"${collectionId}\">${collectionId}</option>`;\r\n        }\r\n        collectionSelect.innerHTML = options;\r\n        if (state.savePreviewCollection)\r\n            collectionSelect.value = state.savePreviewCollection;\r\n        collectionSelect.addEventListener(\"change\", (e) => {\r\n            const target = e.currentTarget;\r\n            const value = target.value;\r\n            state.savePreviewCollection = value || undefined;\r\n        });\r\n        savePromptPreviewButton.removeEventListener(\"click\", PreviewSave.onSavePreview);\r\n        savePromptPreviewButton.addEventListener(\"click\", PreviewSave.onSavePreview);\r\n        wrapper.appendChild(collectionSelect);\r\n        wrapper.appendChild(savePromptPreviewButton);\r\n    };\r\n    exports.default = PreviewSave;\r\n});\r\n","define([\"require\", \"exports\", \"./index\", \"client/index\", \"client/Database/index\"], function (require, exports, index_1, index_2, index_3) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class PromptEditEvent {\r\n        static onCloseWindow() {\r\n            const { state } = index_2.default;\r\n            const wrapper = index_2.default.DOMCache.promptEdit;\r\n            if (!wrapper || !state.editingPrompt)\r\n                return;\r\n            state.editingPrompt = undefined;\r\n            wrapper.style.display = \"none\";\r\n        }\r\n        static onAddTags(targetItem, inputElement) {\r\n            if (!inputElement || !targetItem)\r\n                return;\r\n            const value = inputElement.value;\r\n            let tags = value.split(\",\").map(item => item.trim());\r\n            //removing empty tags\r\n            tags = tags.filter(item => item);\r\n            for (const tag of tags) {\r\n                if (targetItem.tags.includes(tag))\r\n                    continue;\r\n                targetItem.tags.push(tag);\r\n            }\r\n            index_1.default.update(targetItem);\r\n        }\r\n        static onChangeAutogenCollection(value, prompt) {\r\n            if (!prompt)\r\n                return;\r\n            const { data } = index_3.default;\r\n            if (!prompt.autogen)\r\n                prompt.autogen = {};\r\n            if (!value || value === \"__none\")\r\n                delete prompt.autogen.collection;\r\n            else {\r\n                prompt.autogen.collection = value;\r\n                const targetCollection = data.styles[value];\r\n                if (!targetCollection)\r\n                    return;\r\n                prompt.autogen.style = \"\";\r\n                for (const styleItem of targetCollection) {\r\n                    prompt.autogen.style = styleItem.name;\r\n                    break;\r\n                }\r\n            }\r\n            index_1.default.update(prompt);\r\n        }\r\n        static onChangeAutogenStyle(value, prompt) {\r\n            if (!prompt || !value)\r\n                return;\r\n            if (!prompt.autogen)\r\n                prompt.autogen = {};\r\n            prompt.autogen.style = value;\r\n            index_1.default.update(prompt);\r\n        }\r\n    }\r\n    exports.default = PromptEditEvent;\r\n});\r\n","define([\"require\", \"exports\", \"client/index\", \"client/Database/index\", \"client/KnownPrompts/index\", \"client/CollectionTools/index\", \"client/TagTooltip/index\", \"client/dom\", \"./event\"], function (require, exports, index_1, index_2, index_3, index_4, index_5, dom_1, event_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class PromptEdit {\r\n        static init(wrapper) {\r\n            const promptEdit = document.createElement(\"div\");\r\n            promptEdit.className = \"PBE_promptEdit PBE_generalWindow\";\r\n            index_1.default.DOMCache.promptEdit = promptEdit;\r\n            wrapper.appendChild(promptEdit);\r\n            index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n            promptEdit.addEventListener(\"click\", () => {\r\n                index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n            });\r\n        }\r\n        static addCollectionSelector(wrapper) {\r\n            const { state } = index_1.default;\r\n            const { data } = index_2.default;\r\n            const { united } = data;\r\n            const targetItem = united.find(item => item.id === state.editingPrompt);\r\n            if (!targetItem)\r\n                return;\r\n            if (!targetItem.collections)\r\n                return;\r\n            if (targetItem.collections.length === 1) {\r\n                const collName = targetItem.collections[0];\r\n                const singleCollName = (0, dom_1.makeElement)({\r\n                    element: \"div\",\r\n                    content: collName,\r\n                    className: \"PBE_promptEditSingleCollection\"\r\n                });\r\n                wrapper.appendChild(singleCollName);\r\n                return;\r\n            }\r\n            const collectionSelect = document.createElement(\"select\");\r\n            collectionSelect.className = \"PBE_generalInput\";\r\n            let options = \"\";\r\n            for (const collectionItem of targetItem.collections) {\r\n                options += `<option value=\"${collectionItem}\">${collectionItem}</option>`;\r\n            }\r\n            collectionSelect.innerHTML = options;\r\n            if (state.editTargetCollection)\r\n                collectionSelect.value = state.editTargetCollection;\r\n            collectionSelect.addEventListener(\"change\", (e) => {\r\n                const target = e.currentTarget;\r\n                const value = target.value;\r\n                state.editTargetCollection = value || undefined;\r\n                PromptEdit.update();\r\n            });\r\n            wrapper.appendChild(collectionSelect);\r\n        }\r\n        static addMoveBlock(wrapper) {\r\n            const { data } = index_2.default;\r\n            const { united } = data;\r\n            const { state } = index_1.default;\r\n            const copyOrMoveBlock = document.createElement(\"div\");\r\n            const collectionSelect = document.createElement(\"select\");\r\n            const copyButton = document.createElement(\"button\");\r\n            const moveButton = document.createElement(\"button\");\r\n            const targetItem = united.find(item => item.id === state.editingPrompt);\r\n            if (!targetItem)\r\n                return;\r\n            let atLestOnePossibleCollection = false;\r\n            collectionSelect.className = \"PBE_generalInput\";\r\n            copyOrMoveBlock.className = \"PBE_rowBlock\";\r\n            copyButton.className = \"PBE_button\";\r\n            moveButton.className = \"PBE_button\";\r\n            copyButton.innerText = \"Copy\";\r\n            moveButton.innerText = \"Move\";\r\n            let options = \"\";\r\n            for (const collectionId in data.original) {\r\n                if (targetItem.collections && targetItem.collections.includes(collectionId)) {\r\n                    if (state.copyOrMoveTo === collectionId)\r\n                        state.copyOrMoveTo = undefined;\r\n                    continue;\r\n                }\r\n                ;\r\n                if (!atLestOnePossibleCollection)\r\n                    atLestOnePossibleCollection = true;\r\n                if (!state.copyOrMoveTo)\r\n                    state.copyOrMoveTo = collectionId;\r\n                options += `<option value=\"${collectionId}\">${collectionId}</option>`;\r\n            }\r\n            if (!atLestOnePossibleCollection)\r\n                return;\r\n            collectionSelect.innerHTML = options;\r\n            if (state.copyOrMoveTo)\r\n                collectionSelect.value = state.copyOrMoveTo;\r\n            collectionSelect.addEventListener(\"change\", (e) => {\r\n                const target = e.currentTarget;\r\n                const value = target.value;\r\n                state.copyOrMoveTo = value || undefined;\r\n            });\r\n            copyButton.addEventListener(\"click\", (e) => {\r\n                const to = state.copyOrMoveTo;\r\n                const from = state.editTargetCollection;\r\n                if (!to || !from)\r\n                    return;\r\n                if (!data.original[to] || !data.original[from])\r\n                    return;\r\n                const originalItem = data.original[from].find(item => item.id === state.editingPrompt);\r\n                if (!originalItem)\r\n                    return;\r\n                if (data.original[to].some(item => item.id === state.editingPrompt))\r\n                    return;\r\n                data.original[to].push(JSON.parse(JSON.stringify(originalItem)));\r\n                index_2.default.movePreviewImage(state.editingPrompt, from, to, \"copy\");\r\n                index_2.default.saveJSONData(to, true);\r\n                index_2.default.updateMixedList();\r\n                PromptEdit.update();\r\n            });\r\n            moveButton.addEventListener(\"click\", (e) => {\r\n                const { data } = index_2.default;\r\n                const to = state.copyOrMoveTo;\r\n                const from = state.editTargetCollection;\r\n                if (!to || !from)\r\n                    return;\r\n                if (!data.original[to] || !data.original[from])\r\n                    return;\r\n                const originalItem = data.original[from].find(item => item.id === state.editingPrompt);\r\n                if (!originalItem)\r\n                    return;\r\n                if (!data.original[to].some(item => item.id === state.editingPrompt)) {\r\n                    data.original[to].push(JSON.parse(JSON.stringify(originalItem)));\r\n                }\r\n                data.original[from] = data.original[from].filter(item => item.id !== state.editingPrompt);\r\n                index_2.default.movePreviewImage(state.editingPrompt, from, to, \"move\");\r\n                index_2.default.saveJSONData(to, true);\r\n                index_2.default.saveJSONData(from, true);\r\n                index_2.default.updateMixedList();\r\n                PromptEdit.update();\r\n            });\r\n            copyOrMoveBlock.appendChild(collectionSelect);\r\n            copyOrMoveBlock.appendChild(copyButton);\r\n            copyOrMoveBlock.appendChild(moveButton);\r\n            wrapper.appendChild(copyOrMoveBlock);\r\n        }\r\n        static saveEdit() {\r\n            const { data } = index_2.default;\r\n            const { united } = data;\r\n            const { state } = index_1.default;\r\n            const wrapper = index_1.default.DOMCache.promptEdit;\r\n            const collection = data.original[state.editTargetCollection];\r\n            wrapper.style.display = \"none\";\r\n            if (!state.editItem || !collection)\r\n                return;\r\n            const commentBlock = wrapper.querySelector(\"#PBE_commentArea\");\r\n            const addAtStartInput = wrapper.querySelector(\".PBE_promptEdit_addAtStart\");\r\n            const addAfterInput = wrapper.querySelector(\".PBE_promptEdit_addAfter\");\r\n            const addStartInput = wrapper.querySelector(\".PBE_promptEdit_addStart\");\r\n            const addEndInput = wrapper.querySelector(\".PBE_promptEdit_addEnd\");\r\n            const tagsList = wrapper.querySelectorAll(\".PBE_tagsList > div\");\r\n            const categoriesList = wrapper.querySelectorAll(\".PBE_categoryList > div\");\r\n            const autoGenCollectionSelect = wrapper.querySelector(\"#PBE_autoGentCollection\");\r\n            const autoGentStyleSelect = wrapper.querySelector(\"#PBE_autoGentStyle\");\r\n            const comment = commentBlock ? commentBlock.value : \"\";\r\n            const addAtStart = addAtStartInput.checked;\r\n            const addAfter = addAfterInput.value;\r\n            const addStart = addStartInput.value;\r\n            const addEnd = addEndInput.value;\r\n            const tags = [];\r\n            const category = [];\r\n            const autogenCollection = (autoGenCollectionSelect === null || autoGenCollectionSelect === void 0 ? void 0 : autoGenCollectionSelect.value) || undefined;\r\n            const autogenStyle = (autoGentStyleSelect === null || autoGentStyleSelect === void 0 ? void 0 : autoGentStyleSelect.value) || undefined;\r\n            for (const divItem of tagsList)\r\n                tags.push(divItem.innerText);\r\n            for (const divItem of categoriesList)\r\n                category.push(divItem.innerText);\r\n            state.editItem.comment = comment;\r\n            if (!state.editItem.comment)\r\n                delete state.editItem.comment;\r\n            const indexInOrigin = collection.findIndex(item => item.id === state.editingPrompt);\r\n            if (indexInOrigin !== -1)\r\n                collection[indexInOrigin] = state.editItem;\r\n            else\r\n                collection.push(state.editItem);\r\n            const collectionPrompt = collection.find(item => item.id === state.editingPrompt);\r\n            if (!collectionPrompt)\r\n                return;\r\n            collectionPrompt.tags = tags;\r\n            collectionPrompt.category = category;\r\n            if (!addAtStart)\r\n                delete collectionPrompt.addAtStart;\r\n            else\r\n                collectionPrompt.addAtStart = addAtStart;\r\n            if (!addAfter)\r\n                delete collectionPrompt.addAfter;\r\n            else\r\n                collectionPrompt.addAfter = addAfter;\r\n            if (!addStart)\r\n                delete collectionPrompt.addStart;\r\n            else\r\n                collectionPrompt.addStart = addStart;\r\n            if (!addEnd)\r\n                delete collectionPrompt.addEnd;\r\n            else\r\n                collectionPrompt.addEnd = addEnd;\r\n            if (autogenStyle && autogenCollection) {\r\n                if (!collectionPrompt.autogen)\r\n                    collectionPrompt.autogen = {};\r\n                collectionPrompt.autogen.collection = autogenCollection;\r\n                collectionPrompt.autogen.style = autogenStyle;\r\n            }\r\n            else\r\n                delete collectionPrompt.autogen;\r\n            index_2.default.saveJSONData(state.editTargetCollection);\r\n            index_2.default.updateMixedList();\r\n            state.editTargetCollection = undefined;\r\n            state.editingPrompt = undefined;\r\n            index_3.default.update();\r\n            index_4.default.update(true);\r\n        }\r\n        static getTargetItem() {\r\n            const { data } = index_2.default;\r\n            const { united } = data;\r\n            const { state } = index_1.default;\r\n            const targetItem = united.find(item => item.id === state.editingPrompt);\r\n            if (!targetItem)\r\n                return false;\r\n            if (!targetItem.collections)\r\n                return false;\r\n            if (!targetItem.collections[0])\r\n                return false;\r\n            if (!targetItem.collections.includes(state.editTargetCollection)) {\r\n                state.editTargetCollection = targetItem.collections[0];\r\n            }\r\n            let collection = data.original[state.editTargetCollection];\r\n            if (!collection)\r\n                return false;\r\n            const originalItem = collection.find(item => item.id === state.editingPrompt);\r\n            if (!originalItem)\r\n                return false;\r\n            state.editItem = JSON.parse(JSON.stringify(originalItem));\r\n            return state.editItem;\r\n        }\r\n        static showAddSetup(wrapper) {\r\n            const targetItem = PromptEdit.getTargetItem();\r\n            if (!targetItem)\r\n                return;\r\n            const { addAtStart = false, addAfter = \"\", addStart = \"\", addEnd = \"\" } = targetItem;\r\n            const addAtStartBlock = document.createElement(\"div\");\r\n            const addAtStartTitle = document.createElement(\"label\");\r\n            const addAtStartCheckbox = document.createElement(\"input\");\r\n            addAtStartBlock.className = \"PBE_rowBlock\";\r\n            addAtStartTitle.htmlFor = \"PBE_promptEdit_addAtStart\";\r\n            addAtStartTitle.textContent = \"Add at the beginning:\";\r\n            addAtStartCheckbox.type = \"checkbox\";\r\n            addAtStartCheckbox.id = \"PBE_promptEdit_addAtStart\";\r\n            addAtStartCheckbox.className = \"PBE_promptEdit_addAtStart\";\r\n            addAtStartCheckbox.name = \"PBE_promptEdit_addAtStart\";\r\n            addAtStartCheckbox.checked = addAtStart;\r\n            addAtStartBlock.appendChild(addAtStartTitle);\r\n            addAtStartBlock.appendChild(addAtStartCheckbox);\r\n            const sisterTagsAfter = document.createElement(\"div\");\r\n            const sisterTagsAfterTitle = document.createElement(\"label\");\r\n            const sisterTagsAfterInput = document.createElement(\"input\");\r\n            sisterTagsAfter.className = \"PBE_rowBlock\";\r\n            sisterTagsAfterTitle.textContent = \"Subsequent prompts:\";\r\n            sisterTagsAfterInput.className = \"PBE_generalInput PBE_promptEdit_addAfter\";\r\n            sisterTagsAfterInput.type = \"text\";\r\n            sisterTagsAfterInput.value = addAfter;\r\n            sisterTagsAfter.appendChild(sisterTagsAfterTitle);\r\n            sisterTagsAfter.appendChild(sisterTagsAfterInput);\r\n            const sisterTagsStart = document.createElement(\"div\");\r\n            const sisterTagsStartTitle = document.createElement(\"label\");\r\n            const sisterTagsStartInput = document.createElement(\"input\");\r\n            sisterTagsStart.className = \"PBE_rowBlock\";\r\n            sisterTagsStartTitle.textContent = \"Add prompts at the start:\";\r\n            sisterTagsStartInput.className = \"PBE_generalInput PBE_promptEdit_addStart\";\r\n            sisterTagsStartInput.type = \"text\";\r\n            sisterTagsStartInput.value = addStart;\r\n            sisterTagsStart.appendChild(sisterTagsStartTitle);\r\n            sisterTagsStart.appendChild(sisterTagsStartInput);\r\n            const sisterTagsEnd = document.createElement(\"div\");\r\n            const sisterTagsEndTitle = document.createElement(\"label\");\r\n            const sisterTagsEndInput = document.createElement(\"input\");\r\n            sisterTagsEnd.className = \"PBE_rowBlock\";\r\n            sisterTagsEndTitle.textContent = \"Add prompts at the end:\";\r\n            sisterTagsEndInput.className = \"PBE_generalInput PBE_promptEdit_addEnd\";\r\n            sisterTagsEndInput.type = \"text\";\r\n            sisterTagsEndInput.value = addEnd;\r\n            sisterTagsEnd.appendChild(sisterTagsEndTitle);\r\n            sisterTagsEnd.appendChild(sisterTagsEndInput);\r\n            wrapper.appendChild(addAtStartBlock);\r\n            wrapper.appendChild(sisterTagsAfter);\r\n            wrapper.appendChild(sisterTagsStart);\r\n            wrapper.appendChild(sisterTagsEnd);\r\n        }\r\n        static showAutoGenBlock(wrapper, prompt) {\r\n            if (!wrapper || !prompt)\r\n                return;\r\n            const { data } = index_2.default;\r\n            const { autogen = {} } = prompt;\r\n            const collection = autogen.collection || \"__none\";\r\n            const autoGenBlock = (0, dom_1.makeElement)({ element: \"div\", className: \"PBE_rowBlock\", content: \"Autogen:\" });\r\n            autoGenBlock.style.height = \"40px\";\r\n            const colOptions = [{ id: \"__none\", name: \"None\" }];\r\n            for (const colId in data.styles)\r\n                colOptions.push({ id: colId, name: colId });\r\n            const stylesCollectionsSelect = (0, dom_1.makeSelect)({\r\n                id: \"PBE_autoGentCollection\",\r\n                className: \"PBE_generalInput\",\r\n                value: collection,\r\n                options: colOptions,\r\n                onChange: (e) => event_1.default.onChangeAutogenCollection(e.currentTarget.value, prompt)\r\n            });\r\n            autoGenBlock.appendChild(stylesCollectionsSelect);\r\n            if (autogen.collection) {\r\n                const targetCollection = data.styles[autogen.collection];\r\n                if (targetCollection) {\r\n                    const styleOptions = [];\r\n                    for (const styleItem of targetCollection)\r\n                        styleOptions.push({ id: styleItem.name, name: styleItem.name });\r\n                    const styleSelect = (0, dom_1.makeSelect)({\r\n                        id: \"PBE_autoGentStyle\",\r\n                        className: \"PBE_generalInput\",\r\n                        value: autogen.style || \"\",\r\n                        options: styleOptions,\r\n                        onChange: (e) => event_1.default.onChangeAutogenStyle(e.currentTarget.value, prompt)\r\n                    });\r\n                    autoGenBlock.appendChild(styleSelect);\r\n                }\r\n            }\r\n            wrapper.appendChild(autoGenBlock);\r\n        }\r\n        static update(targetItem) {\r\n            const { data } = index_2.default;\r\n            const { state } = index_1.default;\r\n            const wrapper = index_1.default.DOMCache.promptEdit;\r\n            if (!wrapper || !state.editingPrompt)\r\n                return;\r\n            if (!targetItem)\r\n                targetItem = PromptEdit.getTargetItem() || undefined;\r\n            if (!targetItem)\r\n                return;\r\n            index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n            wrapper.innerHTML = \"\";\r\n            const headerBlock = (0, dom_1.makeElement)({ element: \"div\", className: \"PBE_rowBlock\" });\r\n            const headerTitle = (0, dom_1.makeElement)({ element: \"div\", className: \"PBE_promptEditTitle\", content: state.editingPrompt });\r\n            headerBlock.appendChild(headerTitle);\r\n            PromptEdit.addCollectionSelector(headerBlock);\r\n            wrapper.style.display = \"flex\";\r\n            wrapper.style.backgroundImage = index_2.default.getPromptPreviewURL(state.editingPrompt, state.editTargetCollection);\r\n            const currentTagsBlock = (0, dom_1.makeElement)({ element: \"div\", className: \"PBE_rowBlock\" });\r\n            const currentCategoriesBlock = (0, dom_1.makeElement)({ element: \"div\", className: \"PBE_rowBlock\" });\r\n            const addTagBlock = (0, dom_1.makeElement)({ element: \"div\", className: \"PBE_rowBlock\" });\r\n            const addCategoryBlock = (0, dom_1.makeElement)({ element: \"div\", className: \"PBE_rowBlock\" });\r\n            const footerBlock = (0, dom_1.makeElement)({ element: \"div\", className: \"PBE_rowBlock\" });\r\n            const tagsTitle = (0, dom_1.makeElement)({ element: \"div\", content: \"Tags:\" });\r\n            const tagsList = (0, dom_1.makeElement)({ element: \"div\", className: \"PBE_List PBE_Scrollbar PBE_tagsList\" });\r\n            const tagInput = (0, dom_1.makeElement)({ element: \"input\", id: \"PBE_addTagInput\", className: \"PBE_generalInput\" });\r\n            const addTagButton = (0, dom_1.makeElement)({ element: \"button\", content: \"Add tag\", className: \"PBE_button\" });\r\n            const categoriesTitle = (0, dom_1.makeElement)({ element: \"div\", content: \"Categories:\" });\r\n            const categoriesList = (0, dom_1.makeElement)({ element: \"div\", className: \"PBE_List PBE_Scrollbar PBE_categoryList\" });\r\n            const categorySelect = (0, dom_1.makeElement)({ element: \"select\", id: \"PBE_addCategorySelect\", className: \"PBE_generalInput\" });\r\n            const addCategoryButton = (0, dom_1.makeElement)({ element: \"button\", content: \"Add category\", className: \"PBE_button\" });\r\n            const commentArea = (0, dom_1.makeElement)({ element: \"textarea\", id: \"PBE_commentArea\", className: \"PBE_Textarea PBE_Scrollbar\" });\r\n            const cancelButton = (0, dom_1.makeElement)({ element: \"button\", content: \"Cancel\", className: \"PBE_button PBE_buttonCancel\" });\r\n            const saveButton = (0, dom_1.makeElement)({ element: \"button\", content: \"Save\", className: \"PBE_button\" });\r\n            commentArea.value = targetItem.comment || \"\";\r\n            for (const tagItem of targetItem.tags) {\r\n                const tagElement = document.createElement(\"div\");\r\n                tagElement.className = \"PBE_promptEditInfoItem\";\r\n                tagElement.innerText = tagItem;\r\n                tagElement.addEventListener(\"click\", (e) => {\r\n                    if (!e.metaKey && !e.ctrlKey)\r\n                        return;\r\n                    const target = e.currentTarget;\r\n                    const tagId = target.innerText;\r\n                    targetItem.tags = targetItem.tags.filter(item => item !== tagId);\r\n                    PromptEdit.update(targetItem);\r\n                });\r\n                tagsList.appendChild(tagElement);\r\n            }\r\n            for (const categoryItem of targetItem.category) {\r\n                const categoryElement = document.createElement(\"div\");\r\n                categoryElement.className = \"PBE_promptEditInfoItem\";\r\n                categoryElement.innerText = categoryItem;\r\n                categoryElement.addEventListener(\"click\", (e) => {\r\n                    if (!e.metaKey && !e.ctrlKey)\r\n                        return;\r\n                    const target = e.currentTarget;\r\n                    const categoryId = target.innerText;\r\n                    targetItem.category = targetItem.category.filter(item => item !== categoryId);\r\n                    PromptEdit.update(targetItem);\r\n                });\r\n                categoriesList.appendChild(categoryElement);\r\n            }\r\n            const categories = data.categories;\r\n            let options = \"\";\r\n            for (const categoryItem of categories) {\r\n                if (targetItem.category.includes(categoryItem))\r\n                    continue;\r\n                if (!categorySelect.value)\r\n                    categorySelect.value = categoryItem;\r\n                options += `<option value=\"${categoryItem}\">${categoryItem}</option>`;\r\n            }\r\n            categorySelect.innerHTML = options;\r\n            tagInput.addEventListener(\"keyup\", (e) => {\r\n                const target = e.currentTarget;\r\n                if (e.keyCode !== 13)\r\n                    return;\r\n                if (target.dataset.hint)\r\n                    return;\r\n                event_1.default.onAddTags(targetItem, tagInput);\r\n            });\r\n            addTagButton.addEventListener(\"click\", (e) => {\r\n                const inputElement = wrapper.querySelector(\"#PBE_addTagInput\");\r\n                if (!inputElement)\r\n                    return;\r\n                event_1.default.onAddTags(targetItem, inputElement);\r\n            });\r\n            addCategoryButton.addEventListener(\"click\", (e) => {\r\n                const selectElement = wrapper.querySelector(\"#PBE_addCategorySelect\");\r\n                if (!selectElement)\r\n                    return;\r\n                const value = selectElement.value;\r\n                if (targetItem.category.includes(value))\r\n                    return;\r\n                targetItem.category.push(value);\r\n                PromptEdit.update(targetItem);\r\n            });\r\n            commentArea.addEventListener(\"change\", (e) => targetItem.comment = e.currentTarget.value);\r\n            cancelButton.addEventListener(\"click\", event_1.default.onCloseWindow);\r\n            saveButton.addEventListener(\"click\", PromptEdit.saveEdit);\r\n            currentTagsBlock.appendChild(tagsTitle);\r\n            currentTagsBlock.appendChild(tagsList);\r\n            currentCategoriesBlock.appendChild(categoriesTitle);\r\n            currentCategoriesBlock.appendChild(categoriesList);\r\n            addTagBlock.appendChild(tagInput);\r\n            addTagBlock.appendChild(addTagButton);\r\n            addCategoryBlock.appendChild(categorySelect);\r\n            addCategoryBlock.appendChild(addCategoryButton);\r\n            footerBlock.appendChild(cancelButton);\r\n            footerBlock.appendChild(saveButton);\r\n            wrapper.appendChild(headerBlock);\r\n            if (Object.keys(data.original).length > 1) {\r\n                PromptEdit.addMoveBlock(wrapper);\r\n            }\r\n            wrapper.appendChild(currentTagsBlock);\r\n            wrapper.appendChild(currentCategoriesBlock);\r\n            wrapper.appendChild(addTagBlock);\r\n            wrapper.appendChild(addCategoryBlock);\r\n            //autogen block\r\n            PromptEdit.showAutoGenBlock(wrapper, targetItem);\r\n            PromptEdit.showAddSetup(wrapper);\r\n            wrapper.appendChild(commentArea);\r\n            wrapper.appendChild(footerBlock);\r\n            index_5.default.add(tagInput, true);\r\n        }\r\n    }\r\n    exports.default = PromptEdit;\r\n});\r\n","define([\"require\", \"exports\", \"./index\", \"client/index\", \"client/ActivePrompts/index\", \"client/Database/index\", \"client/KnownPrompts/index\", \"client/CurrentPrompts/index\"], function (require, exports, index_1, index_2, index_3, index_4, index_5, index_6) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class PromptScribeEvent {\r\n        static onCloseWindow() {\r\n            const { state } = index_2.default;\r\n            const wrapper = index_2.default.DOMCache.promptScribe;\r\n            if (!wrapper)\r\n                return;\r\n            state.showScriberWindow = undefined;\r\n            wrapper.style.display = \"none\";\r\n        }\r\n        static onAddUnknownPrompts() {\r\n            const { data } = index_4.default;\r\n            const { state } = index_2.default;\r\n            let { selectedNewPrompts = [] } = state;\r\n            const uniquePrompts = index_3.default.getUnique();\r\n            if (!state.savePreviewCollection)\r\n                return;\r\n            const targetCollection = data.original[state.savePreviewCollection];\r\n            if (!targetCollection)\r\n                return;\r\n            let newPrompts = false;\r\n            for (const prompt of uniquePrompts) {\r\n                if (!selectedNewPrompts.includes(prompt.id))\r\n                    continue;\r\n                const known = targetCollection.some(item => item.id === prompt.id);\r\n                if (!known) {\r\n                    if (!newPrompts)\r\n                        newPrompts = true;\r\n                    const targetItem = { id: prompt.id, tags: [], category: [] };\r\n                    if (prompt.isExternalNetwork)\r\n                        targetItem.isExternalNetwork = true;\r\n                    targetCollection.push(targetItem);\r\n                    //removing from the selected\r\n                    selectedNewPrompts = selectedNewPrompts.filter(item => item !== prompt.id);\r\n                }\r\n            }\r\n            if (!newPrompts)\r\n                return;\r\n            state.selectedNewPrompts = selectedNewPrompts;\r\n            index_4.default.saveJSONData(state.savePreviewCollection);\r\n            index_4.default.updateMixedList();\r\n            index_5.default.update();\r\n            index_6.default.update();\r\n            index_1.default.update();\r\n        }\r\n        static onToggleOnlyNew(e) {\r\n            const { state } = index_2.default;\r\n            const id = \"new_in_all_collections\";\r\n            if (state.toggledButtons.includes(id)) {\r\n                state.toggledButtons = state.toggledButtons.filter(item => item !== id);\r\n            }\r\n            else {\r\n                state.toggledButtons.push(id);\r\n            }\r\n            index_1.default.update();\r\n        }\r\n        static onToggleAll(e) {\r\n            const { state } = index_2.default;\r\n            let { selectedNewPrompts = [] } = state;\r\n            if (!selectedNewPrompts.length) {\r\n                index_1.default.update(true);\r\n                return;\r\n            }\r\n            state.selectedNewPrompts = [];\r\n            index_1.default.update();\r\n        }\r\n    }\r\n    exports.default = PromptScribeEvent;\r\n});\r\n","define([\"require\", \"exports\", \"client/index\", \"client/ActivePrompts/index\", \"client/Database/index\", \"client/synchroniseCurrentPrompts\", \"client/showPromptItem\", \"./event\"], function (require, exports, index_1, index_2, index_3, synchroniseCurrentPrompts_1, showPromptItem_1, event_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class PromptScribe {\r\n        static init(wrapper) {\r\n            const promptScribe = document.createElement(\"div\");\r\n            promptScribe.className = \"PBE_generalWindow PBE_promptScribe\";\r\n            promptScribe.id = \"PBE_promptScribe\";\r\n            index_1.default.DOMCache.promptScribe = promptScribe;\r\n            wrapper.appendChild(promptScribe);\r\n            index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n            promptScribe.addEventListener(\"click\", () => {\r\n                index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n            });\r\n        }\r\n        static initButton(positiveWrapper) {\r\n            const { readonly } = index_3.default.meta;\r\n            if (readonly)\r\n                return;\r\n            const addUnknownButton = document.createElement(\"button\");\r\n            addUnknownButton.className = \"PBE_actionButton PBE_addUnknownButton\";\r\n            addUnknownButton.innerText = \"Add Unknown\";\r\n            addUnknownButton.addEventListener(\"click\", PromptScribe.onOpenScriber);\r\n            positiveWrapper.appendChild(addUnknownButton);\r\n        }\r\n        static onOpenScriber() {\r\n            const { state } = index_1.default;\r\n            (0, synchroniseCurrentPrompts_1.default)();\r\n            state.showScriberWindow = true;\r\n            PromptScribe.update(true);\r\n        }\r\n        static showHeader(wrapper) {\r\n            const { data } = index_3.default;\r\n            const { state } = index_1.default;\r\n            const newPromptsHeader = document.createElement(\"div\");\r\n            newPromptsHeader.className = \"PBE_newPromptsHeader\";\r\n            const toggleOnlyNew = document.createElement(\"div\");\r\n            toggleOnlyNew.className = \"PBE_toggleButton\";\r\n            toggleOnlyNew.innerText = \"All collections\";\r\n            toggleOnlyNew.title = \"Toggle if only unknown in all collections should be shown or only in the current collection\";\r\n            if (state.toggledButtons.includes(\"new_in_all_collections\"))\r\n                toggleOnlyNew.classList.add(\"PBE_toggledButton\");\r\n            toggleOnlyNew.style.height = \"24px\";\r\n            toggleOnlyNew.addEventListener(\"click\", event_1.default.onToggleOnlyNew);\r\n            const saveButton = document.createElement(\"button\");\r\n            saveButton.innerText = \"Add new prompts\";\r\n            saveButton.className = \"PBE_button\";\r\n            saveButton.addEventListener(\"click\", event_1.default.onAddUnknownPrompts);\r\n            const toggleAll = document.createElement(\"button\");\r\n            toggleAll.innerText = \"Toggle all\";\r\n            toggleAll.className = \"PBE_button\";\r\n            toggleAll.style.marginRight = \"10px\";\r\n            toggleAll.addEventListener(\"click\", event_1.default.onToggleAll);\r\n            const collectionSelect = document.createElement(\"select\");\r\n            collectionSelect.className = \"PBE_generalInput PBE_select\";\r\n            collectionSelect.style.margin = \"0 10px\";\r\n            collectionSelect.style.height = \"30px\";\r\n            let options = \"\";\r\n            for (const collectionId in data.original) {\r\n                if (!state.savePreviewCollection)\r\n                    state.savePreviewCollection = collectionId;\r\n                options += `<option value=\"${collectionId}\">${collectionId}</option>`;\r\n            }\r\n            collectionSelect.innerHTML = options;\r\n            if (state.savePreviewCollection)\r\n                collectionSelect.value = state.savePreviewCollection;\r\n            collectionSelect.addEventListener(\"change\", (e) => {\r\n                const target = e.currentTarget;\r\n                const value = target.value;\r\n                state.savePreviewCollection = value || undefined;\r\n                PromptScribe.update();\r\n            });\r\n            newPromptsHeader.appendChild(toggleAll);\r\n            newPromptsHeader.appendChild(toggleOnlyNew);\r\n            newPromptsHeader.appendChild(collectionSelect);\r\n            newPromptsHeader.appendChild(saveButton);\r\n            wrapper.appendChild(newPromptsHeader);\r\n        }\r\n        static showUnknownPrompts(wrapper, initial = false) {\r\n            const { data } = index_3.default;\r\n            const { state } = index_1.default;\r\n            let { selectedNewPrompts = [], savePreviewCollection, toggledButtons = [] } = state;\r\n            const newInAllCollections = toggledButtons.includes(\"new_in_all_collections\");\r\n            //const activePrompts = ActivePrompts.getCurrentPrompts();\r\n            const uniquePrompts = index_2.default.getUnique();\r\n            let database = data.united;\r\n            if (!newInAllCollections && savePreviewCollection && data.original[state.savePreviewCollection]) {\r\n                database = data.original[state.savePreviewCollection];\r\n            }\r\n            if (initial)\r\n                selectedNewPrompts = [];\r\n            let unknownPromptsList = [];\r\n            for (const item of uniquePrompts) {\r\n                if (item.isSyntax)\r\n                    continue;\r\n                let isKnown = false;\r\n                for (const knownPrompt of database) {\r\n                    if (knownPrompt.id.toLowerCase() === item.id.toLowerCase()) {\r\n                        isKnown = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!isKnown) {\r\n                    unknownPromptsList.push(item);\r\n                    if (initial)\r\n                        selectedNewPrompts.push(item.id);\r\n                }\r\n            }\r\n            if (initial)\r\n                state.selectedNewPrompts = selectedNewPrompts;\r\n            const newPromptsContainer = document.createElement(\"div\");\r\n            newPromptsContainer.className = \"PBE_dataBlock PBE_Scrollbar PBE_windowContent\";\r\n            for (let item of unknownPromptsList) {\r\n                const promptElement = (0, showPromptItem_1.default)({ prompt: item, options: { noSplash: true } });\r\n                promptElement.classList.add(\"PBE_newElement\");\r\n                if (selectedNewPrompts.includes(item.id))\r\n                    promptElement.classList.add(\"PBE_selectedNewElement\");\r\n                newPromptsContainer.appendChild(promptElement);\r\n                promptElement.addEventListener(\"click\", (e) => {\r\n                    const target = e.currentTarget;\r\n                    const id = target.dataset.prompt;\r\n                    if (!id)\r\n                        return;\r\n                    if (selectedNewPrompts.includes(id)) {\r\n                        selectedNewPrompts = selectedNewPrompts.filter(item => item !== id);\r\n                        target.classList.remove(\"PBE_selectedNewElement\");\r\n                    }\r\n                    else {\r\n                        selectedNewPrompts.push(id);\r\n                        target.classList.add(\"PBE_selectedNewElement\");\r\n                    }\r\n                    index_1.default.state.selectedNewPrompts = selectedNewPrompts;\r\n                });\r\n            }\r\n            wrapper.appendChild(newPromptsContainer);\r\n        }\r\n        static update(initial) {\r\n            const { state } = index_1.default;\r\n            const wrapper = index_1.default.DOMCache.promptScribe;\r\n            if (!wrapper)\r\n                return;\r\n            index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n            wrapper.innerHTML = \"\";\r\n            wrapper.style.display = \"flex\";\r\n            const footerBlock = document.createElement(\"div\");\r\n            const closeButton = document.createElement(\"button\");\r\n            footerBlock.className = \"PBE_rowBlock PBE_rowBlock_wide\";\r\n            closeButton.innerText = \"Close\";\r\n            closeButton.className = \"PBE_button\";\r\n            closeButton.addEventListener(\"click\", (e) => {\r\n                state.showScriberWindow = undefined;\r\n                wrapper.style.display = \"none\";\r\n            });\r\n            PromptScribe.showHeader(wrapper);\r\n            PromptScribe.showUnknownPrompts(wrapper, initial);\r\n            footerBlock.appendChild(closeButton);\r\n            wrapper.appendChild(footerBlock);\r\n        }\r\n    }\r\n    exports.default = PromptScribe;\r\n});\r\n","define([\"require\", \"exports\", \"./index\", \"client/index\", \"client/ActivePrompts/index\", \"client/Database/index\", \"client/CurrentPrompts/index\", \"client/PromptEdit/index\", \"client/const\"], function (require, exports, index_1, index_2, index_3, index_4, index_5, index_6, const_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class PromptToolsEvent {\r\n        static onCloseWindow() {\r\n            const { state } = index_2.default;\r\n            const wrapper = index_2.default.DOMCache.promptTools;\r\n            if (!wrapper)\r\n                return;\r\n            state.promptTools = undefined;\r\n            wrapper.style.display = \"none\";\r\n        }\r\n        static onToggleButton(e) {\r\n            const target = e.currentTarget;\r\n            const { state } = index_2.default;\r\n            const id = target.dataset.id;\r\n            if (!id)\r\n                return;\r\n            if (state.toggledButtons.includes(id)) {\r\n                state.toggledButtons = state.toggledButtons.filter(item => item !== id);\r\n            }\r\n            else {\r\n                state.toggledButtons.push(id);\r\n            }\r\n            index_1.default.update();\r\n        }\r\n        static onChangeSelected(e) {\r\n            const target = e.currentTarget;\r\n            const { state } = index_2.default;\r\n            const { index, groupId } = state.promptTools;\r\n            if (index === undefined)\r\n                return;\r\n            const clickPrompt = target.dataset.prompt;\r\n            const newIndex = Number(target.dataset.index);\r\n            let newGroup = Number(target.dataset.group);\r\n            if (Number.isNaN(newGroup))\r\n                newGroup = false;\r\n            if (e.shiftKey && clickPrompt) {\r\n                state.editingPrompt = clickPrompt;\r\n                index_6.default.update();\r\n                return;\r\n            }\r\n            if (e.metaKey || e.ctrlKey) {\r\n                index_3.default.removePrompt(newIndex, newGroup);\r\n            }\r\n            else {\r\n                //same element\r\n                if (index === newIndex && groupId === newGroup)\r\n                    return;\r\n                state.promptTools.index = newIndex;\r\n                state.promptTools.groupId = newGroup;\r\n            }\r\n            index_1.default.update();\r\n            index_5.default.update();\r\n        }\r\n        static onSelectNew(e) {\r\n            const target = e.currentTarget;\r\n            const { data } = index_4.default;\r\n            const { united } = data;\r\n            const { state } = index_2.default;\r\n            const { index, groupId } = state.promptTools;\r\n            const clickPrompt = target.dataset.prompt;\r\n            const replaceMode = state.toggledButtons.includes(\"tools_replaceMode\");\r\n            if (index === undefined || !clickPrompt)\r\n                return;\r\n            const selectedPrompt = united.find(item => item.id === clickPrompt);\r\n            if (!selectedPrompt)\r\n                return;\r\n            if (e.shiftKey) {\r\n                state.editingPrompt = clickPrompt;\r\n                index_6.default.update();\r\n                return;\r\n            }\r\n            const newItem = {\r\n                id: clickPrompt,\r\n                weight: const_1.DEFAULT_PROMPT_WEIGHT,\r\n                isExternalNetwork: selectedPrompt.isExternalNetwork,\r\n            };\r\n            let action = \"add\";\r\n            if (replaceMode)\r\n                action = e.altKey ? \"add\" : \"replace\";\r\n            else\r\n                action = e.altKey ? \"replace\" : \"add\";\r\n            if (action === \"add\")\r\n                index_3.default.insertPrompt(newItem, index + 1, groupId);\r\n            else\r\n                index_3.default.replacePrompt(newItem, index, groupId);\r\n            index_1.default.update();\r\n            index_5.default.update();\r\n        }\r\n    }\r\n    exports.default = PromptToolsEvent;\r\n});\r\n","define([\"require\", \"exports\", \"client/index\", \"client/ActivePrompts/index\", \"client/Database/index\", \"client/dom\", \"client/showPromptItem\", \"client/utils/index\", \"client/PromptsFilter/simple\", \"client/CurrentPrompts/showPrompts\", \"client/utils/index\", \"./event\"], function (require, exports, index_1, index_2, index_3, dom_1, showPromptItem_1, index_4, simple_1, showPrompts_1, index_5, event_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class PromptTools {\r\n        static init(wrapper) {\r\n            const promptTools = document.createElement(\"div\");\r\n            promptTools.className = \"PBE_generalWindow PBE_promptTools\";\r\n            promptTools.id = \"PBE_promptTools\";\r\n            index_1.default.DOMCache.promptTools = promptTools;\r\n            wrapper.appendChild(promptTools);\r\n            index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n            promptTools.addEventListener(\"click\", () => {\r\n                index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n            });\r\n        }\r\n        static showCurrentPromptsList(wrapper) {\r\n            const { state } = index_1.default;\r\n            const { currentFilters } = PromptTools;\r\n            const activePrompts = (0, index_5.clone)(index_2.default.getCurrentPrompts());\r\n            if (state.promptTools.index === undefined)\r\n                return;\r\n            const currentPromptsContainer = (0, dom_1.makeDiv)({ className: \"PBE_windowCurrentList PBE_Scrollbar\" });\r\n            (0, showPrompts_1.default)({\r\n                prompts: activePrompts,\r\n                wrapper: currentPromptsContainer,\r\n                focusOn: { index: state.promptTools.index, groupId: state.promptTools.groupId },\r\n                filterSimple: currentFilters,\r\n                allowMove: false,\r\n                onClick: event_1.default.onChangeSelected,\r\n            });\r\n            currentPromptsContainer.addEventListener(\"wheel\", (e) => {\r\n                const target = e.currentTarget;\r\n                if (!e.deltaY)\r\n                    return;\r\n                target.scrollLeft += e.deltaY + e.deltaX;\r\n                e.preventDefault();\r\n            });\r\n            wrapper.appendChild(currentPromptsContainer);\r\n        }\r\n        static showCurrentPrompts(wrapper) {\r\n            const { state } = index_1.default;\r\n            if (state.promptTools.index === undefined)\r\n                return;\r\n            const setupContainer = (0, dom_1.makeDiv)({ className: \"PBE_List PBE_toolsSetup\" });\r\n            //setup fieldset\r\n            const setupField = (0, dom_1.makeElement)({ element: \"fieldset\", className: \"PBE_fieldset\" });\r\n            const setupLegend = (0, dom_1.makeElement)({ element: \"legend\", content: \"Setup\" });\r\n            const showAll = (0, dom_1.makeDiv)({ content: \"Show All\", className: \"PBE_toggleButton\" });\r\n            const replaceMode = (0, dom_1.makeDiv)({ content: \"Replace mode\", className: \"PBE_toggleButton\" });\r\n            showAll.dataset.id = \"tools_showAll\";\r\n            replaceMode.dataset.id = \"tools_replaceMode\";\r\n            if (state.toggledButtons.includes(\"tools_showAll\"))\r\n                showAll.classList.add(\"PBE_toggledButton\");\r\n            if (state.toggledButtons.includes(\"tools_replaceMode\"))\r\n                replaceMode.classList.add(\"PBE_toggledButton\");\r\n            showAll.addEventListener(\"click\", event_1.default.onToggleButton);\r\n            replaceMode.addEventListener(\"click\", event_1.default.onToggleButton);\r\n            setupField.appendChild(setupLegend);\r\n            setupField.appendChild(showAll);\r\n            setupField.appendChild(replaceMode);\r\n            //similarity fieldset\r\n            const simField = (0, dom_1.makeElement)({ element: \"fieldset\", className: \"PBE_fieldset\" });\r\n            const simLegend = (0, dom_1.makeElement)({ element: \"legend\", content: \"Similarity by:\" });\r\n            const showTags = (0, dom_1.makeDiv)({ content: \"Tags\", className: \"PBE_toggleButton\" });\r\n            const showCategory = (0, dom_1.makeDiv)({ content: \"Category\", className: \"PBE_toggleButton\" });\r\n            const showName = (0, dom_1.makeDiv)({ content: \"Name\", className: \"PBE_toggleButton\" });\r\n            simField.appendChild(simLegend);\r\n            simField.appendChild(showTags);\r\n            simField.appendChild(showCategory);\r\n            simField.appendChild(showName);\r\n            showTags.dataset.id = \"tools_tags\";\r\n            showCategory.dataset.id = \"tools_category\";\r\n            showName.dataset.id = \"tools_name\";\r\n            if (state.toggledButtons.includes(\"tools_tags\"))\r\n                showTags.classList.add(\"PBE_toggledButton\");\r\n            if (state.toggledButtons.includes(\"tools_category\"))\r\n                showCategory.classList.add(\"PBE_toggledButton\");\r\n            if (state.toggledButtons.includes(\"tools_name\"))\r\n                showName.classList.add(\"PBE_toggledButton\");\r\n            showTags.addEventListener(\"click\", event_1.default.onToggleButton);\r\n            showCategory.addEventListener(\"click\", event_1.default.onToggleButton);\r\n            showName.addEventListener(\"click\", event_1.default.onToggleButton);\r\n            setupContainer.appendChild(setupField);\r\n            setupContainer.appendChild(simField);\r\n            PromptTools.showCurrentPromptsList(wrapper);\r\n            wrapper.appendChild(setupContainer);\r\n        }\r\n        static showPossiblePromptswrapper(wrapper) {\r\n            const { data } = index_3.default;\r\n            const { united } = data;\r\n            const { state } = index_1.default;\r\n            const { maxCardsShown = 1000 } = state.config;\r\n            const { possibleFilters } = PromptTools;\r\n            const { sorting } = possibleFilters;\r\n            const { checkFilter } = simple_1.default;\r\n            const { index, groupId } = state.promptTools;\r\n            const activePrompts = index_2.default.getCurrentPrompts();\r\n            const uniquePrompts = index_2.default.getUniqueIds();\r\n            const showAll = state.toggledButtons.includes(\"tools_showAll\");\r\n            if (index === undefined)\r\n                return;\r\n            const targetPrompt = index_2.default.getPromptByIndex(index, groupId);\r\n            if (!targetPrompt || !targetPrompt.id)\r\n                return;\r\n            let targetTags = [];\r\n            let targetCategories = [];\r\n            let targetNameWords = (0, index_4.replaceAllRegex)(targetPrompt.id.toLowerCase(), \"_\", \" \").split(\" \");\r\n            let shownItems = 0;\r\n            const targetPromptSource = united.find(item => item.id === targetPrompt.id);\r\n            if (targetPromptSource) {\r\n                targetTags = targetPromptSource.tags || [];\r\n                targetCategories = targetPromptSource.category || [];\r\n            }\r\n            const nameArr = targetPrompt.id.split(\" \");\r\n            const possiblePrompts = [];\r\n            const addedIds = [];\r\n            for (const index in united) {\r\n                const item = united[index];\r\n                if (shownItems > maxCardsShown)\r\n                    break;\r\n                const { id, tags, category } = item;\r\n                if (!checkFilter(id, possibleFilters))\r\n                    continue;\r\n                //similarity index based on the same tags, categories and words used in the prompt name\r\n                let simIndex = 0;\r\n                if (id === targetPrompt.id)\r\n                    continue;\r\n                let nameWords = (0, index_4.replaceAllRegex)(id.toLowerCase(), \"_\", \" \").split(\" \");\r\n                if (state.toggledButtons.includes(\"tools_tags\"))\r\n                    targetTags.forEach(tagItem => { if (tags.includes(tagItem))\r\n                        simIndex++; });\r\n                if (state.toggledButtons.includes(\"tools_category\"))\r\n                    targetCategories.forEach(catItem => { if (category.includes(catItem))\r\n                        simIndex++; });\r\n                if (state.toggledButtons.includes(\"tools_name\"))\r\n                    targetNameWords.forEach(wordItem => { if (nameWords.includes(wordItem))\r\n                        simIndex++; });\r\n                if (showAll) {\r\n                    possiblePrompts.push(Object.assign(Object.assign({}, item), { simIndex }));\r\n                    shownItems++;\r\n                    continue;\r\n                }\r\n                if (state.toggledButtons.includes(\"tools_tags\") && targetTags.length) {\r\n                    targetTags.some(targetTag => {\r\n                        if (tags.includes(targetTag)) {\r\n                            possiblePrompts.push(Object.assign(Object.assign({}, item), { simIndex }));\r\n                            shownItems++;\r\n                            return true;\r\n                        }\r\n                    });\r\n                }\r\n                if (state.toggledButtons.includes(\"tools_category\") && targetCategories.length) {\r\n                    targetCategories.some(targetCategory => {\r\n                        if (category.includes(targetCategory)) {\r\n                            possiblePrompts.push(Object.assign(Object.assign({}, item), { simIndex }));\r\n                            shownItems++;\r\n                            return true;\r\n                        }\r\n                    });\r\n                }\r\n                if (state.toggledButtons.includes(\"tools_name\")) {\r\n                    const itemNameArr = id.split(\" \");\r\n                    wordLoop: for (const word of nameArr) {\r\n                        for (const itemWord of itemNameArr) {\r\n                            if (itemWord.toLowerCase().includes(word.toLowerCase())) {\r\n                                possiblePrompts.push(Object.assign(Object.assign({}, item), { simIndex }));\r\n                                shownItems++;\r\n                                break wordLoop;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            ;\r\n            switch (sorting) {\r\n                case \"__none\": break;\r\n                case \"alph\":\r\n                    //sorting possible prompts alphabetically\r\n                    possiblePrompts.sort((A, B) => {\r\n                        if (A.id.toLowerCase() < B.id.toLowerCase())\r\n                            return -1;\r\n                        if (A.id.toLowerCase() > B.id.toLowerCase())\r\n                            return 1;\r\n                        return 0;\r\n                    });\r\n                    break;\r\n                case \"alphReversed\":\r\n                    //sorting possible prompts alphabetically in reverse orderd\r\n                    possiblePrompts.sort((A, B) => {\r\n                        if (A.id.toLowerCase() < B.id.toLowerCase())\r\n                            return 1;\r\n                        if (A.id.toLowerCase() > B.id.toLowerCase())\r\n                            return -1;\r\n                        return 0;\r\n                    });\r\n                    break;\r\n                default:\r\n                case \"sim\":\r\n                    //sorting possible prompts based on their similarity to the selected prompt\r\n                    possiblePrompts.sort((A, B) => {\r\n                        if (A.simIndex < B.simIndex)\r\n                            return 1;\r\n                        if (A.simIndex > B.simIndex)\r\n                            return -1;\r\n                        if (A.id.toLowerCase() < B.id.toLowerCase())\r\n                            return -1;\r\n                        if (A.id.toLowerCase() > B.id.toLowerCase())\r\n                            return 1;\r\n                        return 0;\r\n                    });\r\n            }\r\n            function addElement(item) {\r\n                if (addedIds.includes(item.id))\r\n                    return;\r\n                const isShadowed = uniquePrompts.includes(item.id);\r\n                addedIds.push(item.id);\r\n                const promptElement = (0, showPromptItem_1.default)({ prompt: item, options: { isShadowed } });\r\n                promptElement.addEventListener(\"click\", event_1.default.onSelectNew);\r\n                wrapper.appendChild(promptElement);\r\n            }\r\n            for (const item of possiblePrompts)\r\n                addElement(item);\r\n        }\r\n        static update() {\r\n            const { state } = index_1.default;\r\n            const { index, groupId = false } = state.promptTools;\r\n            const wrapper = index_1.default.DOMCache.promptTools;\r\n            if (!wrapper || index === undefined)\r\n                return;\r\n            const targetPrompt = index_2.default.getPromptByIndex(index, groupId);\r\n            index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n            let currScrollState = 0;\r\n            let prevPromptContainer = wrapper.querySelector(\".PBE_windowCurrentList\");\r\n            if (prevPromptContainer) {\r\n                currScrollState = prevPromptContainer.scrollLeft;\r\n                prevPromptContainer = undefined;\r\n            }\r\n            wrapper.innerHTML = \"\";\r\n            wrapper.style.display = \"flex\";\r\n            const backImage = document.createElement(\"div\");\r\n            if (targetPrompt && targetPrompt.id)\r\n                backImage.style.backgroundImage = index_3.default.getPromptPreviewURL(targetPrompt.id);\r\n            backImage.className = \"PBE_toolsBackImage\";\r\n            const currentFilterBlock = document.createElement(\"div\");\r\n            const possibleFilterBlock = document.createElement(\"div\");\r\n            const currentPromptsBlock = document.createElement(\"div\");\r\n            const possiblePromptsBlock = document.createElement(\"div\");\r\n            const footerBlock = document.createElement(\"div\");\r\n            const closeButton = document.createElement(\"button\");\r\n            footerBlock.className = \"PBE_rowBlock PBE_rowBlock_wide PBE_toolsFooter\";\r\n            currentFilterBlock.className = \"PBE_dataBlock PBE_toolsFilter\";\r\n            possibleFilterBlock.className = \"PBE_dataBlock PBE_toolsFilter\";\r\n            currentPromptsBlock.className = \"PBE_dataBlock PBE_toolsHeader\";\r\n            possiblePromptsBlock.className = \"PBE_dataBlock PBE_Scrollbar PBE_windowContent\";\r\n            closeButton.innerText = \"Close\";\r\n            closeButton.className = \"PBE_button\";\r\n            simple_1.default.show(currentFilterBlock, PromptTools.currentFilters, PromptTools.update);\r\n            PromptTools.showCurrentPrompts(currentPromptsBlock);\r\n            simple_1.default.show(possibleFilterBlock, PromptTools.possibleFilters, PromptTools.update);\r\n            PromptTools.showPossiblePromptswrapper(possiblePromptsBlock);\r\n            closeButton.addEventListener(\"click\", event_1.default.onCloseWindow);\r\n            footerBlock.appendChild(closeButton);\r\n            wrapper.appendChild(backImage);\r\n            wrapper.appendChild(currentFilterBlock);\r\n            wrapper.appendChild(currentPromptsBlock);\r\n            wrapper.appendChild(possibleFilterBlock);\r\n            wrapper.appendChild(possiblePromptsBlock);\r\n            wrapper.appendChild(footerBlock);\r\n            let currentPromptsContainer = currentPromptsBlock.querySelector(\".PBE_windowCurrentList\");\r\n            if (currentPromptsContainer) {\r\n                currentPromptsContainer.scrollTo(currScrollState, 0);\r\n                currentPromptsContainer = undefined;\r\n            }\r\n        }\r\n    }\r\n    PromptTools.currentFilters = {\r\n        collection: \"\",\r\n        category: \"\",\r\n        tags: [],\r\n        name: \"\",\r\n        sorting: \"__none\",\r\n        sortingOptions: [\r\n            { id: \"__none\", name: \"Unsorted\" },\r\n            { id: \"weight\", name: \"By weight\" },\r\n            { id: \"alph\", name: \"Alphabetical\" },\r\n            { id: \"alphReversed\", name: \"Alphabetical reversed\" },\r\n        ]\r\n    };\r\n    PromptTools.possibleFilters = {\r\n        collection: \"\",\r\n        category: \"\",\r\n        tags: [],\r\n        name: \"\",\r\n        sorting: \"sim\",\r\n        sortingOptions: [\r\n            { id: \"__none\", name: \"Unsorted\" },\r\n            { id: \"sim\", name: \"By similarity\" },\r\n            { id: \"alph\", name: \"Alphabetical\" },\r\n            { id: \"alphReversed\", name: \"Alphabetical reversed\" },\r\n        ]\r\n    };\r\n    exports.default = PromptTools;\r\n});\r\n","define([\"require\", \"exports\", \"./index\", \"client/index\", \"client/ActivePrompts/index\", \"client/Database/index\", \"client/utils/index\", \"client/synchroniseCurrentPrompts\", \"client/applyStyle\"], function (require, exports, index_1, index_2, index_3, index_4, index_5, synchroniseCurrentPrompts_1, applyStyle_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class PromptWordTooltipEvent {\r\n        static filterNewPromptsOnly(str) {\r\n            if (!str)\r\n                return \"\";\r\n            const newStrPromptsArr = [];\r\n            const uniquePrompts = index_3.default.getUnique();\r\n            const newArr = str.split(\",\");\r\n            for (let prompt of newArr) {\r\n                const newPrompt = (0, index_5.promptStringToObject)({ prompt });\r\n                if (uniquePrompts.some(item => item.id === newPrompt.id))\r\n                    continue;\r\n                newStrPromptsArr.push(prompt);\r\n            }\r\n            return newStrPromptsArr.join(\", \");\r\n        }\r\n        static onKeyDown(e) {\r\n            const { autocomplitePromptMode = \"prompts\" } = index_2.default.state.config;\r\n            if (autocomplitePromptMode === \"off\")\r\n                return;\r\n            const { state } = index_2.default;\r\n            const autoCompleteBox = index_2.default.DOMCache.containers[state.currentContainer].autocompliteWindow;\r\n            if (!autoCompleteBox)\r\n                return;\r\n            if (autoCompleteBox.style.display === \"none\")\r\n                return;\r\n            if (e.keyCode != 38 && e.keyCode != 40 && e.keyCode != 13)\r\n                return;\r\n            const hintElements = autoCompleteBox.querySelectorAll(\".PBE_hintItem\");\r\n            if (!hintElements || !hintElements.length)\r\n                return;\r\n            e.stopPropagation();\r\n            e.preventDefault();\r\n            e.stopImmediatePropagation();\r\n        }\r\n        static onUnfocus(e) {\r\n            const { autocomplitePromptMode = \"prompts\" } = index_2.default.state.config;\r\n            if (autocomplitePromptMode === \"off\")\r\n                return;\r\n            const { state } = index_2.default;\r\n            const autoCompleteBox = index_2.default.DOMCache.containers[state.currentContainer].autocompliteWindow;\r\n            if (!autoCompleteBox)\r\n                return;\r\n            if (autoCompleteBox.style.display === \"none\")\r\n                return;\r\n            clearTimeout(index_1.default.unfocusTimeout);\r\n            index_1.default.unfocusTimeout = setTimeout(() => {\r\n                autoCompleteBox.style.display = \"none\";\r\n                autoCompleteBox.innerHTML = \"\";\r\n            }, 400);\r\n        }\r\n        static onHintWindowKey(e) {\r\n            const { state } = index_2.default;\r\n            const autoCompleteBox = index_2.default.DOMCache.containers[state.currentContainer].autocompliteWindow;\r\n            if (!autoCompleteBox)\r\n                return false;\r\n            if (autoCompleteBox.style.display === \"none\")\r\n                return false;\r\n            if (e.keyCode != 38 && e.keyCode != 40 && e.keyCode != 13)\r\n                return false;\r\n            const hintElements = autoCompleteBox.querySelectorAll(\".PBE_hintItem\");\r\n            if (!hintElements || !hintElements.length)\r\n                return false;\r\n            if (e.keyCode === 13) {\r\n                const selectedHint = autoCompleteBox.querySelector(\".PBE_hintItemSelected\");\r\n                if (!selectedHint)\r\n                    return false;\r\n                const start = Number(selectedHint.dataset.start);\r\n                const end = Number(selectedHint.dataset.end);\r\n                const newPrompt = selectedHint.innerText;\r\n                const collection = selectedHint.dataset.collection;\r\n                const style = selectedHint.dataset.style;\r\n                if (Number.isNaN(start) || Number.isNaN(end))\r\n                    return;\r\n                if (style)\r\n                    PromptWordTooltipEvent.onApplyStyleHint(start, end, style, collection);\r\n                else\r\n                    PromptWordTooltipEvent.onApplyHint(start, end, newPrompt);\r\n                return true;\r\n            }\r\n            const isDown = e.keyCode == 40;\r\n            if (isDown)\r\n                index_1.default.selectedIndex++;\r\n            else\r\n                index_1.default.selectedIndex--;\r\n            if (index_1.default.selectedIndex < 0)\r\n                index_1.default.selectedIndex = hintElements.length - 1;\r\n            else if (index_1.default.selectedIndex > hintElements.length - 1)\r\n                index_1.default.selectedIndex = 0;\r\n            for (let i = 0; i < hintElements.length; i++) {\r\n                const element = hintElements[i];\r\n                if (i === index_1.default.selectedIndex)\r\n                    element.classList.add(\"PBE_hintItemSelected\");\r\n                else\r\n                    element.classList.remove(\"PBE_hintItemSelected\");\r\n            }\r\n            return true;\r\n        }\r\n        static onClickHint(e) {\r\n            const { state } = index_2.default;\r\n            const autoCompleteBox = index_2.default.DOMCache.containers[state.currentContainer].autocompliteWindow;\r\n            const textArea = index_2.default.DOMCache.containers[state.currentContainer].textArea;\r\n            if (!textArea || !autoCompleteBox)\r\n                return;\r\n            const target = e.currentTarget;\r\n            if (!target)\r\n                return;\r\n            const start = Number(target.dataset.start);\r\n            const end = Number(target.dataset.end);\r\n            const collection = target.dataset.collection;\r\n            const style = target.dataset.style;\r\n            const newPrompt = target.innerText;\r\n            if (Number.isNaN(start) || Number.isNaN(end))\r\n                return;\r\n            if (style)\r\n                PromptWordTooltipEvent.onApplyStyleHint(start, end, style, collection);\r\n            else\r\n                PromptWordTooltipEvent.onApplyHint(start, end, newPrompt);\r\n        }\r\n        static onApplyStyleHint(start, end, style, collection) {\r\n            const { state } = index_2.default;\r\n            const { data } = index_4.default;\r\n            const autoCompleteBox = index_2.default.DOMCache.containers[state.currentContainer].autocompliteWindow;\r\n            const textArea = index_2.default.DOMCache.containers[state.currentContainer].textArea;\r\n            if (!textArea || !autoCompleteBox)\r\n                return;\r\n            if (!style || !collection)\r\n                return;\r\n            const targetCollection = data.styles[collection];\r\n            if (!targetCollection)\r\n                return;\r\n            const targetStyle = targetCollection.find(item => item.name === style);\r\n            if (!targetStyle)\r\n                return;\r\n            autoCompleteBox.style.display = \"none\";\r\n            let newValue = \"\";\r\n            const prefix = textArea.value.substring(0, start);\r\n            const postfix = textArea.value.substring(end);\r\n            newValue += prefix;\r\n            newValue += postfix;\r\n            textArea.value = newValue;\r\n            index_1.default.selectedIndex = 0;\r\n            (0, synchroniseCurrentPrompts_1.default)(false);\r\n            (0, applyStyle_1.default)(targetStyle, true, false);\r\n        }\r\n        static onApplyHint(start, end, newPrompt) {\r\n            const { filterNewPromptsOnly } = PromptWordTooltipEvent;\r\n            const { united } = index_4.default.data;\r\n            const { state } = index_2.default;\r\n            const autoCompleteBox = index_2.default.DOMCache.containers[state.currentContainer].autocompliteWindow;\r\n            const textArea = index_2.default.DOMCache.containers[state.currentContainer].textArea;\r\n            if (!textArea || !autoCompleteBox)\r\n                return;\r\n            const targetItem = united.find(item => item.id === newPrompt);\r\n            autoCompleteBox.style.display = \"none\";\r\n            let newValue = \"\";\r\n            const addAfter = targetItem && targetItem.addAfter ? filterNewPromptsOnly(targetItem.addAfter) : \"\";\r\n            const addStart = targetItem && targetItem.addStart ? filterNewPromptsOnly(targetItem.addStart) : \"\";\r\n            const addEnd = targetItem && targetItem.addEnd ? filterNewPromptsOnly(targetItem.addEnd) : \"\";\r\n            if (targetItem && targetItem.addAtStart) {\r\n                const oldValue = textArea.value.substring(0, start) + textArea.value.substring(end);\r\n                if (targetItem.isExternalNetwork)\r\n                    newPrompt = `<${newPrompt}>`;\r\n                if (addAfter)\r\n                    newPrompt += \", \" + addAfter + \", \";\r\n                newValue += newPrompt;\r\n                if (addStart)\r\n                    newValue += addStart + \", \";\r\n                newValue += oldValue;\r\n                if (addEnd)\r\n                    newValue += addEnd;\r\n            }\r\n            else {\r\n                const prefix = textArea.value.substring(0, start);\r\n                const postfix = textArea.value.substring(end);\r\n                if (addStart)\r\n                    newValue += addStart + \", \";\r\n                if (prefix)\r\n                    newValue += prefix + \" \";\r\n                if (targetItem) {\r\n                    if (targetItem.isExternalNetwork)\r\n                        newPrompt = `<${newPrompt}>`;\r\n                    if (addAfter)\r\n                        newPrompt += \", \" + addAfter;\r\n                    newValue += newPrompt;\r\n                }\r\n                else\r\n                    newValue += newPrompt;\r\n                if (postfix)\r\n                    newValue += postfix;\r\n                else\r\n                    newValue += \", \";\r\n                if (addEnd)\r\n                    newValue += addEnd;\r\n            }\r\n            textArea.value = newValue;\r\n            index_1.default.selectedIndex = 0;\r\n            (0, synchroniseCurrentPrompts_1.default)(false);\r\n        }\r\n    }\r\n    exports.default = PromptWordTooltipEvent;\r\n});\r\n","define([\"require\", \"exports\", \"client/index\", \"client/Database/index\", \"./event\"], function (require, exports, index_1, index_2, event_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    /**\r\n     * Prompt autocomplite tooltip window\r\n     */\r\n    class PromptWordTooltip {\r\n        static init(positivePrompts, containerId) {\r\n            if (!positivePrompts)\r\n                return;\r\n            const textArea = positivePrompts.querySelector(\"textarea\");\r\n            if (!textArea)\r\n                return;\r\n            const autocompliteWindow = document.createElement(\"div\");\r\n            autocompliteWindow.className = \"PBE_autocompliteBox\";\r\n            positivePrompts.style.position = \"relative\";\r\n            positivePrompts.appendChild(autocompliteWindow);\r\n            index_1.default.DOMCache.containers[containerId].autocompliteWindow = autocompliteWindow;\r\n            textArea.addEventListener(\"keydown\", event_1.default.onKeyDown);\r\n            textArea.addEventListener(\"blur\", event_1.default.onUnfocus);\r\n            textArea.addEventListener(\"keyup\", PromptWordTooltip.processCarretPosition);\r\n            textArea.addEventListener(\"click\", PromptWordTooltip.processCarretPosition);\r\n        }\r\n        static getPossiblePrompts(word) {\r\n            const promptsList = index_2.default.data.united;\r\n            const possiblePrompts = [];\r\n            for (const prompt of promptsList) {\r\n                if (!prompt.id)\r\n                    continue;\r\n                if (prompt.id.toLowerCase().includes(word))\r\n                    possiblePrompts.push(prompt.id);\r\n            }\r\n            possiblePrompts.sort();\r\n            return possiblePrompts;\r\n        }\r\n        static getPossibleStyles(word) {\r\n            const MAX_STYLES = 5;\r\n            const IGNORED_COLLECTIONS = [\"autogen\"];\r\n            const { styles } = index_2.default.data;\r\n            const possibleStyles = [];\r\n            let addedStyles = 0;\r\n            topLoop: for (const collectionId in styles) {\r\n                if (IGNORED_COLLECTIONS.includes(collectionId))\r\n                    continue;\r\n                for (let i = 0; i < styles[collectionId].length; i++) {\r\n                    const styleItem = styles[collectionId][i];\r\n                    if (!styleItem.name)\r\n                        continue;\r\n                    if (styleItem.name.toLowerCase().includes(word)) {\r\n                        possibleStyles.push({ collection: collectionId, name: styleItem.name });\r\n                        addedStyles++;\r\n                    }\r\n                    if (addedStyles > MAX_STYLES)\r\n                        break topLoop;\r\n                }\r\n            }\r\n            possibleStyles.sort((A, B) => {\r\n                if (A.name > B.name)\r\n                    return 1;\r\n                if (A.name < B.name)\r\n                    return -1;\r\n                return 0;\r\n            });\r\n            return possibleStyles;\r\n        }\r\n        static processCarretPosition(e) {\r\n            const target = e.currentTarget;\r\n            const { autocomplitePromptMode = \"prompts\" } = index_1.default.state.config;\r\n            if (autocomplitePromptMode === \"off\")\r\n                return;\r\n            const doc = index_1.default.gradioApp();\r\n            const activeElement = doc.activeElement || document.activeElement;\r\n            const textArea = target;\r\n            const isFocused = activeElement === textArea;\r\n            if (!isFocused)\r\n                return;\r\n            clearTimeout(PromptWordTooltip.unfocusTimeout);\r\n            if (e.keyCode === 38 || e.keyCode === 40 || e.keyCode === 13) {\r\n                const block = event_1.default.onHintWindowKey(e);\r\n                if (block) {\r\n                    e.stopPropagation();\r\n                    e.preventDefault();\r\n                    e.stopImmediatePropagation();\r\n                    return false;\r\n                }\r\n            }\r\n            const { selectedIndex = 0 } = PromptWordTooltip;\r\n            const { state } = index_1.default;\r\n            if (!index_2.default.data || !index_2.default.data.united)\r\n                return;\r\n            const autoCompleteBox = index_1.default.DOMCache.containers[state.currentContainer].autocompliteWindow;\r\n            if (!autoCompleteBox)\r\n                return;\r\n            autoCompleteBox.innerHTML = \"\";\r\n            const MAX_HINTS = 20;\r\n            let currHints = 0;\r\n            const value = textArea.value;\r\n            const caret = textArea.selectionStart;\r\n            const stopSymbols = [\",\", \"(\", \")\", \"<\", \">\", \":\", \"|\", \"{\", \"}\"];\r\n            const textAreaPosition = textArea.getBoundingClientRect();\r\n            let position = caret;\r\n            let word = \"\";\r\n            let wordStart = caret;\r\n            let wordEnd = caret;\r\n            while (value[position]) {\r\n                if (value[position] && stopSymbols.includes(value[position]))\r\n                    break;\r\n                word += value[position];\r\n                position++;\r\n                wordEnd = position;\r\n            }\r\n            position = caret - 1;\r\n            while (value[position]) {\r\n                if (value[position] && stopSymbols.includes(value[position]))\r\n                    break;\r\n                word = value[position] + word;\r\n                wordStart = position;\r\n                position--;\r\n            }\r\n            word = word.trim();\r\n            if (!word)\r\n                return;\r\n            word = word.toLowerCase();\r\n            const showPrompts = autocomplitePromptMode === \"prompts\" || autocomplitePromptMode === \"all\";\r\n            const showStyles = autocomplitePromptMode === \"styles\" || autocomplitePromptMode === \"all\";\r\n            const possiblePrompts = showPrompts ? PromptWordTooltip.getPossiblePrompts(word) : [];\r\n            const possibleStyles = showStyles ? PromptWordTooltip.getPossibleStyles(word) : [];\r\n            let haveAnyHints = false;\r\n            if (possiblePrompts.length > 1 || (possiblePrompts.length === 1 && word !== possiblePrompts[0]))\r\n                haveAnyHints = true;\r\n            if (possibleStyles.length)\r\n                haveAnyHints = true;\r\n            if (!haveAnyHints) {\r\n                autoCompleteBox.style.display = \"none\";\r\n                return;\r\n            }\r\n            else\r\n                autoCompleteBox.style.display = \"\";\r\n            if (showPrompts)\r\n                for (const item of possiblePrompts) {\r\n                    if (currHints >= MAX_HINTS)\r\n                        break;\r\n                    const hintItem = document.createElement(\"div\");\r\n                    hintItem.className = \"PBE_hintItem\";\r\n                    hintItem.innerText = item;\r\n                    hintItem.dataset.start = wordStart + \"\";\r\n                    hintItem.dataset.end = wordEnd + \"\";\r\n                    if (currHints === selectedIndex)\r\n                        hintItem.classList.add(\"PBE_hintItemSelected\");\r\n                    hintItem.addEventListener(\"click\", event_1.default.onClickHint);\r\n                    autoCompleteBox.appendChild(hintItem);\r\n                    currHints++;\r\n                }\r\n            if (showStyles)\r\n                for (const item of possibleStyles) {\r\n                    if (currHints >= MAX_HINTS)\r\n                        break;\r\n                    const hintItem = document.createElement(\"div\");\r\n                    hintItem.className = \"PBE_hintItem\";\r\n                    hintItem.innerText = \"Style: \" + item.name;\r\n                    hintItem.dataset.collection = item.collection;\r\n                    hintItem.dataset.style = item.name;\r\n                    hintItem.dataset.start = wordStart + \"\";\r\n                    hintItem.dataset.end = wordEnd + \"\";\r\n                    if (currHints === selectedIndex)\r\n                        hintItem.classList.add(\"PBE_hintItemSelected\");\r\n                    hintItem.addEventListener(\"click\", event_1.default.onClickHint);\r\n                    autoCompleteBox.appendChild(hintItem);\r\n                    currHints++;\r\n                }\r\n            const caretePos = getCaretCoordinates(textArea, caret);\r\n            if (caretePos) {\r\n                autoCompleteBox.style.bottom = textAreaPosition.height + \"px\";\r\n                autoCompleteBox.style.left = caretePos.left + 10 + \"px\";\r\n            }\r\n        }\r\n    }\r\n    PromptWordTooltip.selectedIndex = 0;\r\n    PromptWordTooltip.unfocusTimeout = 0;\r\n    exports.default = PromptWordTooltip;\r\n});\r\n","define([\"require\", \"exports\", \"client/index\", \"client/Database/index\", \"client/CollectionTools/index\", \"client/TagTooltip/index\"], function (require, exports, index_1, index_2, index_3, index_4) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class PromptsFilter {\r\n        static onAddNewFilter(e) {\r\n            const { promptsFilter } = index_1.default.state;\r\n            const target = e.currentTarget;\r\n            if (!target || !target.dataset.id)\r\n                return;\r\n            const parent = target.parentElement;\r\n            if (!parent)\r\n                return;\r\n            if (target.innerText === \"+\") {\r\n                const cancelButton = parent.querySelector(\".PBE_filtersRemoveNew\");\r\n                const newFilterContainer = parent.querySelector(\".PBE_newFilterContainer\");\r\n                if (!cancelButton || !newFilterContainer)\r\n                    return;\r\n                target.innerText = \"✓\";\r\n                cancelButton.style.display = \"flex\";\r\n                newFilterContainer.style.display = \"flex\";\r\n                return;\r\n            }\r\n            const filterTypeSelector = target.parentElement.querySelector(\".PBE_filterType\");\r\n            const filterActionElement = target.parentElement.querySelector(\".PBE_filterAction\");\r\n            if (!filterTypeSelector || !filterTypeSelector.value)\r\n                return;\r\n            if (!filterActionElement || !filterActionElement.dataset.action)\r\n                return;\r\n            const id = target.dataset.id;\r\n            const action = filterActionElement.dataset.action;\r\n            const type = filterTypeSelector.value;\r\n            let value = \"\";\r\n            if (type === \"meta\") {\r\n                const metaSelector = target.parentElement.querySelector(\".PBE_filterMeta\");\r\n                if (!metaSelector || !metaSelector.value)\r\n                    return;\r\n                value = metaSelector.value;\r\n            }\r\n            else if (type === \"category\") {\r\n                const categorySelector = target.parentElement.querySelector(\".PBE_filterCategory\");\r\n                if (!categorySelector || !categorySelector.value)\r\n                    return;\r\n                value = categorySelector.value;\r\n            }\r\n            else {\r\n                const nameInput = target.parentElement.querySelector(\".PBE_filterName\");\r\n                if (!nameInput || !nameInput.value)\r\n                    return;\r\n                value = nameInput.value;\r\n            }\r\n            if (!promptsFilter[id])\r\n                promptsFilter[id] = [];\r\n            promptsFilter[id].push({ action, type: type, value });\r\n            index_3.default.update();\r\n        }\r\n        static onHideNewFilter(e) {\r\n            const target = e.currentTarget;\r\n            if (!target)\r\n                return;\r\n            const parent = target.parentElement;\r\n            if (!parent)\r\n                return;\r\n            const addButton = parent.querySelector(\".PBE_filtersAddNewButton\");\r\n            const newFilterContainer = parent.querySelector(\".PBE_newFilterContainer\");\r\n            if (!addButton || !newFilterContainer)\r\n                return;\r\n            addButton.innerText = \"+\";\r\n            target.style.display = \"none\";\r\n            newFilterContainer.style.display = \"none\";\r\n        }\r\n        static onRemoveFilter(e) {\r\n            const { promptsFilter } = index_1.default.state;\r\n            const target = e.currentTarget;\r\n            const id = target.dataset.id;\r\n            const index = Number(target.dataset.index);\r\n            if (!id || Number.isNaN(index))\r\n                return;\r\n            if (!promptsFilter[id])\r\n                return;\r\n            promptsFilter[id].splice(index, 1);\r\n            index_3.default.update();\r\n        }\r\n        static showActiveFilters(wrapper, filterId) {\r\n            const { promptsFilter = {} } = index_1.default.state;\r\n            const filterSetup = promptsFilter[filterId];\r\n            if (!filterSetup)\r\n                return;\r\n            for (let i = 0; i < filterSetup.length; i++) {\r\n                const filterItem = filterSetup[i];\r\n                const { action, type, value } = filterItem;\r\n                const isInclude = action === \"include\";\r\n                const filterElement = document.createElement(\"div\");\r\n                filterElement.className = \"PBE_filterItem\";\r\n                if (!isInclude)\r\n                    filterElement.className += \" PBE_filterItemNegative\";\r\n                filterElement.innerText = action === \"include\" ? \"+\" : \"-\";\r\n                filterElement.innerText += `${type}: ${value}`;\r\n                const removeButton = document.createElement(\"div\");\r\n                removeButton.className = \"PBE_filterItemRemove PBE_buttonCancel\";\r\n                removeButton.innerText = \"✕\";\r\n                removeButton.dataset.id = filterId;\r\n                removeButton.dataset.index = i + \"\";\r\n                removeButton.addEventListener(\"click\", PromptsFilter.onRemoveFilter);\r\n                filterElement.appendChild(removeButton);\r\n                wrapper.appendChild(filterElement);\r\n            }\r\n        }\r\n        static update(wrapper, filterId) {\r\n            if (!wrapper || !filterId)\r\n                return;\r\n            const { promptsFilter } = index_1.default.state;\r\n            wrapper.innerHTML = \"\";\r\n            const filtersContainer = document.createElement(\"div\");\r\n            filtersContainer.className = \"PBE_filtersWrapper\";\r\n            const addFilterButton = document.createElement(\"div\");\r\n            addFilterButton.className = \"PBE_filtersAddNew PBE_filtersAddNewButton\";\r\n            addFilterButton.dataset.id = filterId;\r\n            addFilterButton.innerText = \"✓\";\r\n            const cancelButton = document.createElement(\"div\");\r\n            cancelButton.className = \"PBE_filtersAddNew PBE_filtersRemoveNew .PBE_buttonCancel\";\r\n            cancelButton.innerText = \"✕\";\r\n            const newFilterContainer = document.createElement(\"div\");\r\n            newFilterContainer.className = \"PBE_row PBE_newFilterContainer\";\r\n            const activeFilters = document.createElement(\"div\");\r\n            activeFilters.className = \"PBE_row\";\r\n            activeFilters.style.flexWrap = \"wrap\";\r\n            const actionButton = document.createElement(\"div\");\r\n            actionButton.className = \"PBE_filterAction\";\r\n            actionButton.innerText = \"Include\";\r\n            actionButton.dataset.action = \"include\";\r\n            const typeSelect = document.createElement(\"select\");\r\n            typeSelect.className = \"PBE_generalInput PBE_select PBE_filterType\";\r\n            typeSelect.style.margin = \"0 5px\";\r\n            typeSelect.innerHTML = `\r\n            <option value=\"name\">Name</option>\r\n            <option value=\"tag\">Tag</option>\r\n            <option value=\"category\">Category</option>\r\n            <option value=\"meta\">Meta</option>\r\n        `;\r\n            const addionalSetup = document.createElement(\"div\");\r\n            actionButton.addEventListener(\"click\", (e) => {\r\n                const target = e.currentTarget;\r\n                const action = target.dataset.action;\r\n                if (action === \"include\") {\r\n                    target.dataset.action = \"exclude\";\r\n                    target.innerText = \"Exclude\";\r\n                }\r\n                else {\r\n                    target.dataset.action = \"include\";\r\n                    target.innerText = \"Include\";\r\n                }\r\n            });\r\n            typeSelect.addEventListener(\"change\", (e) => {\r\n                const target = e.currentTarget;\r\n                const value = target.value;\r\n                PromptsFilter.updateAdditionalSetup(addionalSetup, value, addFilterButton);\r\n            });\r\n            addFilterButton.addEventListener(\"click\", PromptsFilter.onAddNewFilter);\r\n            cancelButton.addEventListener(\"click\", PromptsFilter.onHideNewFilter);\r\n            PromptsFilter.showActiveFilters(activeFilters, filterId);\r\n            PromptsFilter.updateAdditionalSetup(addionalSetup, \"name\", addFilterButton);\r\n            newFilterContainer.appendChild(actionButton);\r\n            newFilterContainer.appendChild(typeSelect);\r\n            newFilterContainer.appendChild(addionalSetup);\r\n            filtersContainer.appendChild(activeFilters);\r\n            filtersContainer.appendChild(newFilterContainer);\r\n            filtersContainer.appendChild(addFilterButton);\r\n            filtersContainer.appendChild(cancelButton);\r\n            wrapper.appendChild(filtersContainer);\r\n        }\r\n        static updateAdditionalSetup(wrapper, type, addFilterButton) {\r\n            wrapper.innerHTML = \"\";\r\n            if (type === \"meta\") {\r\n                const metaSelect = document.createElement(\"select\");\r\n                metaSelect.className = \"PBE_generalInput PBE_select PBE_filterMeta\";\r\n                metaSelect.innerHTML = `\r\n                <option value=\"preview\">Have preview image</option>\r\n                <option value=\"categories\">Have categories</option>\r\n                <option value=\"categories3\">Have at least 3 categories</option>\r\n                <option value=\"tags\">Have tags</option>\r\n                <option value=\"tags3\">Have at least 3 tags</option>\r\n                <option value=\"comment\">Have comment</option>\r\n                <option value=\"comment\">comment</option>\r\n                <option value=\"autogen\">Have autogen style</option>\r\n                <option value=\"png\">Is PNG</option>\r\n                <option value=\"jpg\">Is JPG</option>\r\n            `;\r\n                wrapper.appendChild(metaSelect);\r\n                return;\r\n            }\r\n            if (type === \"category\") {\r\n                const { data } = index_2.default;\r\n                const categories = data.categories;\r\n                const categorySelector = document.createElement(\"select\");\r\n                categorySelector.className = \"PBE_generalInput PBE_select PBE_filterCategory\";\r\n                let options = `\r\n                <option value=\"\">All</option>\r\n                <option value=\"__none\">Uncategorised</option>\r\n            `;\r\n                for (const categoryItem of categories) {\r\n                    options += `<option value=\"${categoryItem}\">${categoryItem}</option>`;\r\n                }\r\n                categorySelector.innerHTML = options;\r\n                wrapper.appendChild(categorySelector);\r\n                return;\r\n            }\r\n            if (type === \"tag\" || type === \"name\") {\r\n                const inputElement = document.createElement(\"input\");\r\n                inputElement.className = \"PBE_generalInput PBE_input PBE_filterName\";\r\n                if (type === \"tag\")\r\n                    index_4.default.add(inputElement, true);\r\n                inputElement.addEventListener(\"keydown\", (e) => {\r\n                    if (e.keyCode !== 13)\r\n                        return;\r\n                    addFilterButton.dispatchEvent(new Event('click'));\r\n                });\r\n                wrapper.appendChild(inputElement);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    exports.default = PromptsFilter;\r\n});\r\n","define([\"require\", \"exports\", \"client/Database/index\", \"client/dom\", \"client/TagTooltip/index\"], function (require, exports, index_1, dom_1, index_2) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class PromptsSimpleFilter {\r\n        /**\r\n         * Returns true if prompt passes filters params\r\n         * @param {*} promptId\r\n         * @param {*} filters\r\n         * @returns\r\n         */\r\n        static checkFilter(promptId, filters = {}) {\r\n            if (!promptId)\r\n                return false;\r\n            const { data } = index_1.default;\r\n            const { unitedList } = data;\r\n            let onlyName = false;\r\n            const { collection = \"\", category = \"\", tags = [], name = \"\" } = filters;\r\n            if (!collection && !category && !name && !tags.length)\r\n                return true;\r\n            if (!collection && !category && !tags.length && name)\r\n                onlyName = true;\r\n            //checkinig name first in order to be able to filter new prompts name not yet in collections.\r\n            //cheking name\r\n            if (name && !promptId.toLowerCase().includes(name))\r\n                return false;\r\n            if (onlyName)\r\n                return true;\r\n            const unitedPrompt = unitedList[promptId];\r\n            //prompt data not found\r\n            if (!unitedPrompt)\r\n                return false;\r\n            //checking collections\r\n            if (collection && !unitedPrompt.collections.includes(collection))\r\n                return false;\r\n            //checking categories\r\n            if (category) {\r\n                if (category === \"__none\" && unitedPrompt.category.length)\r\n                    return false;\r\n                else if (category !== \"__none\" && !unitedPrompt.category.includes(category))\r\n                    return false;\r\n            }\r\n            //checking tags\r\n            if (tags.length) {\r\n                for (const tagItem of tags) {\r\n                    if (!unitedPrompt.tags.includes(tagItem))\r\n                        return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        /**\r\n         * Showing filters block\r\n         * @param {*} wrapper\r\n         * @param {*} filters\r\n         * @param {*} callback\r\n         * @returns\r\n         */\r\n        static show(wrapper, filters = {}, callback) {\r\n            if (!wrapper || !callback)\r\n                return;\r\n            const { data } = index_1.default;\r\n            const { categories } = data;\r\n            const { collection = \"\", category = \"\", tags = [], name = \"\", sorting = \"\", sortingOptions } = filters;\r\n            const filtersContainer = (0, dom_1.makeDiv)({ className: \"PBE_filtersContainer\" });\r\n            //collections filter\r\n            const colOptions = [{ id: \"\", name: \"All collections\" }];\r\n            for (const collectionId in data.original)\r\n                colOptions.push({ id: collectionId, name: collectionId });\r\n            const collectionSelector = (0, dom_1.makeSelect)({\r\n                className: \"PBE_generalInput PBE_select\",\r\n                value: collection,\r\n                options: colOptions,\r\n                onChange: e => {\r\n                    filters.collection = e.currentTarget.value;\r\n                    callback();\r\n                }\r\n            });\r\n            //categories filter\r\n            const catOptions = [\r\n                { id: \"\", name: \"All categories\" },\r\n                { id: \"__none\", name: \"Uncategorised\" },\r\n            ];\r\n            for (const categoryId of categories)\r\n                catOptions.push({ id: categoryId, name: categoryId });\r\n            const categorySelector = (0, dom_1.makeSelect)({\r\n                className: \"PBE_generalInput PBE_select\",\r\n                value: category,\r\n                options: catOptions,\r\n                onChange: e => {\r\n                    filters.category = e.currentTarget.value;\r\n                    callback();\r\n                }\r\n            });\r\n            //tags filter\r\n            const tagsInput = (0, dom_1.makeElement)({\r\n                element: \"input\",\r\n                className: \"PBE_generalInput PBE_input\",\r\n                value: tags.join(\", \"),\r\n                placeholder: \"tag1, tag2, tag3\",\r\n                onChange: e => {\r\n                    const value = e.currentTarget.value;\r\n                    let tags = value.split(\",\").map(item => item.trim());\r\n                    //removing empty tags\r\n                    tags = tags.filter(item => item);\r\n                    filters.tags = tags || [];\r\n                    callback();\r\n                }\r\n            });\r\n            index_2.default.add(tagsInput);\r\n            //name filter\r\n            const nameInput = (0, dom_1.makeElement)({\r\n                element: \"input\",\r\n                className: \"PBE_generalInput PBE_input\",\r\n                value: name,\r\n                placeholder: \"by name\",\r\n                onChange: e => {\r\n                    filters.name = e.currentTarget.value.toLowerCase();\r\n                    callback();\r\n                }\r\n            });\r\n            filtersContainer.appendChild(collectionSelector);\r\n            filtersContainer.appendChild(categorySelector);\r\n            filtersContainer.appendChild(tagsInput);\r\n            filtersContainer.appendChild(nameInput);\r\n            //sorting selector\r\n            if (sortingOptions) {\r\n                const sortingSelector = (0, dom_1.makeSelect)({\r\n                    className: \"PBE_generalInput PBE_select\",\r\n                    value: sorting,\r\n                    options: sortingOptions,\r\n                    onChange: e => {\r\n                        filters.sorting = e.currentTarget.value;\r\n                        callback();\r\n                    }\r\n                });\r\n                filtersContainer.appendChild(sortingSelector);\r\n            }\r\n            wrapper.appendChild(filtersContainer);\r\n        }\r\n    }\r\n    exports.default = PromptsSimpleFilter;\r\n});\r\n","define([\"require\", \"exports\", \"./index\", \"client/index\", \"client/ActivePrompts/index\", \"client/CurrentPrompts/index\", \"client/Database/index\", \"client/LoadStyle/index\"], function (require, exports, index_1, index_2, index_3, index_4, index_5, index_6) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class SaveStyleEvent {\r\n        static onOpenStyles() {\r\n            const { state } = index_2.default;\r\n            state.showSaveStyleWindow = true;\r\n            index_1.default.update();\r\n        }\r\n        static onCloseWindow() {\r\n            const { state } = index_2.default;\r\n            const wrapper = index_2.default.DOMCache.saveStyleWindow;\r\n            if (!wrapper || !state.showSaveStyleWindow)\r\n                return;\r\n            state.showSaveStyleWindow = undefined;\r\n            wrapper.style.display = \"none\";\r\n        }\r\n        static onSaveStyle() {\r\n            const { data } = index_5.default;\r\n            const { state } = index_2.default;\r\n            const collectionId = state.newStyleCollection;\r\n            if (!collectionId)\r\n                return;\r\n            const targetCollection = data.styles[collectionId];\r\n            if (!targetCollection)\r\n                return;\r\n            const styleNameInput = index_2.default.DOMCache.saveStyleWindow.querySelector(\"#PBE_newStyleName\");\r\n            const name = styleNameInput.value;\r\n            if (!name || !data.styles)\r\n                return;\r\n            const newStyle = index_6.default.grabCurrentStyle(name, collectionId);\r\n            if (!newStyle)\r\n                return;\r\n            targetCollection.push(newStyle);\r\n            index_5.default.updateStyles(collectionId);\r\n            index_1.default.update();\r\n        }\r\n        static onChangeNewCollection(e) {\r\n            const target = e.currentTarget;\r\n            const { state } = index_2.default;\r\n            const value = target.value;\r\n            if (!value)\r\n                return;\r\n            state.newStyleCollection = value;\r\n        }\r\n        static onClickActivePrompt(e) {\r\n            const target = e.currentTarget;\r\n            const index = Number(target.dataset.index);\r\n            let group = Number(target.dataset.group);\r\n            if (Number.isNaN(group))\r\n                group = false;\r\n            if (e.ctrlKey || e.metaKey) {\r\n                index_3.default.removePrompt(index, group);\r\n                index_1.default.update();\r\n                index_4.default.update();\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    exports.default = SaveStyleEvent;\r\n});\r\n","define([\"require\", \"exports\", \"client/index\", \"client/ActivePrompts/index\", \"client/Database/index\", \"client/CurrentPrompts/showPrompts\", \"client/LoadStyle/index\", \"client/dom\", \"./event\"], function (require, exports, index_1, index_2, index_3, showPrompts_1, index_4, dom_1, event_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class SaveStyle {\r\n        static init(mainWrapper) {\r\n            const saveStyleWindow = document.createElement(\"div\");\r\n            saveStyleWindow.className = \"PBE_generalWindow PBE_stylesWindow\";\r\n            saveStyleWindow.id = \"PBE_saveStyleWindow\";\r\n            index_1.default.DOMCache.saveStyleWindow = saveStyleWindow;\r\n            mainWrapper.appendChild(saveStyleWindow);\r\n            index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n            saveStyleWindow.addEventListener(\"click\", () => {\r\n                index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n            });\r\n        }\r\n        static initButton(positiveWrapper) {\r\n            const addStylesButton = document.createElement(\"button\");\r\n            addStylesButton.className = \"PBE_actionButton PBE_saveStylesButton\";\r\n            addStylesButton.innerText = \"Save style\";\r\n            addStylesButton.addEventListener(\"click\", event_1.default.onOpenStyles);\r\n            positiveWrapper.appendChild(addStylesButton);\r\n        }\r\n        static showCurrentPrompts(wrapper) {\r\n            let activePrompts = index_2.default.getCurrentPrompts();\r\n            (0, showPrompts_1.default)({\r\n                prompts: activePrompts,\r\n                wrapper,\r\n                allowMove: false,\r\n                onClick: event_1.default.onClickActivePrompt,\r\n            });\r\n        }\r\n        static showAddStyle(wrapper) {\r\n            const { data } = index_3.default;\r\n            const { state } = index_1.default;\r\n            const setupContainer = document.createElement(\"div\");\r\n            setupContainer.className = \"PBE_List PBE_stylesSetup\";\r\n            const styleNameInput = document.createElement(\"input\");\r\n            const saveButton = document.createElement(\"button\");\r\n            saveButton.innerText = \"Save as style\";\r\n            saveButton.className = \"PBE_button\";\r\n            styleNameInput.placeholder = \"Style name\";\r\n            styleNameInput.className = \"PBE_generalInput PBE_newStyleName\";\r\n            styleNameInput.id = \"PBE_newStyleName\";\r\n            saveButton.addEventListener(\"click\", event_1.default.onSaveStyle);\r\n            const collectionSelect = document.createElement(\"select\");\r\n            collectionSelect.className = \"PBE_generalInput PBE_select\";\r\n            collectionSelect.style.height = \"30px\";\r\n            collectionSelect.style.marginRight = \"5px\";\r\n            let options = \"\";\r\n            for (const collectionId in data.styles) {\r\n                if (!state.newStyleCollection)\r\n                    state.newStyleCollection = collectionId;\r\n                options += `<option value=\"${collectionId}\">${collectionId}</option>`;\r\n            }\r\n            collectionSelect.innerHTML = options;\r\n            collectionSelect.value = state.newStyleCollection;\r\n            collectionSelect.addEventListener(\"change\", event_1.default.onChangeNewCollection);\r\n            const saveRow = (0, dom_1.makeElement)({ element: \"div\", className: \"PBE_row\" });\r\n            saveRow.appendChild(collectionSelect);\r\n            saveRow.appendChild(saveButton);\r\n            setupContainer.appendChild(styleNameInput);\r\n            setupContainer.appendChild(saveRow);\r\n            wrapper.appendChild(setupContainer);\r\n            index_4.default.showMetaCheckboxes(wrapper, false);\r\n            index_4.default.showStyleSetup(wrapper, false);\r\n        }\r\n        static update() {\r\n            const { readonly } = index_3.default.meta;\r\n            const { state } = index_1.default;\r\n            const wrapper = index_1.default.DOMCache.saveStyleWindow;\r\n            if (!wrapper || !state.showSaveStyleWindow)\r\n                return;\r\n            index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n            wrapper.innerHTML = \"\";\r\n            wrapper.style.display = \"flex\";\r\n            const currentPromptsBlock = (0, dom_1.makeDiv)({ className: \"PBE_dataBlock PBE_Scrollbar PBE_windowContent\" });\r\n            const footerBlock = (0, dom_1.makeDiv)({ className: \"PBE_rowBlock PBE_rowBlock_wide\" });\r\n            const closeButton = document.createElement(\"button\");\r\n            closeButton.innerText = \"Close\";\r\n            closeButton.className = \"PBE_button\";\r\n            const addNewContainer = (0, dom_1.makeDiv)({ className: \"PBE_row\" });\r\n            if (!readonly) {\r\n                SaveStyle.showCurrentPrompts(currentPromptsBlock);\r\n                SaveStyle.showAddStyle(addNewContainer);\r\n            }\r\n            closeButton.addEventListener(\"click\", event_1.default.onCloseWindow);\r\n            footerBlock.appendChild(closeButton);\r\n            if (!readonly) {\r\n                wrapper.appendChild(addNewContainer);\r\n                wrapper.appendChild(currentPromptsBlock);\r\n            }\r\n            wrapper.appendChild(footerBlock);\r\n        }\r\n        ;\r\n    }\r\n    exports.default = SaveStyle;\r\n});\r\n","define([\"require\", \"exports\", \"./index\", \"client/index\", \"client/Database/index\", \"client/utils/index\"], function (require, exports, index_1, index_2, index_3, index_4) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class SetupWindowEvent {\r\n    }\r\n    /**\r\n     * Closes Setup window\r\n     * @returns\r\n     */\r\n    SetupWindowEvent.onCloseWindow = () => {\r\n        const { viewMode } = index_1.default;\r\n        const wrapper = index_2.default.DOMCache.setupWindow;\r\n        if (!wrapper)\r\n            return;\r\n        if (viewMode === \"newCollection\" || viewMode === \"newStylesCollection\") {\r\n            index_1.default.viewMode = \"normal\";\r\n            index_1.default.update();\r\n            return true;\r\n        }\r\n        else\r\n            wrapper.style.display = \"none\";\r\n    };\r\n    SetupWindowEvent.onUpdateDirName = (e) => {\r\n        const target = e.currentTarget;\r\n        let value = target.value;\r\n        if (!value)\r\n            return;\r\n        value = (0, index_4.makeFileNameSafe)(value);\r\n        target.value = value;\r\n    };\r\n    SetupWindowEvent.onCreate = (e) => {\r\n        const target = e.currentTarget;\r\n        const { viewMode } = index_1.default;\r\n        if (!target.parentNode)\r\n            return;\r\n        const setupWindow = target.parentNode.parentNode;\r\n        if (!setupWindow)\r\n            return;\r\n        if (viewMode === \"newCollection\") {\r\n            const newNameInput = setupWindow.querySelector(\".PBE_newCollectionName\");\r\n            const formatSelect = setupWindow.querySelector(\".PBE_newCollectionFormat\");\r\n            if (!newNameInput || !formatSelect)\r\n                return;\r\n            const newName = (0, index_4.makeFileNameSafe)(newNameInput.value);\r\n            const format = formatSelect.value;\r\n            if (!newName || !format)\r\n                return;\r\n            index_3.default.createNewCollection(newName, format);\r\n        }\r\n        else if (viewMode === \"newStylesCollection\") {\r\n            const newNameInput = setupWindow.querySelector(\".PBE_newCollectionName\");\r\n            const formatSelect = setupWindow.querySelector(\".PBE_newStyleCollectionFormat\");\r\n            if (!newNameInput || !formatSelect)\r\n                return;\r\n            const newName = (0, index_4.makeFileNameSafe)(newNameInput.value);\r\n            const format = formatSelect.value;\r\n            if (!newName || !format)\r\n                return;\r\n            index_3.default.createNewStylesCollection(newName, format);\r\n        }\r\n        index_1.default.viewMode = \"normal\";\r\n        index_1.default.update();\r\n    };\r\n    exports.default = SetupWindowEvent;\r\n});\r\n","define([\"require\", \"exports\", \"client/index\", \"client/Database/index\", \"client/dom\", \"./event\"], function (require, exports, index_1, index_2, dom_1, event_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class SetupWindow {\r\n    }\r\n    /**\r\n     * Shown Setup window tab\r\n     */\r\n    SetupWindow.viewMode = \"normal\";\r\n    /**\r\n     * Inits Setup window HTML on page, loads config data.\r\n     * @param {*} wrapper\r\n     */\r\n    SetupWindow.init = (wrapper) => {\r\n        /*  const {state} = PromptsBrowser;\r\n    \r\n            const savedConfigString = localStorage.getItem(\"PBE_config\");\r\n            if(savedConfigString) {\r\n                const savedConfig = JSON.parse(savedConfigString);\r\n                if(savedConfig) state.config = savedConfig;\r\n            } */\r\n        const setupWindow = document.createElement(\"div\");\r\n        setupWindow.className = \"PBE_setupWindow PBE_generalWindow\";\r\n        index_1.default.DOMCache.setupWindow = setupWindow;\r\n        wrapper.appendChild(setupWindow);\r\n        index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n        setupWindow.addEventListener(\"click\", () => {\r\n            index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n        });\r\n    };\r\n    /**\r\n     * Shows block with create new collection buttons\r\n     * @param {*} wrapper\r\n     */\r\n    SetupWindow.showCreateNew = (wrapper) => {\r\n        const newCollection = (0, dom_1.makeElement)({\r\n            element: \"button\", className: \"PBE_button\", content: \"New prompts collection\"\r\n        });\r\n        const newStylesCollection = (0, dom_1.makeElement)({\r\n            element: \"button\", className: \"PBE_button\", content: \"New styles collection\"\r\n        });\r\n        newCollection.addEventListener(\"click\", () => {\r\n            SetupWindow.viewMode = \"newCollection\";\r\n            SetupWindow.update();\r\n        });\r\n        newStylesCollection.addEventListener(\"click\", () => {\r\n            SetupWindow.viewMode = \"newStylesCollection\";\r\n            SetupWindow.update();\r\n        });\r\n        wrapper.appendChild(newCollection);\r\n        wrapper.appendChild(newStylesCollection);\r\n        //wrapper.appendChild(buttonsBlock);\r\n    };\r\n    SetupWindow.showNewCollection = (wrapper) => {\r\n        const newName = document.createElement(\"div\");\r\n        const newNameLabel = document.createElement(\"div\");\r\n        const newNameInput = document.createElement(\"input\");\r\n        newName.className = \"PBE_rowBlock\";\r\n        newName.style.maxWidth = \"none\";\r\n        newNameInput.className = \"PBE_generalInput PBE_input PBE_newCollectionName\";\r\n        newNameLabel.innerText = \"New prompts collection name\";\r\n        newNameInput.addEventListener(\"change\", event_1.default.onUpdateDirName);\r\n        newName.appendChild(newNameLabel);\r\n        newName.appendChild(newNameInput);\r\n        const format = document.createElement(\"div\");\r\n        const formatLabel = document.createElement(\"div\");\r\n        const formatSelect = document.createElement(\"select\");\r\n        format.className = \"PBE_rowBlock\";\r\n        format.style.maxWidth = \"none\";\r\n        formatSelect.value = \"short\";\r\n        formatSelect.className = \"PBE_generalInput PBE_select PBE_newCollectionFormat\";\r\n        formatSelect.innerHTML = `\r\n            <option value=\"short\">Short</option>\r\n            <option value=\"expanded\">Expanded</option>\r\n        `;\r\n        formatLabel.innerText = \"Store format\";\r\n        format.appendChild(formatLabel);\r\n        format.appendChild(formatSelect);\r\n        wrapper.appendChild(newName);\r\n        wrapper.appendChild(format);\r\n    };\r\n    SetupWindow.showNewStylesCollection = (wrapper) => {\r\n        const newName = (0, dom_1.makeElement)({ element: \"div\", className: \"PBE_rowBlock\" });\r\n        const format = (0, dom_1.makeElement)({ element: \"div\", className: \"PBE_rowBlock\" });\r\n        newName.style.maxWidth = \"none\";\r\n        format.style.maxWidth = \"none\";\r\n        const newNameLabel = (0, dom_1.makeElement)({ element: \"div\", content: \"New styles collection name\" });\r\n        const formatLabel = (0, dom_1.makeElement)({ element: \"div\", content: \"Store format\" });\r\n        const newNameInput = (0, dom_1.makeElement)({ element: \"input\", className: \"PBE_generalInput PBE_input PBE_newCollectionName\" });\r\n        newNameInput.addEventListener(\"change\", event_1.default.onUpdateDirName);\r\n        newName.appendChild(newNameLabel);\r\n        newName.appendChild(newNameInput);\r\n        const formatSelect = (0, dom_1.makeSelect)({\r\n            className: \"PBE_generalInput PBE_select PBE_newStyleCollectionFormat\",\r\n            value: \"short\",\r\n            options: [\r\n                { id: \"short\", name: \"Short\" },\r\n                { id: \"expanded\", name: \"Expanded\" },\r\n            ],\r\n        });\r\n        format.appendChild(formatLabel);\r\n        format.appendChild(formatSelect);\r\n        wrapper.appendChild(newName);\r\n        wrapper.appendChild(format);\r\n    };\r\n    SetupWindow.update = () => {\r\n        const { readonly } = index_2.default.meta;\r\n        const { viewMode } = SetupWindow;\r\n        const wrapper = index_1.default.DOMCache.setupWindow;\r\n        if (!wrapper)\r\n            return;\r\n        index_1.default.onCloseActiveWindow = event_1.default.onCloseWindow;\r\n        wrapper.style.display = \"flex\";\r\n        if (viewMode === \"newCollection\")\r\n            wrapper.innerHTML = \"New prompts collection\";\r\n        else if (viewMode === \"newStylesCollection\")\r\n            wrapper.innerHTML = \"New styles collections\";\r\n        else\r\n            wrapper.innerHTML = \"New Collection\";\r\n        const topBlock = document.createElement(\"div\");\r\n        const contentBlock = document.createElement(\"div\");\r\n        const footerBlock = document.createElement(\"div\");\r\n        const closeButton = document.createElement(\"button\");\r\n        topBlock.className = \"PBE_row PBE_setupWindowTopBlock\";\r\n        contentBlock.className = \"PBE_windowContent PBE_Scrollbar\";\r\n        contentBlock.style.width = \"100%\";\r\n        if (viewMode === \"newCollection\") {\r\n            SetupWindow.showNewCollection(contentBlock);\r\n        }\r\n        else if (viewMode === \"newStylesCollection\") {\r\n            SetupWindow.showNewStylesCollection(contentBlock);\r\n        }\r\n        else {\r\n            if (!readonly)\r\n                SetupWindow.showCreateNew(topBlock);\r\n            const infoMessage = document.createElement(\"div\");\r\n            infoMessage.innerText = `The extension settings have moved to the general webUI settings in the \"Prompts Browser\" category.`;\r\n            contentBlock.appendChild(infoMessage);\r\n        }\r\n        const statusBlock = (0, dom_1.makeElement)({ element: \"div\", className: \"PBE_setupWindowStatus PBE_row\" });\r\n        statusBlock.innerHTML = `\r\n            version: ${index_2.default.meta.version}\r\n            <a target='_blank' href='https://github.com/AlpacaInTheNight/PromptsBrowser'>Project Page</a>\r\n        `;\r\n        footerBlock.className = \"PBE_rowBlock PBE_rowBlock_wide\";\r\n        footerBlock.style.justifyContent = \"space-evenly\";\r\n        closeButton.innerText = viewMode === \"normal\" ? \"Close\" : \"Cancel\";\r\n        closeButton.className = \"PBE_button\";\r\n        if (viewMode !== \"normal\")\r\n            closeButton.classList.add(\"PBE_buttonCancel\");\r\n        closeButton.addEventListener(\"click\", event_1.default.onCloseWindow);\r\n        if (viewMode === \"newCollection\" || viewMode === \"newStylesCollection\") {\r\n            const createButton = document.createElement(\"button\");\r\n            createButton.innerText = \"Create\";\r\n            createButton.className = \"PBE_button\";\r\n            createButton.addEventListener(\"click\", event_1.default.onCreate);\r\n            footerBlock.appendChild(createButton);\r\n        }\r\n        footerBlock.appendChild(closeButton);\r\n        wrapper.appendChild(topBlock);\r\n        wrapper.appendChild(contentBlock);\r\n        wrapper.appendChild(statusBlock);\r\n        wrapper.appendChild(footerBlock);\r\n    };\r\n    exports.default = SetupWindow;\r\n});\r\n","define([\"require\", \"exports\", \"./index\"], function (require, exports, index_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class TagTooltipEvent {\r\n        static onUnfocus(e) {\r\n            const inputElement = e;\r\n            const autoCompleteBox = index_1.default.container;\r\n            if (!autoCompleteBox || !inputElement)\r\n                return;\r\n            if (autoCompleteBox.style.display === \"none\")\r\n                return;\r\n            clearTimeout(index_1.default.unfocusTimeout);\r\n            index_1.default.unfocusTimeout = setTimeout(() => {\r\n                autoCompleteBox.style.display = \"none\";\r\n                autoCompleteBox.innerHTML = \"\";\r\n            }, 400);\r\n        }\r\n        static onKeyDown(e) {\r\n            const inputElement = e;\r\n            const autoCompleteBox = index_1.default.container;\r\n            if (!autoCompleteBox || !inputElement)\r\n                return;\r\n            if (autoCompleteBox.style.display === \"none\")\r\n                return;\r\n            if (e.keyCode != 38 && e.keyCode != 40 && e.keyCode != 13)\r\n                return;\r\n            const hintElements = autoCompleteBox.querySelectorAll(\".PBE_hintItem\");\r\n            if (!hintElements || !hintElements.length)\r\n                return;\r\n            e.stopPropagation();\r\n            e.preventDefault();\r\n            e.stopImmediatePropagation();\r\n        }\r\n        static onClickHint(e) {\r\n            const inputElement = index_1.default.input;\r\n            const autoCompleteBox = index_1.default.container;\r\n            if (!autoCompleteBox || !inputElement)\r\n                return;\r\n            const target = e.currentTarget;\r\n            if (!target)\r\n                return;\r\n            const start = Number(target.dataset.start);\r\n            const end = Number(target.dataset.end);\r\n            const newPrompt = target.innerText;\r\n            if (Number.isNaN(start) || Number.isNaN(end))\r\n                return;\r\n            TagTooltipEvent.onApplyHint(start, end, newPrompt);\r\n        }\r\n        static onHintWindowKey(e) {\r\n            const inputElement = index_1.default.input;\r\n            const autoCompleteBox = index_1.default.container;\r\n            if (!autoCompleteBox || !inputElement)\r\n                return false;\r\n            if (autoCompleteBox.style.display === \"none\")\r\n                return false;\r\n            if (e.keyCode != 38 && e.keyCode != 40 && e.keyCode != 13)\r\n                return false;\r\n            const hintElements = autoCompleteBox.querySelectorAll(\".PBE_hintItem\");\r\n            if (!hintElements || !hintElements.length)\r\n                return false;\r\n            if (e.keyCode === 13) {\r\n                const selectedHint = autoCompleteBox.querySelector(\".PBE_hintItemSelected\");\r\n                if (!selectedHint)\r\n                    return false;\r\n                const start = Number(selectedHint.dataset.start);\r\n                const end = Number(selectedHint.dataset.end);\r\n                const newPrompt = selectedHint.innerText;\r\n                if (Number.isNaN(start) || Number.isNaN(end))\r\n                    return false;\r\n                TagTooltipEvent.onApplyHint(start, end, newPrompt);\r\n                return true;\r\n            }\r\n            const isDown = e.keyCode == 40;\r\n            if (isDown)\r\n                index_1.default.selectedIndex++;\r\n            else\r\n                index_1.default.selectedIndex--;\r\n            if (index_1.default.selectedIndex < 0)\r\n                index_1.default.selectedIndex = hintElements.length - 1;\r\n            else if (index_1.default.selectedIndex > hintElements.length - 1)\r\n                index_1.default.selectedIndex = 0;\r\n            for (let i = 0; i < hintElements.length; i++) {\r\n                const element = hintElements[i];\r\n                if (i === index_1.default.selectedIndex)\r\n                    element.classList.add(\"PBE_hintItemSelected\");\r\n                else\r\n                    element.classList.remove(\"PBE_hintItemSelected\");\r\n            }\r\n            return true;\r\n        }\r\n        static onApplyHint(start, end, newTag) {\r\n            const inputElement = index_1.default.input;\r\n            const autoCompleteBox = index_1.default.container;\r\n            if (!autoCompleteBox || !inputElement)\r\n                return;\r\n            autoCompleteBox.style.display = \"none\";\r\n            inputElement.dataset.hint = \"\";\r\n            let newValue = \"\";\r\n            const prefix = inputElement.value.substring(0, start);\r\n            const postfix = inputElement.value.substring(end);\r\n            if (prefix)\r\n                newValue += prefix + \" \";\r\n            newValue += newTag;\r\n            if (postfix)\r\n                newValue += postfix;\r\n            inputElement.value = newValue;\r\n            index_1.default.selectedIndex = 0;\r\n            inputElement.dispatchEvent(new Event(\"change\"));\r\n        }\r\n    }\r\n    exports.default = TagTooltipEvent;\r\n});\r\n","define([\"require\", \"exports\", \"client/Database/index\", \"./event\"], function (require, exports, index_1, event_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class TagTooltip {\r\n        static add(inputContainer, fixed = false) {\r\n            TagTooltip.updateTagsList();\r\n            //removing old element from the page\r\n            if (TagTooltip.container) {\r\n                const oldWindow = document.querySelector(\".PBE_autocompliteTags\");\r\n                if (oldWindow)\r\n                    oldWindow.remove();\r\n                TagTooltip.container = undefined;\r\n            }\r\n            const autocompliteWindow = document.createElement(\"div\");\r\n            autocompliteWindow.className = \"PBE_autocompliteBox PBE_autocompliteTags\";\r\n            if (fixed)\r\n                inputContainer.dataset.position = \"fixed\";\r\n            document.body.appendChild(autocompliteWindow);\r\n            TagTooltip.setBoxPosition(inputContainer, autocompliteWindow);\r\n            autocompliteWindow.innerText = \"\";\r\n            TagTooltip.container = autocompliteWindow;\r\n            TagTooltip.input = inputContainer;\r\n            inputContainer.addEventListener(\"keydown\", event_1.default.onKeyDown);\r\n            inputContainer.addEventListener(\"blur\", event_1.default.onUnfocus);\r\n            inputContainer.addEventListener(\"keyup\", TagTooltip.processCarretPosition);\r\n            inputContainer.addEventListener(\"click\", TagTooltip.processCarretPosition);\r\n        }\r\n        static setBoxPosition(inputContainer, boxContainer) {\r\n            const rect = inputContainer.getBoundingClientRect();\r\n            boxContainer.style.top = rect.top + rect.height + \"px\";\r\n            boxContainer.style.left = rect.left + \"px\";\r\n            boxContainer.style.zIndex = \"1000\";\r\n        }\r\n        static updateTagsList() {\r\n            const { data } = index_1.default;\r\n            if (!data || !data.united)\r\n                return;\r\n            const knownTags = [];\r\n            const promptsList = data.united;\r\n            for (const prompt of promptsList) {\r\n                if (!prompt.tags)\r\n                    continue;\r\n                for (const tagItem of prompt.tags) {\r\n                    if (!knownTags.includes(tagItem))\r\n                        knownTags.push(tagItem);\r\n                }\r\n            }\r\n            knownTags.sort();\r\n            TagTooltip.knownTags = knownTags;\r\n        }\r\n        static processCarretPosition(e) {\r\n            const target = e.currentTarget;\r\n            TagTooltip.input = target;\r\n            const elementPosition = target.dataset.position || \"\";\r\n            clearTimeout(TagTooltip.unfocusTimeout);\r\n            if (e.keyCode === 38 || e.keyCode === 40 || e.keyCode === 13) {\r\n                const block = event_1.default.onHintWindowKey(e);\r\n                if (block) {\r\n                    e.stopPropagation();\r\n                    e.preventDefault();\r\n                    return false;\r\n                }\r\n            }\r\n            const { selectedIndex = 0, knownTags = [] } = TagTooltip;\r\n            const autoCompleteBox = TagTooltip.container;\r\n            if (!autoCompleteBox || !target)\r\n                return;\r\n            autoCompleteBox.innerHTML = \"\";\r\n            TagTooltip.setBoxPosition(target, autoCompleteBox);\r\n            if (autoCompleteBox.style.position !== elementPosition) {\r\n                autoCompleteBox.style.position = elementPosition;\r\n            }\r\n            const MAX_HINTS = 20;\r\n            let currHints = 0;\r\n            const value = target.value;\r\n            const caret = target.selectionStart;\r\n            const stopSymbols = [\",\", \"(\", \")\", \"<\", \">\", \":\"];\r\n            let position = caret;\r\n            let word = \"\";\r\n            let wordStart = caret;\r\n            let wordEnd = caret;\r\n            while (value[position]) {\r\n                if (value[position] && stopSymbols.includes(value[position]))\r\n                    break;\r\n                word += value[position];\r\n                position++;\r\n                wordEnd = position;\r\n            }\r\n            position = caret - 1;\r\n            while (value[position]) {\r\n                if (value[position] && stopSymbols.includes(value[position]))\r\n                    break;\r\n                word = value[position] + word;\r\n                wordStart = position;\r\n                position--;\r\n            }\r\n            word = word.trim();\r\n            if (!word) {\r\n                target.dataset.hint = \"\";\r\n                return;\r\n            }\r\n            word = word.toLowerCase();\r\n            const possibleTags = [];\r\n            for (const tag of knownTags) {\r\n                if (tag.toLowerCase().includes(word))\r\n                    possibleTags.push(tag);\r\n            }\r\n            if (!possibleTags.length || (possibleTags.length === 1 && word === possibleTags[0])) {\r\n                autoCompleteBox.style.display = \"none\";\r\n                target.dataset.hint = \"\";\r\n                return;\r\n            }\r\n            else {\r\n                autoCompleteBox.style.display = \"\";\r\n                target.dataset.hint = \"true\";\r\n            }\r\n            for (const item of possibleTags) {\r\n                if (currHints >= MAX_HINTS)\r\n                    break;\r\n                const hintItem = document.createElement(\"div\");\r\n                hintItem.className = \"PBE_hintItem\";\r\n                hintItem.innerText = item;\r\n                hintItem.dataset.start = wordStart + \"\";\r\n                hintItem.dataset.end = wordEnd + \"\";\r\n                if (currHints === selectedIndex)\r\n                    hintItem.classList.add(\"PBE_hintItemSelected\");\r\n                hintItem.addEventListener(\"click\", event_1.default.onClickHint);\r\n                autoCompleteBox.appendChild(hintItem);\r\n                currHints++;\r\n            }\r\n        }\r\n    }\r\n    TagTooltip.selectedIndex = 0;\r\n    TagTooltip.unfocusTimeout = 0;\r\n    TagTooltip.container = undefined;\r\n    TagTooltip.input = undefined;\r\n    TagTooltip.knownTags = [];\r\n    exports.default = TagTooltip;\r\n});\r\n","define([\"require\", \"exports\", \"client/index\", \"client/ActivePrompts/index\", \"client/CurrentPrompts/index\", \"clientTypes/style\"], function (require, exports, index_1, index_2, index_3, style_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    //making sure Svelte will pick up and delegate changes in the input value\r\n    function triggerEvents(element) {\r\n        element.dispatchEvent(new KeyboardEvent('keypress'));\r\n        element.dispatchEvent(new KeyboardEvent('input'));\r\n        element.dispatchEvent(new KeyboardEvent('blur'));\r\n    }\r\n    let _timerSamplerA = 0;\r\n    let _timerSamplerB = 0;\r\n    function addItem(isRoot, branchItem, activePrompts, isAfter, unique) {\r\n        if (\"groupId\" in branchItem) {\r\n            const { prompts } = branchItem;\r\n            branchItem.prompts = [];\r\n            addBranch(false, prompts, branchItem.prompts, isAfter, unique);\r\n            if (isRoot && !isAfter)\r\n                activePrompts.unshift(branchItem);\r\n            else\r\n                activePrompts.push(branchItem);\r\n        }\r\n        else {\r\n            const { id, isSyntax } = branchItem;\r\n            if (!isSyntax && unique.includes(id))\r\n                return;\r\n            if (isRoot && !isAfter)\r\n                activePrompts.unshift(Object.assign({}, branchItem));\r\n            else\r\n                activePrompts.push(Object.assign({}, branchItem));\r\n        }\r\n    }\r\n    function addBranch(isRoot, branch, activePrompts, isAfter, unique) {\r\n        if (isRoot && !isAfter) {\r\n            for (let i = branch.length - 1; i >= 0; i--) {\r\n                const branchItem = branch[i];\r\n                addItem(isRoot, branchItem, activePrompts, isAfter, unique);\r\n            }\r\n        }\r\n        else {\r\n            for (const branchItem of branch) {\r\n                addItem(isRoot, branchItem, activePrompts, isAfter, unique);\r\n            }\r\n        }\r\n    }\r\n    function addPositive(positive, isAfter, addType = style_1.AddStyleType.UniqueRoot) {\r\n        if (!positive || !positive.length)\r\n            return false;\r\n        const uniqueUsedPrompts = index_2.default.getUniqueIds();\r\n        const activePrompts = index_2.default.getCurrentPrompts();\r\n        if (addType === style_1.AddStyleType.UniqueRoot || addType === style_1.AddStyleType.All) {\r\n            if (isAfter) {\r\n                for (const prompt of positive) {\r\n                    if (\"groupId\" in prompt) {\r\n                        activePrompts.push(Object.assign({}, prompt));\r\n                        continue;\r\n                    }\r\n                    const { id, isSyntax } = prompt;\r\n                    if (addType === style_1.AddStyleType.UniqueRoot && !isSyntax && uniqueUsedPrompts.includes(id))\r\n                        continue;\r\n                    activePrompts.push(Object.assign({}, prompt));\r\n                }\r\n            }\r\n            else {\r\n                for (let i = positive.length - 1; i >= 0; i--) {\r\n                    const prompt = positive[i];\r\n                    if (\"groupId\" in prompt) {\r\n                        activePrompts.unshift(Object.assign({}, prompt));\r\n                        continue;\r\n                    }\r\n                    const { id, isSyntax } = prompt;\r\n                    if (addType === style_1.AddStyleType.UniqueRoot && !isSyntax && uniqueUsedPrompts.includes(id))\r\n                        continue;\r\n                    activePrompts.unshift(Object.assign({}, prompt));\r\n                }\r\n            }\r\n        }\r\n        else if (addType === style_1.AddStyleType.UniqueOnly) {\r\n            addBranch(true, positive, activePrompts, isAfter, uniqueUsedPrompts);\r\n        }\r\n    }\r\n    function applyStyle(style, isAfter, override = false) {\r\n        if (!style)\r\n            return;\r\n        const { state } = index_1.default;\r\n        const { positive, negative, seed, width, height, steps, cfg, sampling, addType = style_1.AddStyleType.UniqueRoot } = style;\r\n        if (override)\r\n            index_2.default.setCurrentPrompts([]);\r\n        const negativePrompts = index_1.default.DOMCache.containers[state.currentContainer].negativePrompts;\r\n        const seedInput = index_1.default.DOMCache.containers[state.currentContainer].seedInput;\r\n        const widthInput = index_1.default.DOMCache.containers[state.currentContainer].widthInput;\r\n        const heightInput = index_1.default.DOMCache.containers[state.currentContainer].heightInput;\r\n        const stepsInput = index_1.default.DOMCache.containers[state.currentContainer].stepsInput;\r\n        const cfgInput = index_1.default.DOMCache.containers[state.currentContainer].cfgInput;\r\n        const samplingInput = index_1.default.DOMCache.containers[state.currentContainer].samplingInput;\r\n        addPositive(positive, isAfter, addType);\r\n        if (seed !== undefined && seedInput) {\r\n            seedInput.value = seed + \"\";\r\n            triggerEvents(seedInput);\r\n        }\r\n        if (negativePrompts && negative) {\r\n            const negativeTextAreas = negativePrompts.getElementsByTagName(\"textarea\");\r\n            if (negativeTextAreas && negativeTextAreas[0]) {\r\n                const textArea = negativeTextAreas[0];\r\n                textArea.value = negative;\r\n                triggerEvents(textArea);\r\n            }\r\n        }\r\n        if (widthInput && width !== undefined) {\r\n            widthInput.value = width + \"\";\r\n            triggerEvents(widthInput);\r\n        }\r\n        if (heightInput && height !== undefined) {\r\n            heightInput.value = height + \"\";\r\n            triggerEvents(heightInput);\r\n        }\r\n        if (stepsInput && steps !== undefined) {\r\n            stepsInput.value = steps + \"\";\r\n            triggerEvents(stepsInput);\r\n        }\r\n        if (cfgInput && cfg !== undefined) {\r\n            cfgInput.value = cfg + \"\";\r\n            triggerEvents(cfgInput);\r\n        }\r\n        if (samplingInput && sampling) {\r\n            const inputWrapper = samplingInput.parentElement.parentElement;\r\n            const enterKeyEvent = new KeyboardEvent('keydown', {\r\n                code: 'Enter',\r\n                key: 'Enter',\r\n                charCode: 13,\r\n                keyCode: 13,\r\n                view: window,\r\n                bubbles: true\r\n            });\r\n            inputWrapper.style.opacity = \"0\";\r\n            samplingInput.dispatchEvent(new KeyboardEvent('focus'));\r\n            clearTimeout(_timerSamplerA);\r\n            clearTimeout(_timerSamplerB);\r\n            _timerSamplerA = setTimeout(() => {\r\n                samplingInput.value = sampling;\r\n                samplingInput.dispatchEvent(new KeyboardEvent('keydown'));\r\n                samplingInput.dispatchEvent(new KeyboardEvent('keyup'));\r\n                samplingInput.dispatchEvent(new KeyboardEvent('input'));\r\n                _timerSamplerB = setTimeout(() => {\r\n                    samplingInput.dispatchEvent(enterKeyEvent);\r\n                    inputWrapper.style.opacity = \"\";\r\n                }, 100);\r\n            }, 100);\r\n        }\r\n        index_3.default.update();\r\n    }\r\n    exports.default = applyStyle;\r\n});\r\n","define([\"require\", \"exports\"], function (require, exports) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const categories = [\r\n        \"character\",\r\n        \"character description\",\r\n        \"portrait\",\r\n        \"body\",\r\n        \"composition\",\r\n        \"object\",\r\n        \"interior\",\r\n        \"exterior\",\r\n        \"artist\",\r\n        \"action\",\r\n        \"cloth\",\r\n        \"style\",\r\n        \"lighting\",\r\n        \"building\",\r\n        \"scenery\",\r\n        \"architecture\",\r\n        \"texture\",\r\n        \"position\",\r\n        \"background\",\r\n        \"emotion\",\r\n        \"media\",\r\n        \"condition\",\r\n        \"quality\",\r\n        \"franchise\",\r\n        \"effect\",\r\n        \"meta\",\r\n        \"creature\"\r\n    ].sort();\r\n    exports.default = categories;\r\n});\r\n","define([\"require\", \"exports\"], function (require, exports) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    /**\r\n     * Returns true if prompt passes filter requirements\r\n     * @param {*} prompt\r\n     * @param {*} filter\r\n     * @returns boolean\r\n     */\r\n    function checkFilter(prompt, filter) {\r\n        if (!filter || !filter.length)\r\n            return true; //no filter requirements\r\n        let { id, comment = \"\", autogen = {} } = prompt;\r\n        if (!id)\r\n            return false; //invalid prompt\r\n        const { tags = [], category = [], previewImage } = prompt;\r\n        let fulfil = false;\r\n        id = id.toLowerCase();\r\n        comment = comment.toLowerCase();\r\n        const haveAutogen = autogen.collection && autogen.style ? true : false;\r\n        for (const filterItem of filter) {\r\n            const { action, type, value } = filterItem;\r\n            const isInclude = action === \"include\";\r\n            fulfil = false;\r\n            if (type === \"name\") {\r\n                if (id.includes(value))\r\n                    fulfil = isInclude ? true : false;\r\n                else if (!isInclude)\r\n                    fulfil = true;\r\n            }\r\n            else if (type === \"category\") {\r\n                if (value === \"__none\") {\r\n                    if (!category.length)\r\n                        fulfil = isInclude ? true : false;\r\n                }\r\n                else {\r\n                    if (category.includes(value))\r\n                        fulfil = isInclude ? true : false;\r\n                    else if (!isInclude)\r\n                        fulfil = true;\r\n                }\r\n            }\r\n            else if (type === \"tag\") {\r\n                if (tags.includes(value))\r\n                    fulfil = isInclude ? true : false;\r\n                else if (!isInclude)\r\n                    fulfil = true;\r\n            }\r\n            else if (type === \"meta\") {\r\n                if (value === \"preview\")\r\n                    fulfil = isInclude ? !!previewImage : !previewImage;\r\n                else if (value === \"png\")\r\n                    fulfil = isInclude ? previewImage === \"png\" : previewImage !== \"png\";\r\n                else if (value === \"jpg\")\r\n                    fulfil = isInclude ? previewImage === \"jpg\" : previewImage !== \"jpg\";\r\n                else if (value === \"categories\")\r\n                    fulfil = isInclude ? !!category.length : !category.length;\r\n                else if (value === \"tags\")\r\n                    fulfil = isInclude ? !!tags.length : !tags.length;\r\n                else if (value === \"comment\")\r\n                    fulfil = isInclude ? !!comment : !comment;\r\n                else if (value === \"autogen\")\r\n                    fulfil = isInclude ? haveAutogen : !haveAutogen;\r\n                else if (value === \"categories3\")\r\n                    fulfil = isInclude ? category.length >= 3 : category.length < 3;\r\n                else if (value === \"tags3\")\r\n                    fulfil = isInclude ? tags.length >= 3 : tags.length < 3;\r\n            }\r\n            if (!fulfil)\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    exports.default = checkFilter;\r\n});\r\n","define([\"require\", \"exports\"], function (require, exports) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.NEW_CARD_GRADIENT = exports.EMPTY_CARD_GRADIENT = exports.PROMPT_WEIGHT_FACTOR = exports.DEFAULT_PROMPT_WEIGHT = void 0;\r\n    const DEFAULT_PROMPT_WEIGHT = 1;\r\n    exports.DEFAULT_PROMPT_WEIGHT = DEFAULT_PROMPT_WEIGHT;\r\n    const PROMPT_WEIGHT_FACTOR = 1.1;\r\n    exports.PROMPT_WEIGHT_FACTOR = PROMPT_WEIGHT_FACTOR;\r\n    const EMPTY_CARD_GRADIENT = \"linear-gradient(135deg, rgba(179,220,237,1) 0%,rgba(41,184,229,1) 50%,rgba(188,224,238,1) 100%)\";\r\n    exports.EMPTY_CARD_GRADIENT = EMPTY_CARD_GRADIENT;\r\n    const NEW_CARD_GRADIENT = \"linear-gradient(135deg, rgba(180,221,180,1) 0%,rgba(131,199,131,1) 17%,rgba(82,177,82,1) 33%,rgba(0,138,0,1) 67%,rgba(0,87,0,1) 83%,rgba(0,36,0,1) 100%)\";\r\n    exports.NEW_CARD_GRADIENT = NEW_CARD_GRADIENT;\r\n});\r\n","define([\"require\", \"exports\"], function (require, exports) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.makeSelect = exports.makeCheckbox = exports.makeDiv = exports.makeElement = void 0;\r\n    function makeElement(params) {\r\n        if (!params)\r\n            return;\r\n        const { element, id, name, className, type, content, title, style, value, placeholder, onChange } = params;\r\n        if (!element)\r\n            return;\r\n        const newElement = document.createElement(element);\r\n        if (type)\r\n            newElement.type = type;\r\n        if (id)\r\n            newElement.id = id;\r\n        if (name)\r\n            newElement.name = name;\r\n        if (className)\r\n            newElement.className = className;\r\n        if (content)\r\n            newElement.innerText = content;\r\n        if (title)\r\n            newElement.title = title;\r\n        if (value)\r\n            newElement.value = value;\r\n        if (placeholder)\r\n            newElement.placeholder = placeholder;\r\n        if (style)\r\n            for (const i in style)\r\n                newElement.style[i] = style[i];\r\n        if (onChange)\r\n            newElement.addEventListener(\"change\", onChange);\r\n        return newElement;\r\n    }\r\n    exports.makeElement = makeElement;\r\n    function makeCheckbox(params) {\r\n        if (!params)\r\n            return;\r\n        const { name = \"\", title = \"\", checked = false, id, data, onChange, reverse = false } = params;\r\n        let { wrapper } = params;\r\n        if (!wrapper)\r\n            wrapper = makeElement({ element: \"div\" });\r\n        const checkBox = makeElement(Object.assign(Object.assign({}, params), { element: \"input\", type: \"checkbox\" }));\r\n        const boxTitle = makeElement({ element: \"label\", content: name, title });\r\n        checkBox.checked = checked;\r\n        if (reverse) {\r\n            wrapper.appendChild(boxTitle);\r\n            wrapper.appendChild(checkBox);\r\n        }\r\n        else {\r\n            wrapper.appendChild(checkBox);\r\n            wrapper.appendChild(boxTitle);\r\n        }\r\n        if (onChange)\r\n            checkBox.addEventListener(\"change\", onChange);\r\n        if (id) {\r\n            checkBox.name = id;\r\n            boxTitle.htmlFor = id;\r\n        }\r\n        if (data)\r\n            checkBox.dataset.id = data;\r\n        return wrapper;\r\n    }\r\n    exports.makeCheckbox = makeCheckbox;\r\n    function makeSelect(params) {\r\n        if (!params)\r\n            return;\r\n        const { id, value = \"\", options = [], className, onChange, style } = params;\r\n        const selectElement = makeElement({ element: \"select\", id, className, style });\r\n        if (onChange)\r\n            selectElement.addEventListener(\"change\", onChange);\r\n        let htmlOptions = \"\";\r\n        for (const option of options) {\r\n            htmlOptions += `<option value=\"${option.id}\">${option.name}</option>`;\r\n        }\r\n        selectElement.innerHTML = htmlOptions;\r\n        selectElement.value = value;\r\n        return selectElement;\r\n    }\r\n    exports.makeSelect = makeSelect;\r\n    function makeDiv(params) {\r\n        return makeElement(Object.assign(Object.assign({}, params), { element: \"div\" }));\r\n    }\r\n    exports.makeDiv = makeDiv;\r\n});\r\n","define([\"require\", \"exports\", \"client/Database/index\", \"client/SetupWindow/index\", \"client/PromptEdit/index\", \"client/PromptTools/index\", \"client/CollectionTools/index\", \"client/ControlPanel/index\", \"client/KnownPrompts/index\", \"client/CurrentPrompts/index\", \"client/SaveStyle/index\", \"client/LoadStyle/index\", \"client/PromptScribe/index\", \"client/PreviewSave/index\", \"client/PromptWordTooltip/index\", \"client/synchroniseCurrentPrompts\", \"client/utils/index\", \"client/initialState\", \"client/supportedContainers\"], function (require, exports, index_1, index_2, index_3, index_4, index_5, index_6, index_7, index_8, index_9, index_10, index_11, index_12, index_13, synchroniseCurrentPrompts_1, index_14, initialState_1, supportedContainers_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class PromptsBrowser {\r\n        static onChangeTab(e) {\r\n            const target = e.target;\r\n            const tagName = target.tagName.toLowerCase();\r\n            if (tagName !== \"button\")\r\n                return;\r\n            const { state } = PromptsBrowser;\r\n            const text = target.innerText.trim();\r\n            if (state.currentContainer === text)\r\n                return;\r\n            let update = false;\r\n            if (text === \"txt2img\") {\r\n                state.currentContainer = \"text2Img\";\r\n                update = true;\r\n            }\r\n            if (text === \"img2img\") {\r\n                state.currentContainer = \"img2Img\";\r\n                update = true;\r\n            }\r\n            if (update) {\r\n                index_6.default.update();\r\n                index_12.default.update();\r\n                index_7.default.update();\r\n                index_8.default.update();\r\n            }\r\n        }\r\n        /**\r\n         * Tracking escape key to close active window.\r\n         * @param e\r\n         * @returns\r\n         */\r\n        static onDocumentKey(e) {\r\n            if (e.key !== \"Escape\")\r\n                return;\r\n            let hold = false;\r\n            if (PromptsBrowser.onCloseActiveWindow)\r\n                hold = PromptsBrowser.onCloseActiveWindow() || false;\r\n            if (!hold)\r\n                PromptsBrowser.onCloseActiveWindow = undefined;\r\n        }\r\n    }\r\n    PromptsBrowser.timeoutPBUpdatePrompt = 0;\r\n    PromptsBrowser.DOMCache = {\r\n        containers: {},\r\n    };\r\n    PromptsBrowser.state = initialState_1.default;\r\n    PromptsBrowser.onCloseActiveWindow = undefined;\r\n    PromptsBrowser.supportedContainers = supportedContainers_1.default;\r\n    PromptsBrowser.textAreaSynchronise = () => (0, synchroniseCurrentPrompts_1.default)(true, false);\r\n    PromptsBrowser.loadUIConfig = () => {\r\n        const { state } = PromptsBrowser;\r\n        const lsShowViews = localStorage.getItem(\"PBE_showViews\");\r\n        if (lsShowViews)\r\n            state.showViews = JSON.parse(lsShowViews);\r\n        const showControlPanel = localStorage.getItem(\"showControlPanel\");\r\n        if (showControlPanel === \"false\")\r\n            state.showControlPanel = false;\r\n    };\r\n    /**\r\n     * Loading extension configuration from the local storage\r\n     * TODO: this is outdated. Config comes from server now.\r\n     */\r\n    PromptsBrowser.loadConfig = () => {\r\n        const { state } = PromptsBrowser;\r\n        //getting config from local storage\r\n        const savedConfigString = localStorage.getItem(\"PBE_config\");\r\n        if (savedConfigString) {\r\n            const savedConfig = JSON.parse(savedConfigString);\r\n            if (savedConfig)\r\n                state.config = savedConfig;\r\n        }\r\n    };\r\n    PromptsBrowser.gradioApp = () => {\r\n        const elems = document.getElementsByTagName('gradio-app');\r\n        const gradioShadowRoot = elems.length == 0 ? null : elems[0].shadowRoot;\r\n        return !!gradioShadowRoot ? gradioShadowRoot : document.body;\r\n    };\r\n    PromptsBrowser.init = (tries = 0) => {\r\n        const { state } = PromptsBrowser;\r\n        const { DOMCache } = PromptsBrowser;\r\n        const { united } = index_1.default.data;\r\n        if (!DOMCache.containers)\r\n            DOMCache.containers = {};\r\n        const mainContainer = PromptsBrowser.gradioApp();\r\n        if (tries > 100) {\r\n            (0, index_14.log)(\"No prompt wrapper container found or server did not returned prompts data.\");\r\n            return;\r\n        }\r\n        const checkContainer = mainContainer.querySelector(\"#txt2img_prompt_container\");\r\n        if (!checkContainer || !united) {\r\n            PromptsBrowser.timeoutPBUpdatePrompt = setTimeout(() => PromptsBrowser.init(tries + 1), 1000);\r\n            return;\r\n        }\r\n        DOMCache.mainContainer = mainContainer;\r\n        const tabsContainer = mainContainer.querySelector(\"#tabs > div:first-child\");\r\n        tabsContainer.removeEventListener(\"click\", PromptsBrowser.onChangeTab);\r\n        tabsContainer.addEventListener(\"click\", PromptsBrowser.onChangeTab);\r\n        document.removeEventListener('keyup', PromptsBrowser.onDocumentKey);\r\n        document.addEventListener('keyup', PromptsBrowser.onDocumentKey);\r\n        for (const containerId in PromptsBrowser.supportedContainers) {\r\n            DOMCache.containers[containerId] = {};\r\n            const container = PromptsBrowser.supportedContainers[containerId];\r\n            const domContainer = DOMCache.containers[containerId];\r\n            if (container.prompt) {\r\n                const promptContainer = mainContainer.querySelector(`#${container.prompt}`);\r\n                if (promptContainer.dataset.loadedpbextension)\r\n                    continue;\r\n                promptContainer.dataset.loadedpbextension = \"true\";\r\n                const positivePrompts = mainContainer.querySelector(`#${container.prompt} > div`);\r\n                const negativePrompts = mainContainer.querySelector(`#${container.prompt} > div:nth-child(2)`);\r\n                if (!positivePrompts || !negativePrompts) {\r\n                    (0, index_14.log)(`No prompt containers found for ${containerId}`);\r\n                    continue;\r\n                }\r\n                domContainer.promptContainer = promptContainer;\r\n                domContainer.positivePrompts = positivePrompts;\r\n                domContainer.negativePrompts = negativePrompts;\r\n                //in order to be able to place buttons correctly\r\n                positivePrompts.style.position = \"relative\";\r\n                if (container.buttons) {\r\n                    const buttonsContainer = mainContainer.querySelector(`#${container.buttons}`);\r\n                    if (buttonsContainer) {\r\n                        domContainer.buttonsContainer = buttonsContainer;\r\n                        const generateButton = buttonsContainer.querySelector(\".primary\");\r\n                        if (generateButton)\r\n                            domContainer.generateButton = generateButton;\r\n                    }\r\n                }\r\n                if (container.results) {\r\n                    const resultsContainer = mainContainer.querySelector(`#${container.results}`);\r\n                    if (resultsContainer) {\r\n                        domContainer.resultsContainer = resultsContainer;\r\n                    }\r\n                }\r\n                domContainer.textArea = positivePrompts.querySelector(\"textarea\");\r\n                const textArea = domContainer.textArea;\r\n                if (textArea && !textArea.dataset.pbelistenerready) {\r\n                    textArea.dataset.pbelistenerready = \"true\";\r\n                    textArea.removeEventListener(\"input\", PromptsBrowser.textAreaSynchronise);\r\n                    textArea.addEventListener(\"input\", PromptsBrowser.textAreaSynchronise);\r\n                }\r\n                index_13.default.init(positivePrompts, containerId);\r\n                index_6.default.init(promptContainer, containerId);\r\n                index_7.default.init(promptContainer, positivePrompts, containerId);\r\n                index_8.default.init(promptContainer, containerId);\r\n                index_9.default.initButton(positivePrompts);\r\n                index_10.default.initButton(positivePrompts);\r\n                index_11.default.initButton(positivePrompts);\r\n                index_8.default.initButton(positivePrompts);\r\n                if (domContainer.promptBrowser && !state.showViews.includes(\"known\")) {\r\n                    domContainer.promptBrowser.style.display = \"none\";\r\n                }\r\n                if (domContainer.currentPrompts && !state.showViews.includes(\"current\")) {\r\n                    domContainer.currentPrompts.style.display = \"none\";\r\n                }\r\n                if (!state.showViews.includes(\"positive\"))\r\n                    positivePrompts.style.display = \"none\";\r\n                if (!state.showViews.includes(\"negative\"))\r\n                    negativePrompts.style.display = \"none\";\r\n            }\r\n            if (container.seed)\r\n                domContainer.seedInput = mainContainer.querySelector(`#${container.seed} input`);\r\n            if (container.width)\r\n                domContainer.widthInput = mainContainer.querySelector(`#${container.width} input`);\r\n            if (container.height)\r\n                domContainer.heightInput = mainContainer.querySelector(`#${container.height} input`);\r\n            if (container.steps)\r\n                domContainer.stepsInput = mainContainer.querySelector(`#${container.steps} input`);\r\n            if (container.cfg)\r\n                domContainer.cfgInput = mainContainer.querySelector(`#${container.cfg} input`);\r\n            if (container.sampling)\r\n                domContainer.samplingInput = mainContainer.querySelector(`#${container.sampling} input`);\r\n            if (container.gallery) {\r\n                domContainer.imageArea = PromptsBrowser.gradioApp().querySelector(`#${container.gallery}`);\r\n                index_12.default.init(domContainer.imageArea, containerId);\r\n            }\r\n        }\r\n        index_2.default.init(mainContainer);\r\n        index_3.default.init(mainContainer);\r\n        index_4.default.init(mainContainer);\r\n        index_5.default.init(mainContainer);\r\n        index_9.default.init(mainContainer);\r\n        index_10.default.init(mainContainer);\r\n        index_11.default.init(mainContainer);\r\n        index_6.default.update();\r\n        index_12.default.update();\r\n        index_7.default.update();\r\n        index_8.default.update();\r\n    };\r\n    exports.default = PromptsBrowser;\r\n    PromptsBrowser.loadConfig();\r\n    document.addEventListener('DOMContentLoaded', function () {\r\n        PromptsBrowser.loadUIConfig();\r\n        index_1.default.load();\r\n        PromptsBrowser.init();\r\n    });\r\n});\r\n","define([\"require\", \"exports\"], function (require, exports) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const initialState = {\r\n        config: {\r\n            belowOneWeight: 0.05,\r\n            aboveOneWeight: 0.02,\r\n            toLowerCase: true,\r\n            spaceMode: \"space\",\r\n            showPromptIndex: false,\r\n            autocomplitePromptMode: \"all\",\r\n            cardWidth: 50,\r\n            cardHeight: 100,\r\n            splashCardWidth: 200,\r\n            splashCardHeight: 300,\r\n            rowsInKnownCards: 3,\r\n            maxCardsShown: 1000,\r\n            resizeThumbnails: true,\r\n            resizeThumbnailsMaxWidth: 300,\r\n            resizeThumbnailsMaxHeight: 300,\r\n            resizeThumbnailsFormat: \"JPG\",\r\n            /**\r\n             * If true, will enable extended syntax element support for prompts used by some addons.\r\n             */\r\n            supportExtendedSyntax: true,\r\n            saveStyleMeta: {\r\n                positive: true,\r\n                seed: false,\r\n                size: false,\r\n                quality: false,\r\n                sampler: false,\r\n                negative: false,\r\n            },\r\n            updateStyleMeta: {\r\n                positive: true,\r\n                seed: false,\r\n                size: false,\r\n                quality: false,\r\n                sampler: false,\r\n                negative: false,\r\n            },\r\n        },\r\n        dragInfo: {},\r\n        promptTools: {},\r\n        showControlPanel: true,\r\n        showViews: [\"known\", \"current\", \"positive\", \"negative\"],\r\n        currentContainer: \"text2Img\",\r\n        currentPromptsList: {},\r\n        selectedPrompt: undefined,\r\n        editingPrompt: undefined,\r\n        filesIteration: (new Date().valueOf()),\r\n        filterCategory: undefined,\r\n        filterName: undefined,\r\n        filterCollection: undefined,\r\n        filterTags: undefined,\r\n        filterStyleCollection: undefined,\r\n        filterStyleName: undefined,\r\n        newStyleCollection: undefined,\r\n        sortKnownPrompts: undefined,\r\n        copyOrMoveTo: undefined,\r\n        //dragItemId: undefined,\r\n        //dragCurrentIndex: undefined,\r\n        //promptToolsId: undefined,\r\n        collectionToolsId: undefined,\r\n        savePreviewCollection: undefined,\r\n        editTargetCollection: undefined,\r\n        editItem: undefined,\r\n        showStylesWindow: undefined,\r\n        showSaveStyleWindow: undefined,\r\n        showScriberWindow: undefined,\r\n        toggledButtons: [\"tools_tags\", \"tools_category\", \"tools_name\", \"tools_replaceMode\", \"new_in_all_collections\", \"styles_simplified_view\"],\r\n        selectedNewPrompts: [],\r\n        selectedCollectionPrompts: [],\r\n        promptsFilter: {},\r\n        autoGenerateType: \"prompt\",\r\n        //autoGenerateKeepCurrent: false,\r\n    };\r\n    exports.default = initialState;\r\n});\r\n","define([\"require\", \"exports\", \"client/index\", \"client/Database/index\", \"client/utils/index\", \"client/const\"], function (require, exports, index_1, index_2, index_3, const_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function onPromptCardHover(e) {\r\n        const { splashCardWidth = 200, splashCardHeight = 300 } = index_1.default.state.config;\r\n        const target = e.currentTarget;\r\n        const splash = target.querySelector(\".PBE_promptElementSplash\");\r\n        if (!splash)\r\n            return;\r\n        const BIG_CARD_HEIGHT = splashCardHeight;\r\n        splash.style.display = \"\";\r\n        const position = target.getBoundingClientRect();\r\n        const bottomPosition = position.y + position.height + BIG_CARD_HEIGHT;\r\n        if (bottomPosition < window.innerHeight)\r\n            splash.style.top = position.top + \"px\";\r\n        else\r\n            splash.style.top = (position.top - position.height - BIG_CARD_HEIGHT) + \"px\";\r\n        splash.style.left = position.left + \"px\";\r\n    }\r\n    /**\r\n     * Shows prompt card\r\n     */\r\n    function showPromptItem({ prompt, options = {} }) {\r\n        const { cardWidth = 50, cardHeight = 100, splashCardWidth = 200, splashCardHeight = 300 } = index_1.default.state.config;\r\n        const { index = 0, parentGroup = false, isShadowed = false, noSplash = false, url } = options;\r\n        const { id = \"\", weight = const_1.DEFAULT_PROMPT_WEIGHT, isExternalNetwork = false, isSyntax = false } = prompt;\r\n        const imageSrc = url || index_2.default.getPromptPreviewURL(id, undefined);\r\n        const promptElement = document.createElement(\"div\");\r\n        const weightContainer = document.createElement(\"div\");\r\n        promptElement.className = \"PBE_promptElement PBE_currentElement\";\r\n        promptElement.style.backgroundImage = imageSrc;\r\n        promptElement.dataset.prompt = id;\r\n        promptElement.dataset.index = index + \"\";\r\n        if (parentGroup !== false)\r\n            promptElement.dataset.group = parentGroup + \"\";\r\n        promptElement.draggable = true;\r\n        if (isExternalNetwork)\r\n            promptElement.classList.add(\"PBE_externalNetwork\");\r\n        if (isShadowed)\r\n            promptElement.classList.add(\"PBE_shadowedElement\");\r\n        if (isSyntax)\r\n            promptElement.classList.add(\"PBE_syntaxElement\");\r\n        promptElement.style.width = `${cardWidth}px`;\r\n        promptElement.style.height = `${cardHeight}px`;\r\n        let promptName = id;\r\n        if (!isSyntax) {\r\n            promptName = (0, index_3.replaceAllRegex)(promptName, \"\\\\\\\\\", \"\");\r\n            promptName = (0, index_3.replaceAllRegex)(promptName, \":\", \": \");\r\n            promptName = (0, index_3.replaceAllRegex)(promptName, \"_\", \" \");\r\n            promptName = (0, index_3.replaceAllRegex)(promptName, \"{\", \"\");\r\n            promptName = (0, index_3.replaceAllRegex)(promptName, \"}\", \"\");\r\n            if (weight !== const_1.DEFAULT_PROMPT_WEIGHT) {\r\n                weightContainer.className = \"PBE_promptElementWeight\";\r\n                weightContainer.innerText = weight + \"\";\r\n                promptElement.appendChild(weightContainer);\r\n            }\r\n            if (weight < 1 && weight > 0.6) {\r\n                promptElement.style.transform = \"scale(0.9)\";\r\n                promptElement.style.zIndex = \"3\";\r\n                weightContainer.style.color = \"green\";\r\n            }\r\n            else if (weight <= 0.6 && weight > 0.4) {\r\n                promptElement.style.transform = \"scale(0.8)\";\r\n                promptElement.style.zIndex = \"2\";\r\n                weightContainer.style.color = \"blue\";\r\n            }\r\n            else if (weight <= 0.4) {\r\n                promptElement.style.transform = \"scale(0.7)\";\r\n                promptElement.style.zIndex = \"1\";\r\n                weightContainer.style.color = \"purple\";\r\n            }\r\n            if (weight > 1 && weight <= 1.2) {\r\n                promptElement.style.transform = \"scale(1.1)\";\r\n                promptElement.style.zIndex = \"4\";\r\n                weightContainer.style.color = \"orange\";\r\n            }\r\n            else if (weight > 1.2 && weight <= 1.3) {\r\n                promptElement.style.transform = \"scale(1.2)\";\r\n                promptElement.style.zIndex = \"5\";\r\n                weightContainer.style.color = \"orangered\";\r\n            }\r\n            else if (weight > 1.3) {\r\n                promptElement.style.transform = \"scale(1.3)\";\r\n                promptElement.style.zIndex = \"6\";\r\n                weightContainer.style.color = \"red\";\r\n            }\r\n        }\r\n        if (!noSplash && !isSyntax) {\r\n            const splashElement = document.createElement(\"div\");\r\n            splashElement.className = \"PBE_promptElementSplash PBE_currentElement\";\r\n            splashElement.style.backgroundImage = imageSrc;\r\n            splashElement.innerText = promptName;\r\n            splashElement.style.width = `${splashCardWidth}px`;\r\n            splashElement.style.height = `${splashCardHeight}px`;\r\n            splashElement.style.marginTop = `${cardHeight}px`;\r\n            if (weight !== const_1.DEFAULT_PROMPT_WEIGHT) {\r\n                splashElement.appendChild(weightContainer.cloneNode(true));\r\n            }\r\n            promptElement.appendChild(splashElement);\r\n            promptElement.addEventListener(\"mouseover\", onPromptCardHover);\r\n        }\r\n        promptElement.innerHTML += promptName;\r\n        return promptElement;\r\n    }\r\n    exports.default = showPromptItem;\r\n});\r\n","define([\"require\", \"exports\"], function (require, exports) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const supportedContainers = {\r\n        text2Img: {\r\n            prompt: \"txt2img_prompt_container\",\r\n            results: \"txt2img_results\",\r\n            gallery: \"txt2img_gallery_container\",\r\n            buttons: \"txt2img_generate_box\",\r\n            settings: \"txt2img_settings\",\r\n            seed: \"txt2img_seed\",\r\n            width: \"txt2img_width\",\r\n            height: \"txt2img_height\",\r\n            steps: \"txt2img_steps\",\r\n            cfg: \"txt2img_cfg_scale\",\r\n            sampling: \"txt2img_sampling\",\r\n        },\r\n        img2Img: {\r\n            prompt: \"img2img_prompt_container\",\r\n            results: \"img2img_results\",\r\n            gallery: \"img2img_gallery_container\",\r\n            buttons: \"img2img_generate_box\",\r\n            settings: \"img2img_settings\",\r\n            seed: \"img2img_seed\",\r\n            width: \"img2img_width\",\r\n            height: \"img2img_height\",\r\n            steps: \"img2img_steps\",\r\n            cfg: \"img2img_cfg_scale\",\r\n            sampling: \"img2img_sampling\",\r\n        }\r\n    };\r\n    exports.default = supportedContainers;\r\n});\r\n","define([\"require\", \"exports\", \"client/Database/index\", \"client/index\", \"client/ActivePrompts/index\", \"client/CurrentPrompts/index\", \"client/const\", \"client/utils/index\", \"client/utils/parseGroups\"], function (require, exports, index_1, index_2, index_3, index_4, const_1, index_5, parseGroups_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.synchroniseListToTextarea = void 0;\r\n    function createPromptObjects({ value, activePrompts, groupId, nestingLevel = 0, normalize = false }) {\r\n        const { state } = index_2.default;\r\n        const { data } = index_1.default;\r\n        const { supportExtendedSyntax = true } = state.config;\r\n        const KEEP_SYNTAX_SYMBOLS = [\"{\", \"}\", \"|\"];\r\n        const DELIMITER_CHAR = \",\";\r\n        const SPACE_CHAR = \" \";\r\n        let prompts = [];\r\n        if (supportExtendedSyntax) {\r\n            prompts = value.split(/([,{}|])/g);\r\n            prompts = prompts.filter(strItem => strItem);\r\n            prompts = prompts.map((strItem, i, arr) => {\r\n                if (typeof strItem !== \"string\")\r\n                    return strItem;\r\n                let trimStr = strItem.trim();\r\n                if (KEEP_SYNTAX_SYMBOLS.includes(trimStr)) {\r\n                    const prevItem = i > 0 ? arr[i - 1] : \"\";\r\n                    const nextItem = arr[i + 1];\r\n                    if (prevItem && prevItem[prevItem.length - 1] === SPACE_CHAR)\r\n                        strItem = SPACE_CHAR + strItem;\r\n                    if (nextItem && nextItem[0] === SPACE_CHAR)\r\n                        strItem += SPACE_CHAR;\r\n                }\r\n                return strItem;\r\n            });\r\n            prompts = prompts.filter(strItem => strItem && strItem.trim());\r\n        }\r\n        else {\r\n            prompts = value.split(\",\");\r\n            prompts = prompts.filter(strItem => strItem && strItem.trim());\r\n        }\r\n        for (let i = 0; i < prompts.length; i++) {\r\n            let promptItem = prompts[i];\r\n            if (!promptItem)\r\n                continue;\r\n            if (!promptItem || promptItem === \",\")\r\n                continue;\r\n            const { id, weight, isExternalNetwork, isSyntax = false, nestedWeight } = (0, index_5.promptStringToObject)({ prompt: promptItem, nestedWeight: 0 });\r\n            if (!id)\r\n                continue;\r\n            promptItem = id;\r\n            if (normalize && !isExternalNetwork && !isSyntax)\r\n                promptItem = (0, index_5.normalizePrompt)({ prompt: promptItem, state, data });\r\n            const targetItem = {\r\n                id: promptItem,\r\n                parentGroup: groupId,\r\n                weight: weight !== undefined ? weight : const_1.DEFAULT_PROMPT_WEIGHT\r\n            };\r\n            if (isExternalNetwork)\r\n                targetItem.isExternalNetwork = true;\r\n            /**\r\n             * If it is a syntax token - also checking if it needs delimiters on its sides in a string.\r\n             */\r\n            if (isSyntax) {\r\n                const prevItem = i > 0 ? prompts[i - 1] : \"\";\r\n                const nextItem = prompts[i + 1];\r\n                targetItem.isSyntax = true;\r\n                targetItem.delimiter = \"none\";\r\n                if (prevItem === DELIMITER_CHAR && nextItem === DELIMITER_CHAR)\r\n                    targetItem.delimiter = \"both\";\r\n                else if (prevItem === DELIMITER_CHAR)\r\n                    targetItem.delimiter = \"prev\";\r\n                else if (nextItem === DELIMITER_CHAR)\r\n                    targetItem.delimiter = \"next\";\r\n            }\r\n            activePrompts.push(targetItem);\r\n        }\r\n    }\r\n    function processGroup({ entityArray, activePrompts, normalize = false, nestingLevel = 0, groupId = false }) {\r\n        for (const entity of entityArray) {\r\n            if (typeof entity === \"string\") {\r\n                createPromptObjects({\r\n                    value: entity,\r\n                    normalize,\r\n                    activePrompts,\r\n                    nestingLevel,\r\n                    groupId,\r\n                });\r\n            }\r\n            else if (\"id\" in entity) {\r\n                const { id, weight, body } = entity;\r\n                const newGroup = {\r\n                    groupId: id,\r\n                    parentGroup: groupId,\r\n                    weight: weight,\r\n                    prompts: [],\r\n                };\r\n                activePrompts.push(newGroup);\r\n                processGroup({\r\n                    entityArray: body,\r\n                    activePrompts: newGroup.prompts,\r\n                    normalize,\r\n                    nestingLevel: nestingLevel + 1,\r\n                    groupId: id,\r\n                });\r\n                if (index_3.default.foldedGroups.length) {\r\n                    const keyForGroup = index_3.default.makeGroupKey(newGroup);\r\n                    if (keyForGroup && index_3.default.foldedGroups.includes(keyForGroup)) {\r\n                        newGroup.folded = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Synchronises text content of the textarea with the array of active prompts used by the extension.\r\n     */\r\n    function syncCurrentPrompts(noTextAreaUpdate = true, normalize = false) {\r\n        const { state } = index_2.default;\r\n        const textArea = index_2.default.DOMCache.containers[state.currentContainer].textArea;\r\n        if (!textArea)\r\n            return;\r\n        let value = textArea.value;\r\n        //trying to fix LORAs/Hypernetworks added without a preceding comma\r\n        value = value.replace(/([^,])\\ </g, \"$1,\\ <\");\r\n        const newActivePrompts = [];\r\n        processGroup({\r\n            entityArray: (0, parseGroups_1.parseGroups)(value),\r\n            activePrompts: newActivePrompts,\r\n            normalize,\r\n        });\r\n        index_3.default.setCurrentPrompts(newActivePrompts);\r\n        index_4.default.update(noTextAreaUpdate);\r\n    }\r\n    function syncListToTextareaBranch(activePrompts, prompts = []) {\r\n        for (const entity of activePrompts) {\r\n            if (\"groupId\" in entity) {\r\n                prompts.push({ text: \"(\", src: { id: \"(\", isSyntax: true, delimiter: \"prev\" } });\r\n                syncListToTextareaBranch(entity.prompts, prompts);\r\n                if (entity.weight)\r\n                    prompts.push({ text: `: ${entity.weight}`, src: { id: \"\", isSyntax: true, delimiter: \"none\" } });\r\n                prompts.push({ text: \")\", src: { id: \")\", isSyntax: true, delimiter: \"next\" } });\r\n                continue;\r\n            }\r\n            const { id, weight, isExternalNetwork } = entity;\r\n            if (isExternalNetwork) {\r\n                prompts.push({ text: `<${id}:${weight}>`, src: entity });\r\n            }\r\n            else {\r\n                if (weight !== undefined && weight !== const_1.DEFAULT_PROMPT_WEIGHT)\r\n                    prompts.push({ text: `(${id}: ${weight})`, src: entity });\r\n                else\r\n                    prompts.push({ text: id, src: entity });\r\n            }\r\n        }\r\n    }\r\n    function syncListToTextarea(activePrompts) {\r\n        const { state, DOMCache } = index_2.default;\r\n        const textArea = DOMCache.containers[state.currentContainer].textArea;\r\n        if (!textArea)\r\n            return;\r\n        const prompts = [];\r\n        textArea.value = \"\";\r\n        syncListToTextareaBranch(activePrompts, prompts);\r\n        let addTextValue = \"\";\r\n        for (let i = 0; i < prompts.length; i++) {\r\n            const { text, src } = prompts[i];\r\n            const nextPromptSrc = prompts[i + 1] ? prompts[i + 1].src : undefined;\r\n            addTextValue += text;\r\n            let addDelimiter = true;\r\n            if (!nextPromptSrc)\r\n                addDelimiter = false;\r\n            else if (src.delimiter) {\r\n                if (src.delimiter === \"prev\" || src.delimiter === \"none\")\r\n                    addDelimiter = false;\r\n            }\r\n            else if (nextPromptSrc.delimiter) {\r\n                if (nextPromptSrc.delimiter === \"next\" || nextPromptSrc.delimiter === \"none\")\r\n                    addDelimiter = false;\r\n            }\r\n            if (nextPromptSrc && text === \")\" && nextPromptSrc.id === \")\")\r\n                addDelimiter = false;\r\n            if (addDelimiter)\r\n                addTextValue += \", \";\r\n        }\r\n        textArea.value = addTextValue;\r\n        //Just to be sure every api listening to changes in textarea done their job\r\n        textArea.dispatchEvent(new Event('focus'));\r\n        textArea.dispatchEvent(new Event('input'));\r\n        textArea.dispatchEvent(new KeyboardEvent('keyup'));\r\n        textArea.dispatchEvent(new KeyboardEvent('keypress'));\r\n        textArea.dispatchEvent(new Event('blur'));\r\n    }\r\n    exports.synchroniseListToTextarea = syncListToTextarea;\r\n    exports.default = syncCurrentPrompts;\r\n});\r\n","define([\"require\", \"exports\"], function (require, exports) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.AddStyleType = void 0;\r\n    var AddStyleType;\r\n    (function (AddStyleType) {\r\n        AddStyleType[\"UniqueOnly\"] = \"unique only\";\r\n        AddStyleType[\"UniqueRoot\"] = \"unique root\";\r\n        AddStyleType[\"All\"] = \"all\";\r\n    })(AddStyleType || (AddStyleType = {}));\r\n    exports.AddStyleType = AddStyleType;\r\n});\r\n","define([\"require\", \"exports\", \"client/ActivePrompts/index\", \"client/Database/index\", \"./promptStringToObject\", \"./parseGroups\"], function (require, exports, index_1, index_2, promptStringToObject_1, parseGroups_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.log = exports.isInSameCollection = exports.randomIntFromInterval = exports.addStrToActive = exports.stringToPromptsArray = exports.promptStringToObject = exports.parseGroups = exports.normalizePrompt = exports.makeFileNameSafe = exports.replaceAllRegex = exports.clone = void 0;\r\n    exports.promptStringToObject = promptStringToObject_1.default;\r\n    exports.parseGroups = parseGroups_1.default;\r\n    const regex = {\r\n        REGX_SINGLE_UNDERSCORE: /(?<!_)_(?!_)/g,\r\n    };\r\n    function clone(obj) {\r\n        if (structuredClone)\r\n            return structuredClone(obj);\r\n        else\r\n            return JSON.parse(JSON.stringify(obj));\r\n    }\r\n    exports.clone = clone;\r\n    function replaceAllRegex(str, oldStr, newStr) {\r\n        if (!str || !oldStr)\r\n            return str;\r\n        return str.replace(new RegExp(oldStr, 'g'), newStr);\r\n    }\r\n    exports.replaceAllRegex = replaceAllRegex;\r\n    ;\r\n    /**\r\n     * Make sure to update server-side makeFileNameSafe method as well\r\n     */\r\n    function makeFileNameSafe(fileName) {\r\n        if (!fileName)\r\n            return;\r\n        const { REGX_SINGLE_UNDERSCORE } = regex;\r\n        fileName = replaceAllRegex(fileName, REGX_SINGLE_UNDERSCORE, \" \");\r\n        //unix/win\r\n        fileName = replaceAllRegex(fileName, \"/\", \"_fsl_\");\r\n        //win\r\n        fileName = replaceAllRegex(fileName, \":\", \"_col_\");\r\n        fileName = replaceAllRegex(fileName, \"\\\\\\\\\", \"_bsl_\");\r\n        fileName = replaceAllRegex(fileName, \"<\", \"_lt_\");\r\n        fileName = replaceAllRegex(fileName, \">\", \"_gt_\");\r\n        fileName = replaceAllRegex(fileName, \"\\\"\", \"_dq_\");\r\n        fileName = replaceAllRegex(fileName, \"\\\\|\", \"_pip_\");\r\n        fileName = replaceAllRegex(fileName, \"\\\\?\", \"_qm_\");\r\n        fileName = replaceAllRegex(fileName, \"\\\\*\", \"_ast_\");\r\n        fileName = fileName.trim();\r\n        return fileName;\r\n    }\r\n    exports.makeFileNameSafe = makeFileNameSafe;\r\n    /**\r\n     * Modifies prompt input so that prompts conform to the same style.\r\n     * @param {*} prompt\r\n     * @returns\r\n     */\r\n    function normalizePrompt({ prompt, state, data }) {\r\n        const { unitedList } = data;\r\n        const { config } = state;\r\n        const { REGX_SINGLE_UNDERSCORE } = regex;\r\n        if (!prompt)\r\n            return prompt;\r\n        prompt = prompt.trim();\r\n        if (!prompt)\r\n            return prompt;\r\n        //do not modify saved prompts\r\n        if (unitedList[prompt])\r\n            return prompt;\r\n        //Skip external networks prompts.\r\n        if (prompt.startsWith(\"<\") && prompt.endsWith(\">\"))\r\n            return prompt;\r\n        if (config.toLowerCase)\r\n            prompt = prompt.toLowerCase();\r\n        if (config.spaceMode === \"space\")\r\n            prompt = prompt.replaceAll(REGX_SINGLE_UNDERSCORE, \" \");\r\n        else if (config.spaceMode === \"underscore\")\r\n            prompt = prompt.replaceAll(\" \", \"_\");\r\n        return prompt;\r\n    }\r\n    exports.normalizePrompt = normalizePrompt;\r\n    function stringToPromptsArray(str, supportExtendedSyntax) {\r\n        if (!str)\r\n            return false;\r\n        const promptsArray = [];\r\n        const arr = str.split(\",\");\r\n        for (let prompt of arr) {\r\n            prompt = prompt.trim();\r\n            if (!prompt)\r\n                continue;\r\n            const newPrompt = (0, promptStringToObject_1.default)({ prompt, supportExtendedSyntax });\r\n            promptsArray.push(newPrompt);\r\n        }\r\n        return promptsArray;\r\n    }\r\n    exports.stringToPromptsArray = stringToPromptsArray;\r\n    function addStrToActive(str, atStart = false, supportExtendedSyntax = false) {\r\n        const arr = stringToPromptsArray(str, supportExtendedSyntax);\r\n        if (!arr || !arr.length)\r\n            return;\r\n        const activePrompts = index_1.default.getCurrentPrompts();\r\n        const uniquePrompots = index_1.default.getUnique();\r\n        for (let prompt of arr) {\r\n            if (uniquePrompots.some(item => item.id === prompt.id))\r\n                continue;\r\n            atStart ? activePrompts.unshift(prompt) : activePrompts.push(prompt);\r\n        }\r\n    }\r\n    exports.addStrToActive = addStrToActive;\r\n    function log(message) {\r\n        console.log(message);\r\n    }\r\n    exports.log = log;\r\n    function randomIntFromInterval(min, max) {\r\n        return Math.floor(Math.random() * (max - min + 1) + min);\r\n    }\r\n    exports.randomIntFromInterval = randomIntFromInterval;\r\n    function isInSameCollection(promptA, promptB) {\r\n        let targetCollection = undefined;\r\n        for (const id in index_2.default.data.original) {\r\n            const collection = index_2.default.data.original[id];\r\n            const containsA = collection.some(item => item.id === promptA);\r\n            const containsB = collection.some(item => item.id === promptB);\r\n            if (containsA && containsB) {\r\n                targetCollection = id;\r\n                break;\r\n            }\r\n        }\r\n        return targetCollection;\r\n    }\r\n    exports.isInSameCollection = isInSameCollection;\r\n});\r\n","define([\"require\", \"exports\"], function (require, exports) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.parseGroups = void 0;\r\n    let assignGroupId = 0;\r\n    function parseBranch(str, container = []) {\r\n        let newStr = str;\r\n        let currChar = \"\";\r\n        let body = \"\";\r\n        let weightMarker = \"\";\r\n        let grabMarker = false;\r\n        let isEscape = false;\r\n        let isExternalNetwork = false;\r\n        while (str.length) {\r\n            if (isEscape) {\r\n                isEscape = false;\r\n                str = str.substring(1);\r\n                continue;\r\n            }\r\n            currChar = str.charAt(0);\r\n            if (currChar === \"\\\\\") {\r\n                isEscape = true;\r\n                body += \"\\\\\";\r\n                body += str.charAt(1);\r\n                str = str.substring(1);\r\n                continue;\r\n            }\r\n            if (currChar === \"<\")\r\n                isExternalNetwork = true;\r\n            else if (currChar === \">\")\r\n                isExternalNetwork = false;\r\n            if (isExternalNetwork) {\r\n                if (currChar === \"(\" || currChar === \")\" || currChar === \",\") {\r\n                    isExternalNetwork = false;\r\n                }\r\n                else {\r\n                    body += currChar;\r\n                    str = str.substring(1);\r\n                    newStr = str;\r\n                    continue;\r\n                }\r\n            }\r\n            if (currChar === \"(\") {\r\n                if (body)\r\n                    container.push(body);\r\n                body = \"\";\r\n                const { container: newContainer, newStr, weight } = parseBranch(str.substring(1), []);\r\n                str = newStr;\r\n                if (newContainer && newContainer.length) {\r\n                    let isGroup = true;\r\n                    //detect if it is a single prompt with weight or a group of prompts\r\n                    if (newContainer.length === 1 &&\r\n                        typeof newContainer[0] === \"string\" &&\r\n                        !newContainer[0].includes(\",\") &&\r\n                        !newContainer[0].includes(\"|\"))\r\n                        isGroup = false;\r\n                    if (isGroup) {\r\n                        container.push({\r\n                            id: assignGroupId,\r\n                            weight: weight ? Number(weight) : undefined,\r\n                            body: newContainer,\r\n                        });\r\n                        assignGroupId++;\r\n                    }\r\n                    else {\r\n                        if (weight)\r\n                            container.push(`(${newContainer}: ${weight})`);\r\n                        else\r\n                            container.push(`(${newContainer})`);\r\n                    }\r\n                }\r\n            }\r\n            else if (currChar === \")\") {\r\n                if (body)\r\n                    container.push(body);\r\n                body = \"\";\r\n                break;\r\n            }\r\n            else if (currChar === \":\") {\r\n                grabMarker = true;\r\n            }\r\n            else if (grabMarker) {\r\n                if (currChar === \".\" || (currChar >= \"0\" && currChar <= \"9\"))\r\n                    weightMarker += currChar;\r\n                else if (currChar !== \" \")\r\n                    grabMarker = false;\r\n            }\r\n            else\r\n                body += currChar;\r\n            str = str.substring(1);\r\n            newStr = str;\r\n        }\r\n        if (body)\r\n            container.push(body);\r\n        return { container, newStr, weight: weightMarker };\r\n    }\r\n    /**\r\n     * Parses prompts string and splices it to groups of strings based on group delimeter syntax.\r\n     * @param str\r\n     * @returns\r\n     */\r\n    function parseGroups(str) {\r\n        assignGroupId = 0;\r\n        const result = parseBranch(str);\r\n        return result.container;\r\n    }\r\n    exports.parseGroups = parseGroups;\r\n    exports.default = parseGroups;\r\n});\r\n","define([\"require\", \"exports\", \"client/const\"], function (require, exports, const_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    /**\r\n     * Converts prompt string to prompt object (including meta data like weight and external network).\r\n     * @param {*} promptItem\r\n     */\r\n    function promptStringToObject({ prompt, nestedWeight = 0, supportExtendedSyntax = true }) {\r\n        const KEEP_SYNTAX_SYMBOLS = [\"{\", \"}\", \"|\"];\r\n        if (supportExtendedSyntax && KEEP_SYNTAX_SYMBOLS.includes(prompt.trim()))\r\n            return { id: prompt, isSyntax: true };\r\n        else\r\n            prompt = prompt.trim();\r\n        //prompt weight\r\n        let weight = const_1.DEFAULT_PROMPT_WEIGHT;\r\n        //prompt is a marker for usage of LORA/Hypernetwork\r\n        let isExternalNetwork = false;\r\n        let currChar = \"\";\r\n        let isEscape = false;\r\n        let i = 0;\r\n        //entering weight\r\n        while (i < prompt.length) {\r\n            if (isEscape) {\r\n                isEscape = false;\r\n                i++;\r\n                continue;\r\n            }\r\n            currChar = prompt.charAt(i);\r\n            if (currChar === \"\\\\\") {\r\n                isEscape = true;\r\n                i++;\r\n                continue;\r\n            }\r\n            if (currChar !== \"(\")\r\n                break;\r\n            nestedWeight += 1;\r\n            i++;\r\n        }\r\n        //getting prompt weight\r\n        weight = Number(Math.pow(const_1.PROMPT_WEIGHT_FACTOR, nestedWeight).toFixed(2));\r\n        //outing weight\r\n        i = prompt.length - 1;\r\n        while (i < prompt.length) {\r\n            if (isEscape) {\r\n                isEscape = false;\r\n                i--;\r\n                continue;\r\n            }\r\n            currChar = prompt.charAt(i);\r\n            if (prompt.charAt(i - 1) === \"\\\\\") {\r\n                isEscape = true;\r\n                i--;\r\n                continue;\r\n            }\r\n            if (currChar !== \")\")\r\n                break;\r\n            nestedWeight -= 1;\r\n            i--;\r\n        }\r\n        //getting new prompt name without weight syntax characters\r\n        i = 0;\r\n        isEscape = false;\r\n        let newPromptItem = \"\";\r\n        while (i < prompt.length) {\r\n            currChar = prompt.charAt(i);\r\n            if (currChar === \"\\\\\") {\r\n                isEscape = true;\r\n                newPromptItem += currChar;\r\n                i++;\r\n                continue;\r\n            }\r\n            if ((currChar !== \"(\" && currChar !== \")\") || isEscape)\r\n                newPromptItem += currChar;\r\n            if (isEscape)\r\n                isEscape = false;\r\n            i++;\r\n        }\r\n        prompt = newPromptItem;\r\n        //detecting external network prompt\r\n        if (prompt.startsWith(\"<\") && prompt.endsWith(\">\")) {\r\n            isExternalNetwork = true;\r\n            prompt = prompt.substring(1);\r\n            prompt = prompt.substring(0, prompt.length - 1);\r\n        }\r\n        //detecting weight marker\r\n        if (prompt.includes(\":\")) {\r\n            const promptArr = prompt.split(\":\");\r\n            const weightDataItem = Number(promptArr.pop());\r\n            if (!Number.isNaN(weightDataItem)) {\r\n                const base = promptArr.join(\":\").trim();\r\n                prompt = base;\r\n                weight = weightDataItem;\r\n            }\r\n        }\r\n        const promptObject = { id: prompt, weight, isExternalNetwork, nestedWeight };\r\n        return promptObject;\r\n    }\r\n    exports.default = promptStringToObject;\r\n});\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./client/index.ts\");\n",""],"names":[],"sourceRoot":""}